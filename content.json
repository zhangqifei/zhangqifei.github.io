{"meta":{"title":"老朋友好久不见！","subtitle":"一天进步一点","description":"记录生活点点滴滴","author":"咻一咻","url":"https://www.zhangqifei.top","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2019-05-13T07:30:48.430Z","updated":"2019-05-13T07:30:48.430Z","comments":false,"path":"/404.html","permalink":"https://www.zhangqifei.top//404.html","excerpt":"","text":"回主页 · 所有文章 · 留言板以下是博主喜欢的一些歌曲，可以听听，稍作休息~"},{"title":"书单","date":"2018-04-22T11:44:27.830Z","updated":"2018-01-03T07:13:24.986Z","comments":false,"path":"books/index.html","permalink":"https://www.zhangqifei.top/books/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-05-13T08:50:49.011Z","updated":"2019-05-13T08:50:49.011Z","comments":true,"path":"links/index.html","permalink":"https://www.zhangqifei.top/links/index.html","excerpt":"","text":""},{"title":"github 仓库","date":"2018-04-22T11:44:27.857Z","updated":"2018-01-03T13:50:50.450Z","comments":false,"path":"repository/index.html","permalink":"https://www.zhangqifei.top/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-04-22T11:44:27.837Z","updated":"2018-01-03T07:13:24.987Z","comments":false,"path":"categories/index.html","permalink":"https://www.zhangqifei.top/categories/index.html","excerpt":"","text":""},{"title":"关于博主","date":"2018-04-22T11:44:27.822Z","updated":"2018-04-22T09:50:12.381Z","comments":true,"path":"about/index.html","permalink":"https://www.zhangqifei.top/about/index.html","excerpt":"","text":"明确了自己真正所热衷的事，并找到了与之匹配的职业 。为能如愿转职，开始利用业余时间，努力钻研，希望这一天尽早到来！ —— 2015年9月30日 白纸的地图如果把来找我咨询的人比喻成迷途的羔羊，通常他们手上都有地图，却没有去看，或是不知道自己目前的位置。你的地图是一张白纸，所以即使想决定目的地，也不知道路在哪里。可是换个角度看，正因为是一张白纸，才可以随心所欲地描绘地图，一切全在你自己。对你来说，一切都是自由地，在你面前是无限地可能。这可是很棒的事啊。 开博缘由在建立改造博客网站的过程中，学习和巩固前端基本知识通过写博客的方式，加深理解，显性化自己的隐性知识共享知识，吸引同好，交流进步 欢迎交流个人邮件及社交网站等信息见边栏底部有什么留言或问题直接在文末留下评论即可"},{"title":"标签","date":"2018-04-22T11:44:27.928Z","updated":"2018-01-03T07:13:24.991Z","comments":false,"path":"tags/index.html","permalink":"https://www.zhangqifei.top/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"测试测试测试测试","slug":"通知/1","date":"2019-08-01T01:41:22.000Z","updated":"2019-05-13T07:29:54.012Z","comments":true,"path":"2019/08/01/通知/1/","link":"","permalink":"https://www.zhangqifei.top/2019/08/01/通知/1/","excerpt":"","text":"测试","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zhangqifei.top/tags/Nginx/"}]},{"title":"恢复更新","slug":"通知/恢复更新","date":"2018-08-01T01:41:22.000Z","updated":"2019-05-13T07:29:54.012Z","comments":true,"path":"2018/08/01/通知/恢复更新/","link":"","permalink":"https://www.zhangqifei.top/2018/08/01/通知/恢复更新/","excerpt":"","text":"菜鸟终于决定要更新了！地址：https://www.zhangqifei.top/book/","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zhangqifei.top/tags/Nginx/"}]},{"title":"一次说清什么是正向代理，什么是反向代理？","slug":"随笔/一次说清什么是正向代理，什么是反向代理？","date":"2018-03-05T01:42:22.000Z","updated":"2018-04-23T07:12:14.352Z","comments":true,"path":"2018/03/05/随笔/一次说清什么是正向代理，什么是反向代理？/","link":"","permalink":"https://www.zhangqifei.top/2018/03/05/随笔/一次说清什么是正向代理，什么是反向代理？/","excerpt":"","text":"正向代理比如你现在缺钱，想找马云爸爸去借钱，可想而知人家可能鸟都不鸟你，到最后碰一鼻子灰借不到钱。不过你认识你家隔壁老王，而老王认识马云同志，而且关系还很好。这时候你托老王去找马云借钱，当然这事最后成了，你从马云那里借到了500万！这时候马云并不知道钱是你借的，只知道这钱是老王借的。最后由老王把钱转交给你。在这里，老王就充当了一个重要的角色：代理。 此时的代理，就是我们常说的正向代理。代理客户端去请求服务器，隐藏了真实客户端，服务器并不知道真实的客户端是谁。正向代理应用最广泛的莫过于现在的某些“科学上网工具”，你访问不了谷歌、Facebook的时候，你可以在国外搭建一台代理服务器，代理你访问，代理服务器再把请求到的数据转交给你，你就可以看到内容了 相对专业点解释： 正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。 反向代理比如你现在很无聊，想找人聊天，这时候你拨通了联通客服10010电话，联通的总机可能随机给你分配一个闲置的客服给你接通。这时候你如愿以偿的和客服聊了起来，问了问她目前有没有结婚、有没有对象、家住哪里、她的微信号、她的手机号。。。 此时联通总机充当的角色就是反向代理，你只知道和客服接通并聊了起来，具体为什么会接通这个客服MM，怎么接通的，你并不知道。 反向代理隐藏了真正的服务端，就像你每天使用百度的时候，只知道敲打www.baidu.com就可以打开百度搜索页面，但背后成千上万台百度服务器具体是哪一台为我们服务的，我们并不知道。我们只知道这个代理服务器，它会把我们的请求转发到真实为我们服务的那台服务器那里去。 软件层面一般常用Nginx来做反向代理服务器，它的性能非常好，用来做负载均衡。 相对专业点解释： 反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。 通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送 到代理服务器中。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。 综上所述：正向代理代理对象是客户端，反向代理代理对象是服务端。 两者区别从用途 上来讲： 正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。 另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。 从安全性 来讲： 正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。 反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。 最后一句话总结：打个比方，有a,b,c三个人正向代理是： a通过b向C借钱，a知道c的存在 。反向代理是： a向b借钱，b又向C借，a不知道c的存在。 原文链接 之所以转载这篇文章，是因为例子举的太好了，非常适合初学者理解。但是样式有点乱 自己稍微整理了下。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.zhangqifei.top/categories/随笔/"}],"tags":[]},{"title":"程序员为什么一定要用Linux？","slug":"随笔/程序员为什么一定要用Linux？","date":"2018-03-04T01:41:22.000Z","updated":"2018-04-23T07:12:14.222Z","comments":true,"path":"2018/03/04/随笔/程序员为什么一定要用Linux？/","link":"","permalink":"https://www.zhangqifei.top/2018/03/04/随笔/程序员为什么一定要用Linux？/","excerpt":"","text":"大多数人推荐Linux，基本上都会说Linux让你更高效、更优秀。 然而工具只是工具。 然而工具只是工具。 然而工具只是工具。 优秀程序员和不优秀程序员的区别首先是态度上的区别。 他们有自己的理想，思考很多，不管是项目开始之前还是在项目进行中，项目完成之后也会进行总结。 他们对待问题比较严谨，思考比较全面，在动手写代码之前肯定经过了一定的思考，对可能引入的问题进行预估。 而不优秀的程序员对待问题比较随意，也就是态度上不是那么认真，代码写的也比较随意：他们不会意识到他们的代码已经污染了整个项目。 除了态度上的不同，在能力上也有很大的差别。 遇到比较难缠的问题，优秀的程序员总是能从原理出发，一针见血的看出问题的真正原因，进而解决问题，而不优秀的程序员总是停留在表面——认为Linux会把你变得优秀就是停留在表面，只有你自己才能把你变优秀。 那么Linux的好处到底在哪里呢？ 1.开源 这个我想不用解释。 2.多用户、多任务、多线程 Linux系统同时可以支持多个用户，每个用户对自己的文件设备有特殊的权利，能够保证各用户之间互不干扰，就像手机开了助手一样，同时登陆多个qq账号，当硬件配置非常高时，每个用户还可以同时执行多个任务、多个线程同时工作、提高效率，简直是完美的一塌糊涂，单凭多用户而言就完爆其他操作系统。 3.稳定性和高效性 你也许会听到Windows服务器长时间运行而突然宕机，但你绝不会听到Linux系统服务器因为长时间不关机会卡死，在Linux上几乎是不会出现这种情况的。Linux服务器可以无休止的运行下去不宕机，因为它继承了Unix卓越的稳定性和高效性。正因为它的稳定才获得了众多用户的青睐，因为它的高效，它的使用范围更加广阔，然而Linux还可以提供一些高可靠性的服务，比如:LNMP、虚拟化、数据库服务等等。 4.安全性和SELinux 其安全性相比其他系统也要安全很多，由于Linux拥有相当庞大的用户和开源社区支持，因此能很快发现系统漏洞，并迅速发布安全补丁及时更新，同时还具有很强的“免疫力”特点，很少受到病毒攻击，对于一个开放式系统而言，在方便用户的同时，很可能存在安全隐患。不过，利用Linux自带防火墙（iptables，firewalld）、入侵检测和安全认证等工具，及时修补系统的漏洞，就能大大提高Linux系统的安全性，让黑客们无机可乘，同时还有安全增强机制SElinux，在linux内核中提供强制访问控制，功能非常全面，能够很好保护系统和服务，不过很多人喜欢把它关闭，这相对安全性就不是很好了。还有Tcp_wrappers也能够提供很好的网络服务访问控制，Linux系统对于用户和文件管理权限的管理也是相当出色的，能够很好的控制权限，保证文件的机密性，也是其他系统无法比拟，所以Linux系统在一定程度上是坚不可摧的。 5.性能优势 由于Linux要保证其稳定性，所以并没有像其它操作系统一样内核如此臃肿庞大、漏洞百出，随着Linux内核的不断更新，不断提升着优势，Linux操作系统能把服务器的硬件优势体现的淋漓尽致，因为Linux系统吸取了Unix系统近1/4世纪发展的经验，最主要的是Linux开放源代码，保证系统稳定性，更好的调用硬件功能，同时还提供了丰富的系统资源工具top，freee，df，vmstat，dmesg，iostat，sar，uptime等，方便查看资源的利用率。 以上这些足够让你投向Linux的怀抱了。当然，除了这些，还有一些说不定道不明的定西，比如： bigger than bigger把你的Linux系统拿出去，开始用命令行做点事情。比如说，输入sudo rm -rf /*在外行人看来，非常之酷炫！ 文章来源：https://www.zhihu.com/question/21048284/answer/170226604","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.zhangqifei.top/categories/随笔/"}],"tags":[]},{"title":"金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？","slug":"linux/金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？","date":"2018-02-07T11:42:22.000Z","updated":"2018-04-22T09:24:20.026Z","comments":true,"path":"2018/02/07/linux/金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？/","link":"","permalink":"https://www.zhangqifei.top/2018/02/07/linux/金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？/","excerpt":"","text":"根据 2017 年的 DevOps 发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。 作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不清楚这些术语背后的原理。本文试图总结当前主流的发布策略，每个的优劣，适用性，让开发人员特别是架构师对现代发布技术有一个更为清晰全面的认识，让大家能够根据自己的企业上下文，对发布策略做出正确的选型和实践。 一、单服务器组发布先解释下单服务器组的概念，早先我们机器资源比较紧张，不像现在云计算和虚拟化（包括容器技术）这么发达，所以应用机器基本是预先静态分配好的（一般由运维负责分配），原来应用 A 住在这 n 台机器上，那么下次升级发布的应用 A 也住在这 n 台机器上，所以称为单服务器组发布方式。 蛮力发布如下图所示，这种发布方式比较简单粗暴，有点像我们传统的软件升级方式，主要靠手工完成，先将老版本 V1 全部下掉，再将新版本发到机器上去。这种方式会引入服务中断（停机），在开发测试环境是可行的，但对于生产环境发布，其会直接影响用户的使用体验，这种方式一般是不建议的。 优势： 简单成本低 不足： 服务中断用户受影响，出了问题回退也慢 适用场合： 开发测试环境 非关键应用（用户影响面小） 初创公司什么都缺，找夜深人静用户访问量小的时间干 流量模式 蛮力发布会引入服务中断时间 金丝雀发布（单服务器组）在蛮力发布基础上的一种简单改进发布方式，目前仍然是不少成长型技术组织的主流发布方式。单服务器组下的金丝雀发布的简化步骤如下图所示： 实践要点 金丝雀发布一般先发 1 台，或者一个小比例，例如 2% 的服务器，主要做流量验证用，也称为金丝雀 (Canary) 测试（国内常称灰度测试）。以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。简单的金丝雀测试一般通过手工测试验证，复杂的金丝雀测试需要比较完善的监控基础设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回退的依据。 如果金丝测试通过，则把剩余的 V1 版本全部升级为 V2 版本。如果金丝雀测试失败，则直接回退金丝雀，发布失败。 优势： 用户体验影响小，金丝雀发布过程出现问题只影响少量用户 不足： 发布自动化程度不够，发布期间可引发服务中断 适用场合： 对新版本功能或性能缺乏足够信心 用户体验要求较高的网站业务场景 缺乏足够的自动化发布工具研发能力 流量模式 少量金丝雀先接受流量，再全量发布 滚动式发布（单服务器组）在金丝雀发布基础上的进一步优化改进，是一种自动化程度较高的发布方式，用户体验比较平滑，是目前成熟型技术组织所采用的主流发布方式。单服务器组下的滚动发布的简化步骤如下图所示： 实践要点 滚动式发布一般先发 1 台，或者一个小比例，如 2% 服务器，主要做流量验证用，类似金丝雀 (Canary) 测试。 滚动式发布需要比较复杂的发布工具和智能 LB，支持平滑的版本替换和流量拉入拉出。 每次发布时，先将老版本 V1 流量从 LB 上摘除，然后清除老版本，发新版本 V2，再将 LB 流量接入新版本。这样可以尽量保证用户体验不受影响。 一次滚动式发布一般由若干个发布批次组成，每批的数量一般是可以配置的（可以通过发布模板定义）。例如第一批 1 台（金丝雀），第二批 10%，第三批 50%，第四批 100%。每个批次之间留观察间隔，通过手工验证或监控反馈确保没有问题再发下一批次，所以总体上滚动式发布过程是比较缓慢的 (其中金丝雀的时间一般会比后续批次更长，比如金丝雀 10 分钟，后续间隔 2 分钟)。 回退是发布的逆过程，将新版本流量从 LB 上摘除，清除新版本，发老版本，再将 LB 流量接入老版本。和发布过程一样，回退过程一般也比较慢的。 滚动式发布国外术语通常叫 Rolling Update Deployment。 优势： 用户体验影响小，体验较平滑 不足： 发布和回退时间比较缓慢 发布工具比较复杂，LB 需要平滑的流量摘除和拉入能力 适用场合： 用户体验不能中断的网站业务场景 有一定的复杂发布工具研发能力； 流量模式 滚动式发布，流量平滑过渡， 二、双服务器组发布蓝绿发布仅适用于双服务器组发布，可以认为是对蛮力发布的一种简单优化发布方式。简化过程如下图所示： 实践要点 V1 版本称为蓝组，V2 版本称为绿组，发布时通过 LB 一次性将流量从蓝组直接切换到绿组，不经过金丝雀和滚动发布，蓝绿发布由此得名； 出现问题回退也很直接，通过 LB 直接将流量切回蓝组。 发布初步成功后，蓝组机器一般不直接回收，而是留一个待观察期，视具体情况观察期的时间可长可短，观察期过后确认发布无问题，则可以回收蓝组机器。 优势： 升级切换和回退速度非常快 不足： 切换是全量的，如果 V2 版本有问题，则对用户体验有直接影响； 需要两倍机器资源； 适用场合： 对用户体验有一定容忍度的场景 机器资源有富余或者可以按需分配（AWS 云，或自建容器云） 暂不具备复杂滚动发布工具研发能力； 流量模式 蓝绿发布一次完成流程切换 金丝雀发布（双服务器组）对蓝绿部署的一种简单优化，发布时先从绿组拉入 1 台金丝雀，待金丝雀验证通过再发全量。对比蓝绿发布，该发布方式的优势是有一个生产流量的金丝雀验证过程，可以减轻 V2 可能有问题的风险和影响面。简化发布过程如下图所示： 滚动式发布（双服务器组）滚动式发布是对上面的蓝绿和金丝雀发布的进一步优化，按批次增量滚动发布，提供更平滑的用户体验。 实践要点 发布前先申请一批新服务器，数量一般和 V1 版本相同，将 V2 版本应用发布到新服务器上。例如如果在 AWS 云上，则可以直接调用 API 申请一批新 VM，如果用容器云 Kubernetes，则可以直接启动一批新容器（使用 V2 版本容器镜像）。 一般会先通过 LB 拉入 1 台 V2 版本的机器，这台机器也相当于金丝雀，用于流量验证。 逐步按批次完成发布，每批只需要通过 LB 拉入 V2 版本，再拉出对应数量的 V1 版本。批次之间留有观察间隔，通过手工或监控反馈确保没有问题再继续发布。 发布有问题回退很快，直接通过 LB 将流量切回 V1 即可。 完成发布后，一般 V1 版本要保留观察以备万一，比如留 1 天，1 天后没有问题则回收 V1 机器资源。 优势： 用户体验影响小； 升级切换和回退（rollback）速度比单服务器组滚动发布要快，LB 切流量即可； 不足： 需要两倍机器资源； 发布工具比较复杂，LB 需要流量切换能力 适用场合： 用户体验不能中断的网站业务场景 机器资源有富余或者可以按需分配（AWS 云，或自建容器云） 有一定的发布工具研发能力； 流量模式 滚动式发布，流量平滑过渡 三、其它发布方式上述都是偏传统的发布方式，能覆盖大部分应用发布场景。针对一些关键新功能的上线发布，或者一些特定的场景，还有一些特殊的发布方式。 功能开关发布利用代码中的功能开关（Feature Flag/Toggle/Switch）来控制发布逻辑，一般不需要复杂的发布工具和智能 LB 配合，是一种相对比较低成本和简单的发布方式。这种方式也是支持现代 DevOps 理念，研发人员可以灵活定制和自助完成的发布方式。功能开关的原理如下图所示： 功能开关发布 实践要点 功能开关发布需要一个配置中心或者开关中心这样的服务支持，例如携程的 Apollo 配置中心附录 6.3，或者开源的 FF4J附录 6.4，这些都支持开关发布，业界还有专门的功能开关 SaaS 服务，例如 LaunchDarkly附录 6.5。通过配置中心，运维或研发人员可以在运行期动态配置功能开关的值。当然，功能开关发布只是配置中心的一种使用场景，配置中心还能支持其它很多动态配置场景。 功能开关服务一般提供客户端 SDK，方便开发人员集成。在运行期，客户端 SDK 会同步最新的开关值，技术实现有推方式 (push)，也有拉方式 (pull)，或者推拉结合方式。 新功能（V2 new feature）和老功能（V1 old feature）住在同一套代码中，新功能隐藏在开关后面，如果开关没有打开，则走老代码逻辑，如果开关打开，则走新代码逻辑。技术实现上可以理解为一个简单的 if/else 逻辑。 应用上线后，开关先不打开，然后运维或研发人员通过开关中心打开新功能，经过流量验证新功能没有问题，则发布完成；如果有问题，则随时可以通过开关中心切回老功能逻辑。 优势： 升级切换和回退速度非常快 相对于复杂的发布工具，实施比较简单，成本相对低廉 研发能够灵活定制发布逻辑，支持 DevOps 自助发布 不足： 切换是全量的，如果 V2 版本有问题，则对用户体验有直接影响； 对代码有侵入，代码逻辑会变复杂，需要定期清理老版本逻辑，维护成本变高 适用场合： 对用户体验有一定容忍度的场景 已有配置中心或开关中心服务 暂不具备研发复杂发布工具能力； 流量模式 通过功能开关一次完成流量切换 A/B 测试A/B 测试附录 7.10原来主要用于产品功能的比对测试，收集用户反馈和对比数据做产品功能设计的决策。实际上，A/B 测试也可以作为一种新功能发布技术。下图展示基于 LB 实现的一种 A/B 测试发布。 实践要点 上图中，原来 PC 端和手机端都访问老版本 V1 服务（也称 A 组或控制组），当 V2 新版本（也称 B 组或实验组）发布以后，为了验证 V2 的功能正确性，同时也为了避免 V2 有问题时影响所有用户，先通过 LB 将手机端的流量切换到 V2 版本，经过一段时间的 A/B 比对测试和观察（主要通过用户和监控反馈），确保 V2 正常，则通过 LB 将全部流量切换到 V2。 基于 LB 方式实现 A/B 测试，LB 需要能够通过某种条件做流量路由，例如通过 client ip，设备类型，浏览器类型，甚至是定制的 HTTP Header 或查询字符串。 高级的 A/B 测试需要专门的平台支撑，wasabi附录 6.6就是 intuit 开源的一个支持高级 A/B 测试的平台，这类平台可以细粒度到针对某类用户做 A/B 测试，例如针对某个地区的用户，某个年龄段的用户，公司内部用户等等。举了例子，假设一个关键业务的新功能上线，为了降低风险采用 A/B 测试，可以做到先只让公司内部员工能访问到新功能，待新功能验证过，再全量放开给外部用户使用。 功能开关和 A/B 测试有点相似，但功能开关一般是无状态和全量的，无法做到针对某类特定用户进行测试，而 A/B 测试一般是有状态的，能够跟踪事务和用户级别的状态，可以实现针对某类特定用户进行测试。 优势： 用户体验影响小； 可以使用生产流量测试； 可以做到针对某类特定目标用户进行测试； 不足： 搭建复杂度相对高，有一定技术门槛 适用场合： 核心关键业务，比如涉及资金的 具备一定的 A/B 测试平台研发能力 流量模式 针对某类目标用户进行 A/B 测试 影子测试对于一些涉及核心业务的遗留系统的升级改造，为了确保万无一失，有一种称为影子测试的大招，采用比较复杂的流量复制、回放和比对技术实现。下面是影子测试的一个样例架构图， 实践要点 目标实现老的 legacy 服务迁移升级到新的 experimental 服务。 测试开始前，需要在测试环境部署一份 legacy 服务和 experimental 服务，同时将生产数据库复制两份到测试环境。同时需要将生产请求日志收集起来，一般可以通过 kafka 队列收集，然后通过类似 goreplay附录 6.8这样的工具，消费 kafka 里头的请求日志，复制回放，将请求分发到 legacy 服务和 experimental 服务，收到响应后进行比对，如果所有响应比对成功，则可以认为 legacy 服务和 experimental 服务在功能逻辑上是等价的；如果有响应比对失败，则认为两者在功能逻辑上不等价，需要修复 experimental 并重新进行影子测试，直到全部比对成功。根据系统复杂度和关键性不同，比对测试时间短的可能需要几周，长的可达半年之久。 影子测试因为旁路在独立测试环境中进行，可以对生产流量完全无影响。 影子测试一般适用于遗留系统的等价重构迁移，例如.net 转 Java，或者 SQLServer 数据库升级为 MySQL 数据库，且外部依赖不能太多，否则需要开发很多 mock，测试部署成本会很高，且比对测试更加复杂和不稳定。 当当网有一个比较成功的交易系统.NET 转 Java 迁移项目附录 6.9，采用了影子测试技术，值得参考借鉴。 优势： 对生产用户体验完全无影响 可以使用生产真实流量进行测试（复制比对） 不足： 搭建复杂度很高，技术门槛高，数据库的导出复制是难点 外部依赖不能太多，否则测试部署成本很高，且比对测试更加复杂和不稳定 适用场合： 核心关键业务，比如涉及资金的 具备一定影子测试平台研发能力，包括流量复制、数据库导出复制和分发比对系统。 流量模式 影子测试对生产流量无影响 四、比较下表对各种发布策略，从各个维度进行综合比较，供参考： 五、结论和建议下面是对发布策略的一些选型建议，供不同阶段公司参考： 蛮力发布一般是不建议采用的，除非是开发测试环境，用户体验不敏感的非关键应用，或者是创业期什么都缺时候的无奈之举。 如果暂时还不具备研发较复杂的滚动发布工具和配套智能 LB，则功能开关是一种不错的轻量级发布技术，投入相对较小的成本，可以让研发人员灵活定制发布逻辑。 金丝雀发布通过少量新版本服务器接收生产流量的方式去验证新版本，可以显著降低风险。金丝雀发布适用于大部分场景，一般成长型公司就可以采用。 对于达到一定业务体量的公司，考虑到用户体验对业务的关键性，则需要投入研发资源开发支持滚动式发布的工具和配套的智能 LB，实现自动化和零停机的发布。滚动式发布一般和金丝雀发布配合，先发一台金丝雀去验证流量，再按批次增量发布。 随着轻量级虚拟化（例如容器）的普及，双服务器组发布方式具有更快的发布和回退速度，是值得投入的高级发布技术。蓝绿部署仅适用于双服务器组，滚动式发布既可以在单服务器组上实现，也可以在双服务器组上实现。 对于涉及关键核心业务的新功能上线，采用 A/B 测试，可以显著降低发布风险，A/B 测试是唯一一种支持针对特定用户组进行生产测试的高级发布技术。当然 A/B 测试的投入不低，建议有一定研发能力的组织采用。 对于关键核心业务的迁移重构，为确保万无一失，最后的一个大招是影子测试，影子测试对生产流量和用户完全无影响。当然这个大招的投入成本和门槛都高，建议有足够业务体量和研发能力的组织投入。 上述的各种发布策略并不是非此即彼的，一个公司常常会综合采用多种发布技术作为互补，实现灵活的发布能力。例如主流的发布手段是金丝雀 + 滚动式发布，某些业务线可能根据业务场景需要采用功能开关发布，还有一些业务线则可能采用高级的 A/B 测试发布手段。 六、附录https://github.com/ContainerSolutions/k8s-deployment-strategies https://opensource.com/article/18/2/feature-flags-ring-deployment-model https://github.com/ctripcorp/apollo http://www.ff4j.org/ https://launchdarkly.com/ https://github.com/intuit/wasabi https://blog.zenika.com/2017/04/19/migration-dun-legacy-avec-goreplay/ https://github.com/buger/goreplay http://blog.shurenyun.com/untitled-9/ https://en.wikipedia.org/wiki/A/B_testing","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"发布","slug":"发布","permalink":"https://www.zhangqifei.top/tags/发布/"}]},{"title":"吐血推荐珍藏的Chrome插件","slug":"工具/吐血推荐珍藏的Chrome插件","date":"2018-01-08T00:33:59.000Z","updated":"2018-04-23T07:11:04.528Z","comments":true,"path":"2018/01/08/工具/吐血推荐珍藏的Chrome插件/","link":"","permalink":"https://www.zhangqifei.top/2018/01/08/工具/吐血推荐珍藏的Chrome插件/","excerpt":"","text":"你应该知道的的Chrome插件！！！ Momentum装逼利器，教你如何优雅的使用Chrome，新打开一个Tab的时候再也不是一片空白，每天一副精美图片，给你们看下我今天的桌面感受下。链接地址 OneTab 强烈推荐，使用场景是这样的，我们使用Chrome经常会一次打开好多tab，很多是会用到的，又不舍得关，内存又耗着，这个时候点击下OneTab，直接把所有tab回收，然后每天的历史都给你记录着，接着你可以一键还原某一天的tab，真乃为Chrome而生。链接地址 ZenHubZenHub增压您GitHub上的工作流程.ZenHub是第一个也是唯一的项目管理套件的作品本身内GitHub上;提高您的工作流程，专为初创内置功能，快速移动的工程团队，以及开源社区。该产品是一款浏览器扩展，注入先进的功能，包括实时拖动和拖放发行任务板，通过 1按钮同行的反馈，并直接上传任何文件类型到GitHub的接口支持。 ZenHub可以很容易地集中所有进程到GitHub上，保持你的团队的精益和敏捷。 链接地址 草料二维码点击生成当前网址二维码,草料二维码插件，实现快速获取二维码。链接地址 Adblock Plus您有没有遇到过在使用chrome浏览器看视频或者是阅读文章的时候突然冒出一个大尺度的广告挡住了您的视线，不过这也可能还算是好的，如果那个大尺度的广告还没有关闭按钮的话我想您可能都有骂人的冲动了吧，而对于一篇自己喜欢的文章或者是喜爱的电影来说又舍不得放弃该怎么办？而今天为大家推荐的这款广告拦截插件：Adblock Plus可以轻松地帮您脱离”困境“。链接地址 开发工具箱功能比较强大，软件开发中常用的一些小工具这里都有，非常方便和全面字符串编码解码 二维码生成 加密解密 HTML/JS/CSS 常用对照表。链接地址 WEB前端助手(FeHelper)FE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成与解码、编码规范检测、页面性能检测、页面取色、Ajax接口调试。链接地址 Postman这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。链接地址 skyZIP™ ProxyskyZIP浏览器扩展是完美的匿名互联网访问，如VPN服务，可以做更多，更快。skyZIP可以通过使用高性能代理服务器来优化网页，从而减少数据使用量。数据节省约50％.许多网站没有优化 - 但skyZIP正在将图像转码为WebP无损格式，因此产生的图像缩小了80％。链接地址 Listen 1我想大部分人对听音乐是强需求吧？如果没有音乐，那么你的生活里将不在有色彩。有人喜欢用网易云音乐、有人喜欢用虾米、QQ 音乐等，但是想大家不可能同时装这么多客户端吧？因为版权的原因，每个在线音乐网站都没有做到完全的曲库，你又不可能把每个音乐网站都买上会员，所以有时候你需要去不同的网站搜索音乐，这个时候请使用 Listen 1，简直不要太良心。界面也有点极客范，堪称程序员专属听歌工具。但是，Listen 1 并没有在 Chrome 应用商店上架，而是以开源的方式放在了 GitHub，只需要下载并让 Chrome 以开发者模式加载即可，安装方式见 GitHub 项目描述。链接地址 iBookmark Bookmarks 收藏夹打造最好用的Chrome书签收藏夹插件，特性如下： 将收藏夹以列表展示，相比树形图不用层层点击，可以直接看到所有网址； 支持搜索，快速查找； 支持在某分类下面新建收藏站点； 点击网址icon图标，可以对该书签进行修改以及删除操作； 支持最常访问统计，将常用网址置顶； 支持最新添加的网址展示。 持续更新中·······","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://www.zhangqifei.top/categories/浏览器/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://www.zhangqifei.top/tags/Chrome/"}]},{"title":"如何管理自己的时间？","slug":"随笔/如何管理自己的时间","date":"2017-10-09T04:35:22.000Z","updated":"2018-04-23T07:12:14.462Z","comments":true,"path":"2017/10/09/随笔/如何管理自己的时间/","link":"","permalink":"https://www.zhangqifei.top/2017/10/09/随笔/如何管理自己的时间/","excerpt":"","text":"我们每天都工作，生活。但有时候，每天都很忙碌，却不知道自己在忙些什么。每个人的时间都是有限的，我不想碌碌无为，终其一生。我需要知道自己做了些什么，为什么做，在哪个时候做。我以《Getting Things Done》与《小强升职记》为主，《番茄工作法》为辅，构建自己的时间管理体系。 Getting Things Done3个东西：确定目标，横向管理，纵向管理 确定目标：你如何判断你的目标，确定做事情的优先级？ 与同龄人沟通，一个人有时候会有太大的孤单感 与高等级比自己强大的人沟通（比如corey） 自我测验（如小强升职记） 横向管理 这个流程图记录了一件事情如何进入gtd系统，最后被处理的 纵向管理是管理一个比较大的，重要的项目需要做的事情。 有着自己想达到的目标和原则 想想可能达到的结果，最好的，最坏的。 头脑风暴，把跟这个项目关联的，所有信息都记录下来，不做评判 整理目标原则，整理结果展望，整理头脑风暴信息。 确定下一步该干什么 作者任务的观点 清空大脑（专注） 生活中只存在两个问题： 你知道要达到的目标，但不知道怎么去做？ 你不知道你的目标是什么？ 我们的最终目标是把各种工作和情况赶出你的大脑，但绝不丢弃有潜在价值的想法 小强升职记这是一本比较实用的时间管理，个人管理书籍，值得深读，精读，多读。 寻找种子 时间日志，找出时间黑洞，找出高效时间段，工作时间段法（基本的时间管理） 何为重要的事情，寻找自己的价值观，《职业价值观自测表》 让种子发芽 四象限法则 猴子法则：学会说NO, 合理安排时间 脑袋同时只装一件事情 gtd 长出主干和枝桠 smart原则 分解 绿叶充实枝干 习惯的养成 摘下够得着的果实 每日回顾，反思和总结 处理零时突发事件 问题如何处理中断？ 番茄工作法该方法，最总要的一个目的是讲一天的时间分成一个个不可分割的原子时间，确保原子时间内，保持高度集中。 番茄工作法是一套pdca流程（戴明环） 五个基本问题这是一本什么类型的书？实用类型 这本书描述了什么？描述了如何运用番茄工作法，使自己如何在一天中专注的做事情。 计划：早上起来，计划一天做的事情 跟踪：执行，定闹钟循环的执行（专注工作-休息-专注工作-休息…） 记录与分析：记录完成情况（记录中断数），分析改进的方式 可视化：执行改进方式 在跟踪中，使用一个个番茄时间跟踪完成。 作者的观点 一次只干一件事（专注） 大项目拆分成小项目 分清事情优先级 总结与反思 说no, 把预估当成承诺 清空脑子 树立自信心（ 前怕狼后怕虎，害怕失败和批评） 没有什么完美主义（完美主义，碍手碍脚） 今日待办是一种承诺。 预估，根据历史记录预估，虽然有一些偏差 番茄工作法是一套pdca流程（戴明环） 是否有道理？感觉更gtd说的比较像，只是更加专注于每一天的处理控制。 番茄工作法是一套pdca流程（戴明环） 自身经验不会做时间管理，真在寻找一种合适自己的方式。感觉该方法比较死板。 对我的用处 看该方法是否适合我 结合gtd构建自己的时间管理系统 重要句子已在作者观点与书的描述中，提炼总结 提问如何处理中断？中断分为内部中断和外部中断。根据事情的紧急情况做区分。 不紧急：记录在收集箱中，继续当前番茄时间，延后分类处理 紧急：作废当前番茄时间，处理紧急事情。 如何预估一个任务需要的时间？根据历史预估，然后当天总结反馈。调整，再预估，迭代处理。 我的时间管理 确定自己的方向目标 用滴答清单，在收集箱中随时记录想到的东西 早上坐地铁，想想今天的事情 根据目标确定每一天/每一周/每一月的重要事情（四象限法则） 将复杂项目分解，成具体的可执行的下一步行动 每一天专注，我不适合使用番茄法。从清单中拿出一件事情，中断根据重要情况，紧急情况做适当处理，参加《小强升职记》中老付的处理方式 晚上回去，想想今天做了什么，为什么做？有什么改进的地方。 向往着更好的生活，更自由的时间，我一直在这条路上奔跑，good luck。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.zhangqifei.top/categories/随笔/"}],"tags":[]},{"title":"注意啦!","slug":"通知/注意啦！","date":"2017-09-28T07:12:09.000Z","updated":"2019-05-13T07:29:54.012Z","comments":true,"path":"2017/09/28/通知/注意啦！/","link":"","permalink":"https://www.zhangqifei.top/2017/09/28/通知/注意啦！/","excerpt":"","text":"CSDN博客地址为： https://blog.csdn.net/qq_37187976/ 原有文章不迁移。 iPage Web Hosting for only $1.99/Month","categories":[{"name":"通知","slug":"通知","permalink":"https://www.zhangqifei.top/categories/通知/"}],"tags":[]},{"title":"如何阅读一本书？","slug":"随笔/如何阅读一本书","date":"2017-09-04T01:35:22.000Z","updated":"2018-04-23T07:12:14.323Z","comments":true,"path":"2017/09/04/随笔/如何阅读一本书/","link":"","permalink":"https://www.zhangqifei.top/2017/09/04/随笔/如何阅读一本书/","excerpt":"","text":"工欲善其事必先利其器，对于我们这些已经脱离了学校的指导学习的热，如果想要不断提高自己，就必须学会自我驱动学习。在自我驱动学习中，书籍成为我们获取知识的重要途径。如何从一本书中汲取知识成为重中之重。 我以艾德勒的《如何阅读一本书》为基本框架，以赵周的《这样读书就够了》与秋叶的《如何高效读懂一本书》为辅，构建我的读书体系。 概述一图胜千言 读《如何阅读一本书》精读，分析阅读。 思维导图 五个基本问题1. 这本书什么类型？实用类型，指导类型，方法论 2. 这本书说了什么？阅读的价值，阅读的四个层次（基础阅读，检视阅读，分析阅读，主题阅读），他们成包含关系。以及如何做笔记等等 3. 作者观点是？阅读使人灵活。阅读要主动阅读（提问题，找答案）。 4. 所得是否有道理，还是部分有道理？ 比较赞同阅读分层结构。分析阅读与对比阅读。 有点啰嗦，一个东西不同说法如“要理性判断，不做无理的辩驳”与“尊重知识与个人意见的不同，在做任何评判之前找到理论依据”。 比较适用于精读一本书或建立某个主题的知识体系。 这么读，时间成本有点高。 5. 对我有什么价值？我怎么运用？ 有一个较为系统的读书方法。全局观。 基础阅读，读书识字。 检视阅读，确定阅读价值与作者的观点，这里需要确定是否有价值，作者大概说了什么。 分析阅读，确定骨架，主旨，事实上，包含检视阅读。输出思维导图，一些重要思想与主旨。评判作者对与否 主题阅读，没有完美的书，不听信一家之言。完成一类主题的思维导图输出，构建该主题的知识骨架/框架。如同有招到无招的境界。 构建一个主题（如数据库，摄影等等）的知识体系的方法，就用这种方式。 重要语句摘录 阅读技巧不仅仅可以运用于书籍，还可以运用于其他的地方，如报纸，杂志，文章，新闻，甚至是广告。 一个技能或一个习惯，都是由一系列的动作组成。 为了忘掉这些单一的动作，一开始你必须先学会每一个动作。 思考、感觉、想象是主动阅读（多提问题，然后寻找答案）的重要组成部分。 自问自答1. 第一个主要议题是什么自我管理的阅读者 2. 第二个主要议题主动阅读的四个基本问题 3. 如何对书籍分类？我觉得应该根据用途来区分，毕竟学以致用 4. 检视阅读的两个阶段是在什么时候完成？第一个阶段，拿到一本新书确认是否有读的必要和价值。第二个阶段，确认可以读，完成一遍粗读，知道在讲什么。 5. 分析阅读的几个阶段是并行完成？第一二个阶段，如果可能，应该在检视阅读中完成。第三个阶段需要阅读完成，一定思考，理解后。 6. 主题阅读是主题分享？请一个主题的若干作者一起来讨论一个主题。 分享沙龙无招胜有招。 读《这样读书就够了》检视阅读，粗读 思维导图 问题1. 这本书什么类型？这本书说了什么？ 实用类，关于如何读书，如何拆书，以及拆书现场的一些的东西。 提出了一个读书方式：拆书帮便签法。 认为读书带目的 读一本书，不一定要整本书，选着对自己有价值的读就可以了。 生存余力=生存力量/生存负债 2. 是否有道理？ 这本书有一半的时间在说拆书家如何如何，没啥价值 比较赞同读书带目的，读书不一定全本书都读，可以选着对自己的有用的部分。 3. 对我有什么价值？书签法，有点用，其核心大概是： 用自己的话复述书的核心价值。 联系自己的相关经验，有相似的地方么 思考，可以怎么用，进行知识归类。 可以用于读消遣书，或不需要分析阅读、精读的书。 读《如何高效读懂一本书》检视略读，初步判断，该书，就是一本个人解读的书单。有时间再细看。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.zhangqifei.top/categories/随笔/"}],"tags":[]},{"title":"DevOps的八荣八耻","slug":"随笔/DevOps的八荣八耻","date":"2017-08-19T01:41:22.000Z","updated":"2018-04-23T12:52:26.482Z","comments":true,"path":"2017/08/19/随笔/DevOps的八荣八耻/","link":"","permalink":"https://www.zhangqifei.top/2017/08/19/随笔/DevOps的八荣八耻/","excerpt":"","text":"以可配置为荣 ，以硬编码为耻以可互备为荣 ，以单点为耻以可无状态为荣 ，以有状态为耻以可随便重启为荣 ，以不能迁移为耻以整体交付为荣，以部分交付为耻以标准化为荣，以特殊化为耻以自动化运维为荣，以人肉化运维为耻以无人值守为荣，以人工值班为耻","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.zhangqifei.top/categories/随笔/"}],"tags":[]},{"title":"ansible puppet saltstack三款自动化运维工具的对比！","slug":"linux/ansible puppet saltstack三款自动化运维工具的对比","date":"2017-08-10T06:41:22.000Z","updated":"2018-04-22T09:29:33.219Z","comments":true,"path":"2017/08/10/linux/ansible puppet saltstack三款自动化运维工具的对比/","link":"","permalink":"https://www.zhangqifei.top/2017/08/10/linux/ansible puppet saltstack三款自动化运维工具的对比/","excerpt":"","text":"一、基础介绍 ansible基础介绍可参考 puppet基础介绍可参考 saltstack基础介绍可参考 二、技术特性比较 名称 Puppet SaltStack Ansible 开发语言 Ruby Python Python 客户端 有 有 无 二次开发 不支持 支持 支持 通信验证 是 是 是 同学加密 标准SSL协议 AES加密 OpenSSH 平台支持 AIX,BSD,HP-UX,Linux,Mac OS X,Solaris,Windows BSD,Linux,Mac OS X,Solaris,Windows AIX,BSD,HP-UX,Linux,Mac OS X,Solaris 配置文件格式 Ruby语法格式 YAML YAML Web UI 提供 提供 提供（商业版本） 命令执行 不支持（配置模块可实现） 支持 支持 三、优缺点对比 名称 优势 劣势 成本 Puppet 模块由Ruby或Ruby子集编写push命令可以即可触发变更Web界面生成处理报表、资源清单、实时节点管理代理运行端进行详细、深入的报告和对节点进行配置 相对其他工具较复杂，需学习Puppet的DSL或Ruby安装过程缺少错误校验和产生错误报表 开源软件免费SaltStack企业版每年内个节点花费约￥100 Saltstack 状态文件可用简单YAML配置模块或复杂的Python/PyDSL脚本与客户端可以基于SSH或在被管节点安装代理Web界面可看到运行的工作、minion状态、事件日志、可在客户端执行命令扩展能力极强 Web界面像毒药竞争产品不稳定与相对不完善缺乏生成深度报告的能力 开源软件免费SaltStack企业版每年内个节点花费约￥150，随着数量增加相应的会有折扣 Ansible 模块可以用任何语言开发备管节点不需要安装代理软件有Web管理界面、可配置用户、组、资源清单和执行Playbook安装、运行极其简单 对备管理节点为Windows有待加强Web管理界面是内置的Ansible的一部分需导入资源清单执行效率较低 开源版本免费Ansible Tower小于10台被管理节点免费超过10太后没年每台需支付￥100~$250的支持服务费用 四、推荐场景4.1 Puppet Puppet也许是四款工具中最深入人心的。就可用操作、模块和用户界面而言，它是最全面的。Puppet呈现了数据中心协调的全貌，几乎涵盖每一个运行系统，为各大操作系统提供了深入的工具。初始设置比较简单，只需要在需要加以管理的每个系统上安装主服务器和客户端代理软件。 命令行接口(CLI)简单直观，允许通过puppet命令下载和安装模块。然后，需要对配置文件进行更改，好让模块适合所需的任务;应接到指令的客户端与主服务器联系时，会更改配置文件，或者客户端通过立即触发更改配置文件的推送(push)来进行更改。 还有一些模块可以提供和配置云服务器实例和虚拟服务器实例。所有模块和配置都使用基于Ruby的Puppet专属语言或者Ruby本身构建而成，因而除了系统管理技能外，还需要编程专业知识。 Puppet企业版拥有最全面的Web用户界面，允许使用主服务器上的预制模块和菜谱(cookbook)，实时控制被管理的节点。Web用户界面很适合用于管理，但是不允许对模块进行诸多配置。报告工具非常完善，提供了详细信息，以便了解代理软件运行如何、已做出什么样的变更。 4.2 Ansible Ansible极其类似Salt，而不太类似Puppet或Chef。Ansible关注的重点是力求精简和快速，而且不需要在节点上安装代理软件。因此，Ansible通过SSH执行所有功能。Ansible基于Python;相比之下，Puppet和Chef基于Ruby。 Ansible可以通过Git软件库克隆，安装到Ansible主服务器上。安装完毕后，需要管理的节点被添加到Ansible配置环境，SSH授权密钥被附加到每个节点上，这与运行Ansible的用户有关。一旦完成了这步，Ansible主服务器可以通过SSH与节点进行通信，执行所有必要的任务。为了与默认情况下不允许根SSH访问的操作系统或发行版协同运行，Ansible接受sudo登录信息，以便在那些系统上以根用户的身份运行命令。 Ansible可以使用Paramiko(基于SSH2协议的Python实现)或标准SSH用于通信，不过还有一种加速模式，允许更快速、更大规模的通信。 针对确保服务在运行，或者触发更新和重新启动之类的简单任务，Ansible可以从命令行来运行，不需要使用配置文件。至于比较复杂的任务，Ansible配置通过名为Playbook的配置文件中的YAML语法来加以处理。Playbook还可以使用模板来扩展其功能。 Ansible有一大批模块，可用于管理各种系统以及亚马逊弹性计算云(EC2)和OpenStack等云计算基础设施。可以用几乎任何一种语言来编写自定义Ansible模块，只要模块输出是有效的JSON。 Ansible的Web用户界面以AnsibleWorks AWX的形式出现，但AWX与CLI并不直接联系在一起。这意味着，除非进行了同步过程，否则CLI里面的配置元素不会出现在Web用户界面中。你可以使用那个内置的同步工具，让两者保持一致，但需要按照预定计划运行同步工具。 4.3 SaltStack Salt类似Ansible，因为它也是基于CLI的工具，采用了推送方法实现客户端通信。它可以通过Git或通过程序包管理系统安装到主服务器和客户端上。客户端会向主服务器提出请求，请求在主服务器上得到接受后，就可以控制该客户端了。 Salt可以通过普通的SSH与客户端进行通信，但如果使用名为minion的客户端代理软件，可以大大增强可扩展性。此外，Salt含有一个异步文件服务器，可以为客户端加快文件服务速度，这完全是Salt注重高扩展性的一个体现。 与Ansible一样，你可以直接通过CLI，向客户端发出命令，比如启动服务或安装程序包;你也可以使用名为state的YAML配置文件，处理比较复杂的任务。还有“pillar”，这些是放在集中地方的数据集，YAML配置文件可以在运行期间访问它们。 你可以直接通过CLI，向客户端请求配置信息，比如内核版本或网络接口方面的详细信息。只要使用名为“grain”的库存元素，就可以描述客户端;这样一来，管理员可以轻松向某一种类型的服务器发出命令，不需要依赖已配置群组。比如说，只要使用一个CLI命令，你就可以向运行某个内核版本的每个客户端发送命令。 与Puppet、Chef和Ansible一样，Salt也提供了大量的模块，以处理特定的软件、操作系统和云服务。自定义模块可以用Python或PyDSL来编写。除了Unix管理外，Salt的确提供Windows管理功能，但它还是更擅长管理Unix和Linux系统。 Salt的Web用户界面Halite非常新，功能不如其他系统的Web用户界面来得全面。它提供了事件日志和客户端状态的视图，能够在客户端上运行命令，但除此之外乏善可陈。 Salt的较大优点在于可扩展性和弹性。你可以有多个级别的主服务器。上游主服务器可以控制下游主服务器及其客户端。另一个优点在于对等系统，让客户端可以向主服务器提出问题，然后主服务器从其他服务器得到答案，提供全面信息。如果需要在实时数据库中查询数据，以便完成客户端的配置，这个优点就很方便。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"},{"name":"运维自动化工具","slug":"linux/运维自动化工具","permalink":"https://www.zhangqifei.top/categories/linux/运维自动化工具/"}],"tags":[]},{"title":"运维自动化工具ansible","slug":"linux/运维自动化工具ansible","date":"2017-08-09T12:42:22.000Z","updated":"2018-04-22T09:29:32.834Z","comments":true,"path":"2017/08/09/linux/运维自动化工具ansible/","link":"","permalink":"https://www.zhangqifei.top/2017/08/09/linux/运维自动化工具ansible/","excerpt":"","text":"基本概念ansible是一个基于python开发的轻量级自动化运维管理工具，可以用来批量执行命令，安装程序，支持playbook编排。它通过ssh协议来连接主机，去中心化，相对比puppet和saltstack无需安装客户即可实现文件传输、命令执行、应用部署、配置管理、任务编排等，显得更为简单与轻量。ansible只是提供一种框架，其基于模块工作的，本身没有批量部署。 企业级自动化运维工具应用实战ansible公司计划在年底做一次大型市场促销活动，全面冲刺下交易额，为明年的上市做准备。公司要求各业务组对年底大促做准备，运维部要求所有业务容量进行三倍的扩容，并搭建出多套环境可以共开发和测试人员做测试，运维老大为了在年底有所表现，要求运维部门同学尽快实现，当你接到这个任务时，有没有更快的解决方案？ Ansible发展史Ansible 创始人，Michael DeHaan（Cobbler 与Func 的作者） 2012-03-09，发布0.0.1版，红帽收购 2015-10-17，Red Hat宣布收购（据说是1.5 亿美元） 同类自动化工具GitHub关注程度（2016-07-10） 同类的自动化运维工具 Watch（关注） Star（点赞） Fork（复制） Contributors(贡献者) Ansible 1387 17716 5356 1428 Saltstack 530 6678 3002 1520 Puppet 463 4044 1678 425 Chef 383 4333 1806 464 Fabric 379 7334 1235 116 特性 模块化：调用特定的模块，完成特定任务 有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块 支持自定义模块 基于Python语言实现 部署简单，基于python和SSH(默认已安装)，agentless 安全，基于OpenSSH 支持playbook编排任务 幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况 无需代理不依赖PKI（无需ssl） 可使用任何编程语言写模块 YAML格式，编排任务，支持丰富的数据结构 较强大的多层解决方案 ansible架构 Ansible工作原理 ANSIBLE PLAYBOOKS：任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YML文件 INVENTORY：Ansible管理主机的清单/etc/anaible/hosts MODULES：Ansible执行命令的功能模块，多数为内置的核心模块，也可自定义 PLUGINS：模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用 API：供第三方程序调用的应用程序编程接口 ANSIBLE：组合INVENTORY、API、MODULES、PLUGINS的绿框，可以理解为是ansible命令工具，其为核心执行工具 Ansible命令执行来源： USER，普通用户，即SYSTEM ADMINISTRATOR CMDB（配置管理数据库）API 调用 PUBLIC/PRIVATE CLOUD API调用 USER-&gt; Ansible Playbook -&gt; Ansibile 利用ansible实现管理的方式： Ad-Hoc 即ansible命令，主要用于临时命令使用场景 Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前提的规划 Ansible-playbook（剧本）执行过程： 将已有编排好的任务集写入Ansible-Playbook 通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行 Ansible主要操作对象： HOSTS主机 NETWORKING网络设备 注意事项 执行ansible的主机一般称为主控端，中控，master或堡垒机主控端Py: thon版本需要2.6或以上 被控端Python版本小于2.4需要安装python-simplejson 被控端如开启SELinux需要安装libselinux-python windows不能做为主控端 ansible安装(四种方式) rpm包安装: EPEL源yum install ansible 编译安装: 12345678yum -y install python-jinja2 PyYAML python-paramiko python-babel python-cryptotar xf ansible-1.5.4.tar.gzcd ansible-1.5.4python setup.py buildpython setup.py installmkdir /etc/ansiblecp -r examples/* /etc/ansible Git方式安装 123git clone git://github.com/ansible/ansible.git --recursivecd ./ansiblesource ./hacking/env-setup pip安装：pip是安装Python包的管理器，类似yum 1234yum install python-pip python-develyum install gcc glibc-devel zibl-devel rpm-bulid openssl-develpip install --upgrade pippip install ansible--upgrade 确认安装：ansible --version 相关文件配置文件/etc/ansible/ansible.cfg 主配置文件，配置ansible工作特性/etc/ansible/hosts 主机清单/etc/ansible/roles/ 存放角色的目录 程序/usr/bin/ansible 主程序，临时命令执行工具/usr/bin/ansible-doc 查看配置文档，模块功能查看工具/usr/bin/ansible-galaxy 下载/上传优秀代码或Roles模块的官网平台/usr/bin/ansible-playbook 定制自动化任务，编排剧本工具/usr/bin/ansible-pull 远程执行命令的工具/usr/bin/ansible-vault 文件加密工具/usr/bin/ansible-console 基于Console界面与用户交互的执行工具 主机清单inventory ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名 默认的inventory file为/etc/ansible/hosts inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成 /etc/ansible/hosts文件格式inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明123456789101112131415161718例：[root@centos7 ~]#vim /etc/ansible/hosts[web]192.168.109.100192.168.109.2[db]192.168.109.3192.168.109.100 //这里默认有个all[root@centos7 ~]#ansible db -m ping 192.168.109.100 | SUCCESS =&gt; &#123; &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;&#125;192.168.109.3 | SUCCESS =&gt; &#123; &quot;changed&quot;: false, &quot;ping&quot;: &quot;pong&quot;&#125; 如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机示例：12345[websrvs]www[01:100].example.com[dbsrvs]db-[a:f].example.com ansible 配置文件12345678910111213Ansible 配置文件/etc/ansible/ansible.cfg （一般保持默认）[defaults]#inventory = /etc/ansible/hosts # 主机列表配置文件#library = /usr/share/my_modules/ # 库文件存放目录#remote_tmp = $HOME/.ansible/tmp #临时py命令文件存放在远程主机目录#local_tmp = $HOME/.ansible/tmp # 本机的临时命令执行目录#forks = 5 # 默认并发数#sudo_user = root # 默认sudo 用户#ask_sudo_pass = True #每次执行ansible命令是否询问ssh密码#ask_pass = True #remote_port = 22#host_key_checking = False #检查对应服务器的host_key，建议取消注释第一次连接不用输入yes#log_path = /var/log/ansible.log 生成日志文件 ansible系列命令123456789101112Ansible系列命令ansible ansible-doc ansible-playbook ansible-vault ansible-console ansible-galaxy ansible-pull ansible-doc:显示模块帮助ansible-doc [options] [module...]-a 显示所有模块的文档-l, --list 列出可用模块-s, --snippet 显示指定模块的playbook片段示例：ansible-doc –l 列出所有模块ansible-doc ping 查看指定模块帮助用法ansible-doc –s ping 查看指定模块帮助用法 123456789101112131415161718192021222324252627282930313233343536ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点ansible &lt;host-pattern&gt; [-m module_name] [-a args] --version 显示版本-m module 指定模块，默认为command-v 详细过程–vv-vvv更详细--list-hosts 显示主机列表，可简写—list-k, --ask-pass 提示连接密码，默认Key验证-K, --ask-become-pass 提示输入sudo-C, --check 检查，并不执行-T, --timeout=TIMEOUT 执行命令的超时时间，默认10s-u, --user=REMOTE_USER 执行远程执行的用户-b, --become 代替旧版的sudo切换ansible的Host-pattern 匹配主机的列表 All ：表示所有Inventory中的所有主机 ansible all –m ping * :通配符 ansible &quot;*&quot; -m ping ansible 192.168.1.* -m ping ansible &quot;*srvs&quot; -m ping 或关系 ansible &quot;websrvs:appsrvs&quot; -m ping ansible &quot;192.168.1.10:192.168.1.20&quot; -m ping 逻辑与 ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping 在websrvs组并且在dbsrvs组中的主机 逻辑非 ansible &apos;websrvs:!dbsrvs&apos; –m ping 在websrvs组，但不在dbsrvs组中的主机 综合逻辑 ansible &apos;websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs&apos; –m ping 正则表达式 ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping ansible &quot;~(web|db).*\\.magedu\\.com&quot; –m ping ansible命令执行过程ansible命令执行过程ansible all -m command -a &#39;ls /root&#39; 加载自己的配置文件默认/etc/ansible/ansible.cfg 加载自己对应的模块文件，如command 通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件 给文件+x执行 执行并返回结果 删除临时py文件，sleep 0退出 执行状态：绿色：执行成功并且不需要做改变的操作黄色：执行成功并且对目标主机做变更红色：执行失败 ansible使用示例12345678以wang用户执行ping存活检测ansible all -m ping -u wang -k以wang sudo至root执行ping存活检测ansible all -m ping -u wang –b -k以wangsudo至mage用户执行ping存活检测ansible all -m ping -u wang –b -k --become-user mage以wang sudo至root用户执行lsansible all -m command -u wang--become-user=root -a &apos;ls/root&apos; -b –k -K ansible常用模块Command：在远程主机执行命令，默认模块，可忽略-m选项123456命令：chdir： ＃运行该命令之前，切换到该目录。creates： ＃一个文件当它已经存在时，这个步骤将不运行。ansible srvs -m command -a &apos;service vsftpd start&apos; ansible srvs -m command -a &apos;echo magedu |passwd --stdin wang&apos; 不成功此命令不支持$VARNAME &lt; &gt; | ;&amp; 等，用shell模块实现 Shell：和command相似，用shell执行命令123456789ansible srv -m shell -a &apos;echo xxxxx |passwd –stdin wang&apos; 调用bash执行命令类似cat /tmp/stanley.md | awk -F&apos;|&apos; &apos;&#123;print $1,$2&#125;&apos; &amp;&gt; /tmp/example.txt这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器[root@centos7 ~]#ansible all -m shell -a &apos;echo $HOSTNAME&apos;192.168.109.100 | SUCCESS | rc=0 &gt;&gt;centos7.magedu.com192.168.109.2 | SUCCESS | rc=0 &gt;&gt;centos7192.168.109.3 | SUCCESS | rc=0 &gt;&gt;centos6.9 Script：运行脚本12345f1.shhostnamedate .... 定义了一些脚本等snsible websrvs -m script -a &apos;f1.sh&apos; Copy:从服务器复制文件到客户端,1234ansible srv -m copy -a &quot;src=/root/f1.sh dest=/tmp/f2.sh owner=wang mode=600 backup=yes&quot; 如目标存在，默认覆盖，此处指定先备份ansible srv -m copy -a &quot;content=&apos;test content\\n&apos; dest=/tmp/f1.txt&quot; 利用内容，直接生成目标文件 cron：计划任务1234567支持时间：minute，hour，day，month，weekdayansible srv -m cron -a &quot;minute=*/5 job=&apos;/usr/bin/ntpdate 172.16.0.1 &amp;&gt;/dev/null&apos; name=Synctime&quot; 创建任务ansible srv -a &apos;crontab -l&apos; 查看任务ansible srv -m cron -a &apos;state=absent name=Synctime&apos; 删除任务计划任务目录路径 /var/spool/cron/rootansible srv -m cron -a &apos;disabled=yes job=&quot;/usr/bin/ntpdate 172.16.0.1 &amp;&gt;/dev/null&quot; name=Synctime&apos;disables=yes 前面加上注释 no的话取消注释 fetch:从客户端取文件至服务器端，copy相反，目录可先tar1ansible srv -m fetch -a &apos;src=/root/a.sh dest=/data/scripts&apos; file：设置文件属性123ansible srv -m file -a &quot;path=/root/a.sh state=touch owner=wang mode=755&quot; //创建空文件 并设置权限等ansible web -m file -a &apos;src=/app/testfile dest=/app/testfile-link state=link&apos; //创建软连接 hostname：管理主机名1ansible web -m hostname -a &quot;name=websrv&quot; yum：管理包12345ansible srv -m yum -a &apos;name=httpd state=latest&apos; 安装ansible srv -m yum -a &apos;name=httpd,tftp state=latest&apos; 安装多个ansible srv -m yum -a &apos;name=httpd state=latest update_cache=yes&apos; update_cache=yes 相当于yum clean allansible srv -m yum -a &apos;name=httpd state=absent&apos; 删除 service：管理服务1234ansible srv -m service -a &apos;name=httpd state=stopped enabled=yes&apos;关闭并且设置开机启动 不支持多个命令ansible srv -m service -a &apos;name=httpd state=started&apos;启动ansible srv –m service –a &apos;name=httpd state=reloaded&apos;ansible srv -m service -a &apos;name=httpd state=restarted&apos;重启 user：管理用户123ansible srv -m user -a &apos;name=user1 comment=&quot;test user&quot; uid=2048 home=/app/user1 group=root&apos;创建普通用户ansible srv -m user -a &apos;name=sysuser1 system=yes home=/app/sysuser1 &apos;创建系统用户ansible srv -m user -a &apos;name=user1 state=absent remove=yes&apos; 删除用户及家目录等数据 Group：管理组12ansible srv -m group -a &quot;name=testgroup system=yes&quot;ansible srv -m group -a &quot;name=testgroup state=absent&quot; ansible系列命令ansible-galaxy123456789连接https://galaxy.ansible.com 下载相应的roles中文 http://www.ansible.com.cn/index.html列出所有已安装的galaxy ansible-galaxy list安装galaxy ansible-galaxy install geerlingguy.redis删除galaxy ansible-galaxy remove geerlingguy.redis ansible-pull12ansible-pull推送命令至远程，效率无限提升，对运维要求较高 Ansible-playbook123456789ansible-playbook hello.yml例子：vim hello.yml- hosts: test remote_user: root tasks: - name: hello world command: wall &quot;hello world&quot; Ansible-vault12345678功能：管理加密解密yml文件 ansible-vault [create|decrypt|edit|encrypt|rekey|view] ansible-vault encrypt hello.yml 加密 ansible-vault decrypt hello.yml 解密 ansible-vault view hello.yml 查看 ansible-vault edit hello.yml 编辑加密文件 ansible-vault rekey hello.yml 修改口令 ansible-vault create new.yml 创建新文件 Ansible-console12345678910111213Ansible-console：2.0+新增，可交互执行命令，支持tab root@test(2)[f:10] $ 执行用户@当前操作的主机组(当前组的主机数量)[f:并发数]$ 设置并发数：forks n 例如：forks 10 切换组：cd 主机组例如：cd web 列出当前组主机列表：list 列出所有的内置命令：?或help示例：root@all (2)[f:5]$ listroot@all (2)[f:5]$ cd appsrvsroot@appsrvs (2)[f:5]$ list root@appsrvs(2)[f:5]$ yum name=httpd state=presentroot@appsrvs(2)[f:5]$ service name=httpd state=started playbook playbook是由一个或多个“play”组成的列表 play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中，即可以让它们联同起来按事先编排的机制同唱一台大戏 Playbook采用YAML语言编写 YAML介绍 YAML是一个可读性高的用来表达资料序列的格式。YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。Clark Evans在2001年在首次发表了这种语言，另外IngydötNet与Oren Ben-Kiki也是这语言的共同设计者 YAML Ain’tMarkup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言） 特性 YAML的可读性好 YAML和脚本语言的交互性好 YAML使用实现语言的数据类型 YAML有一个一致的信息模型 YAML易于实现 YAML可以基于流来处理 YAML表达能力强，扩展性好 更多的内容及规范参见http://www.yaml.org YAML语法简介 在单一档案中，可用连续三个连字号(——)区分多个档案。另外，还有选择性的连续三个点号( … )用来表示档案结尾 次行开始正常写Playbook的内容，一般建议写明该Playbook的功能 使用#号注释代码 缩进必须是统一的，不能空格和tab混用 缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的 YAML文件内容和Linux系统大小写判断方式保持一致，是区别大小写的，k/v的值均需大小写敏感 k/v的值可同行写也可换行写。同行使用:分隔 v可是个字符串，也可是另一个列表一个完整的代码块功能需最少元素需包括name: task 一个name只能包括一个task YAML文件扩展名通常为yml或yaml YAML语法简介123456789101112Dictionary：字典，通常由多个key与value构成示例：---# An employee recordname: Example Developerjob: Developerskill: Elite也可以将key:value放置于&#123;&#125;中进行表示，用,分隔多个key:value示例：---# An employee record&#123;name: Example Developer, job: Developer, skill: Elite&#125; YAML语法YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用”-“来代表，Map里的键值对用”:”分隔示例1234567891011121314name: John Smithage: 41gender: Malespouse: name: Jane Smith age: 37 gender: Femalechildren: - name: Jimmy Smith age: 17 gender: Male - name: Jenny Smith age 13 gender: Female Playbook核心元素 Hosts 执行的远程主机列表 Tasks 任务集 Varniables 内置变量或自定义变量在playbook中调用 Templates 模板，可替换模板文件中的变量并实现一些简单逻辑的文件 Handlers 和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行 tags 标签指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断ansible-playbook –t tagsname useradd.yml示例:安装httpd 并且开机启动1234567891011vim test1.yml- hosts: web remote_user: root tasks: - name: install package yum: name=httpd start=present - name: start service service: name=httpd state=started enabled=yes ansible-playbook test1.yml 执行 playbook基础组件 Hosts： 1234567891011playbook中的每一个play的目的都是为了让某个或某些主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，须事先定义在主机清单中可以是如下形式：one.example.comone.example.com:two.example.com192.168.1.50192.168.1.*Websrvs:dbsrvs两个组的并集Websrvs:&amp;dbsrvs两个组的交集webservers:!phoenix 在websrvs组，但不在dbsrvs组示例:-hosts: websrvs：dbsrvs remote_user: 12345678910可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户- hosts: websrvs remote_user: root tasks: -name: test connection ping: remote_user: magedu sudo: yes 默认sudo为root sudo_user:wang sudo为wang task列表和action 12345play的主体部分是task list。task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。在运行自下而下某playbook时，如果中途发生错误，所有已执行任务都将回滚，因此，在更正playbook后重新执行一次即可task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出 tasks：任务列表12345678910格式： (1) action: module arguments (2) module: arguments 建议使用 注意：shell和command模块后面跟命令，而非key=value某任务的状态在运行后为changed时，可通过“notify&quot;通知给相应的handlers任务可以通过&quot;tags&quot;打标签，而后可在ansible-playbook命令上使用-t指定进行调用示例：tasks: - name: disable selinux command: /sbin/setenforce 0 12345678910111213141516171819202122如果命令或脚本的退出码不为零，可以使用如下方式替代tasks: - name: run this command and ignore the result shell: /usr/bin/somecommand|| /bin/true或者使用ignore_errors来忽略错误信息：tasks: - name: run this command and ignore the result shell: /usr/bin/somecommand ignore_errors: True 运行playbook的方式 ansible-playbook &lt;filename.yml&gt; ... [options]常见选项 --check 只检测可能会发生的改变，但不真正执行操作 --list-hosts 列出运行任务的主机 --limit 主机列表只针对主机列表中的主机执行 -v 显示过程-vv-vvv更详细示例 ansible-playbook file.yml --check 只检测 ansible-playbook file.yml ansible-playbook file.yml --limit websrvs Playbook VS ShellScripts12345678910111213141516171819202122SHELL脚本#!/bin/bash# 安装Apacheyum install --quiet -y httpd# 复制配置文件cp /path/to/config/httpd.conf /etc/httpd/conf/httpd.confcp /path/to/httpd-vhosts.conf /etc/httpd/conf/httpd-vhosts.conf# 启动Apache，并设置开机启动service httpd start chkconfig httpd onPlaybook定义--- - hosts: all tasks: - name: &quot;安装Apache&quot; command: yum install -q -y httpd - name: &quot;复制配置文件&quot; command: cp /tmp/httpd.conf/ etc/httpd/conf/httpd.conf command: cp /tmp/httpd-vhosts.conf/ etc/httpd/conf/httpd-vhosts.conf - name: &quot;启动Apache，并设置开机启动&quot; service: name=httpd state=started enabled=yes 示例system.yml：12345678910--- - hosts: allre mote_user: root tasks: - name: create mysql user user: name=mysql system=yes uid=36 - name: create a group group: name=httpd system=yes Playbook示例123456789101112示例：httpd.yml- hosts: websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ - name: start service service: name=httpd state=started enabled=yes handlers和notify结合使用触发条件 Handlers 是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作 notify这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作 Playbook中handlers使用123456789101112131415- hosts:websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ notify: restart httpd - name: ensure apache is running service: name=httpd state=started enabled=yes handlers: - name: restart httpd service: name=httpd status=restarted 示例：12345678910111213141516171819202122- hosts: websrvs remote_user: root tasks: - name: add group nginx tags: user user: name=nginx state=present - name: add user nginx user: name=nginx state=present group=nginx - name: Install Nginx yum: name=nginx state=present - name: config copy: src=/root/config.txt dest=/etc/nginx/nginx.conf notify: - Restart Nginx - Check Nginx Process handlers: - name: Restart Nginx service: name=nginx state=restarted enabled=yes - name: Check Nginx process shell: killall -0 nginx &gt; /tmp/nginx.log Playbook中tags使用示例：httpd.yml123456789101112131415- hosts: websrvs remote_user: root tasks: - name: Install httpd yum: name=httpd state=present - name: Install configure file copy: src=files/httpd.conf dest=/etc/httpd/conf/ tags: conf - name: start httpd service tags: service service: name=httpd state=started enabled=yes ansible-playbook –t conf httpd.yml -t //--tags 综合实例：安装httpd 并且启动端口是8080123456789101112131415161718192021222324252627282930313233343536373839404142本机先安装httpd 把httpd配置文件 /etc/httpd/conf/httpd.conf 里面端口改为8080[root@centos7 app]#cat httpd.yml ---- hosts: web remote_user: root tasks: - name: install httpd yum: name=httpd - name: copy config file copy: src=/app/httpd.conf dest=/etc/httpd/conf/ - name: start httpd service: name=httpd state=started enabled=yes [root@centos7 app]#ansible-playbook httpd.yml现在把端口改为80[root@centos7 app]#cat httpd.yml ---- hosts: web remote_user: root tasks: - name: install httpd yum: name=httpd - name: copy config file copy: src=/app/httpd.conf dest=/etc/httpd/conf/ notify: restart httpd - name: start httpd service: name=httpd state=started enabled=yes handlers: - name: restart httpd service: name=httpd state=restarted[root@centos7 app]#ansible-playbook --limit 192.18.109.1 httpd.yml 只针对这一台机器[root@centos7 app]#ansible web -m shell -a &apos;ss -ntl|grep 80&apos;192.168.109.100 | SUCCESS | rc=0 &gt;&gt;LISTEN 0 128 :::80 :::* 192.168.109.2 | SUCCESS | rc=0 &gt;&gt;LISTEN 0 128 :::80 :::*","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"},{"name":"运维自动化工具","slug":"linux/运维自动化工具","permalink":"https://www.zhangqifei.top/categories/linux/运维自动化工具/"}],"tags":[{"name":"ansible","slug":"ansible","permalink":"https://www.zhangqifei.top/tags/ansible/"}]},{"title":"运维自动化工具puppet","slug":"linux/运维自动化工具puppet","date":"2017-08-07T11:42:22.000Z","updated":"2018-04-22T09:29:33.000Z","comments":true,"path":"2017/08/07/linux/运维自动化工具puppet/","link":"","permalink":"https://www.zhangqifei.top/2017/08/07/linux/运维自动化工具puppet/","excerpt":"","text":"puppet的概念Puppet是一款使用GPLV2X协议授权的开源管理配置工具，用Ruby语言开发。其既可以通过客户端–服务器的方式运行，也可以独立运行。Puppet可以为系统管理员提供方便、快捷的系统自动化管理。对于系统管理员来说通过Puppet配置管理系统，底层的操作系统的发行版本是透明的，Puppet通过（Provider又称提供者）属性来完成软件的配置与安装，管理员不必关心操作系统的种类与发行版本，Puppet还可以提供一个强大的框架来完成系统管理功能，在框架的基础上系统管理员可以通过Puppet语言来描述系统的一些事务，如安装软件、初始化系统、启动、删除服务、推送配置文件和差异化配置管理服务器等。同时系统管理员和系统管理员之间可以分享用Puppet语言描述好的事务，从而减少重复劳动，提高工作效率。 puppet工作模型 a.部署调度 puppet master在一台服务器以守护进程方式运行，同时也包含客户端各节点的配置信息，puppet agent 在与master的通信过程中，通过标准的SSL协议进行加密和验证，验证通过后，agent从masteer上读取响应节点信息应用在本地。 b.配置语言和资源抽象 puppet使用描述性语言来定义配置项，在puppet中将配置项被称为resource，当Agent连接Master时，Master并不知道Agent的操作系统型号和版本。Agent通过Facter工具收集系统相关信息，并通过SSL协议将Agent的信息传递给Master。Master根据Agent收集到的相关信息，通过资源的提供者来为Agent服务。比如Package资源收到Agent的信息后，会识别Agent的系统型号版本，并通过资源提供者（如yum aptitude pkgadd apt-get等）匹配，为Agent服务。 c.事物层Puppet事务层其实就是它的解析引擎。Puppet事务层配置每一台主机的过程包括： 解析和配置编译。 将编译好的配置同步到Agent。 在Agent上应用配置。 向Master报告运行结果。 首先Puppet会创建一个图表来表示所有资源的关系和上下游执行顺序，以及和Agent的关系。然后Puppet将按照资源之间的关系和上下游顺序依次执行。接着Puppet为每一个Agent获取相应的资源，并把它们编译成“目录”，然后将目录依次分发到各主机，并通过Agent来应用它们，最后应用结果以报告形式反馈给Master。自动化运维工具puppet安装配置 puppet的细节和原理Puppet采用了非常简单的C/S架构，所有数据的交互都通过SSL进行，以保证安全。 客户端Puppetd向Master发起认证请求，或使用带签名的证书。 Master告诉Client你是合法的。 客户端Puppetd调用Facter，Facter探测出主机的一些变量，例如主机名、内存大小、IP地址等。Puppetd将这些信息通过SSL连接发送到服务器端。 服务器端的Puppet Master检测客户端的主机名，然后找到manifest对应的node配置，并对该部分内容进行解析。Facter送过来的信息可以作为变量处 理，node牵涉到的代码才解析，其他没牵涉的代码不解析。解析分为几个阶段，首先是语法检查，如果语法错误就报错；如果语法没错，就继续解析，解析的结 果生成一个中间的“伪代码”（catelog），然后把伪代码发给客户端。 客户端接收到“伪代码”，并且执行。 客户端在执行时判断有没有File文件，如果有，则向fileserver发起请求。 客户端判断有没有配置Report，如果已配置，则把执行结果发送给服务器。 服务器端把客户端的执行结果写入日志，并发送给报告系统。 准备工作123456789101112131415161718192021222324两台机器：192.168.1.100（服务端）192.168.1.101 （客户端）两台机器关闭selinux，清空iptables规则，并保存，设置hostname100上hostname master.aming.com编辑/etc/sysconfig/network 定义hostname101上hostname client.aming.com编辑/etc/sysconfig/network 定义hostname重启服务器编辑hosts文件100和101全部为192.168.1.100 master.aming.com192.168.1.101 client.aming.com安装ntpdate，并建立自动同步时间的任务计划：yum install -y ntpcront -e //加入*/10 * * * * ntpdate time.windows.com 服务端安装12345678910安装puppet 源rpm -ivh http://yum.puppetlabs.com/el/6/p ... ease-6-7.noarch.rpm安装服务端程序yum install -y puppet-server启动服务service puppetmaster start开机启动chkconfig puppetmaster on 客户端安装123456789101112131415161718安装puppet 源rpm -ivh http://yum.puppetlabs.com/el/6/p ... ease-6-7.noarch.rpm安装客户端程序yum install -y puppet修改配置文件vi /etc/puppet/puppet.conf在最后面添加：listen = trueserver = master.aming.comruninterval = 30 //主动更新，每隔30s然后启动puppet服务/etc/init.d/puppet start手动生成ssl证书puppet agent --test --server master.aming.com 服务端查看，签发客户端的证书12345puppet cert list --all会看到client.aming.com 的key，正常应该会在行首有一个+，如果没有说明还没有签发签发客户端puppet cert --sign client.aming.com 测试12345678910111213服务端上vi /etc/puppet/manifests/site.pp加入如下内容：node default &#123;file &#123;&quot;/tmp/123.txt&quot;: content =&gt; &quot;test,test&quot;;&#125;&#125;客户端上puppet agent --test --server master.aming.com这样会在客户端上生成一个 /tmp/123.txt的文件，并且内容为 testtest 配置自动签发证书123456789101112131415161718192021222324252627服务端上删除客户端证书puppet cert clean client.aming.com客户端上删除ssl下的文件rm -rf /var/lib/puppet/ssl/*服务端更改配置文件vim /etc/puppet/puppet.conf在[main]下面加一行autosign = true服务端创建自动签发的配置文件vim /etc/puppet/autosign.conf加入如下内容：*.aming.com 重启puppetmaster服务/etc/init.d/puppetmaster restart客户端重启puppet服务/etc/init.d/puppet restart这样就能在服务端上自动签发证书了。当然不重启服务，手动连一下服务端也可以客户端执行：puppet agent --test --server master.aming.com扩展： puppet更新方式 http://www.cnphp6.com/archives/66975 模块管理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869首先要理解几个概念，模块、类、资源。 模块是puppet的最大单元，模块里面有类，类下面有资源。 puppet管理的文件、用户、服务、任务计划等全部由这些单元组成。下面我们来定义一个模块：在服务端上做如下操作：mkdir /etc/puppet/modules/testm //模块名字就是testmcd !$mkdir &#123;files,manifests,templates&#125; //一个模块下需要有这三个目录，files存一些文件（可以为空），manifests存配置文件，templates存模板（可以留空）touch manifests/init.pp //这个是必须的vi manifests/init.pp //内容如下class testm&#123;file &#123;&quot;/tmp/2.txt&quot;:owner =&gt; &quot;root&quot;,group =&gt; &quot;root&quot;,mode =&gt; 0400,source =&gt; &quot;puppet://$puppetserver/modules/testm/1.txt&quot;&#125;&#125;说明：类名字也叫做testm, 类下面定义了一个资源file，文件名字叫做/tmp/2.txt ，owner，group，mode定义文件的属主、数组以及权限，source定义这个文件从哪里获取。 $puppetserver一会也要定义一下，这里指的是puppet server服务器上/etc/puppet/modules/testm/files/1.txt下面要继续定义一个很关键的配置文件：vim /etc/puppet/manifests/site.pp //内容如下$puppetserver = &apos;master.aming.com&apos;node &apos;client.aming.com&apos;&#123; include testm&#125;说明：$puppetserver 定义服务端的主机名，node后面为客户端的主机名，这里面定义该客户端要加载的模块配置完成后，在客户端执行命令：puppet agent --test --server=master.aming.com //如果客户端上启动了puppet服务，不用执行这命令，它也会自动同步的上面的模块其实只是同步了一个文件而已，那么要想同步一个目录如何做？我们可以通过实现同步一个目录来做一个包发布系统。比如在一台机器上编译安装好了apache，那么就可以通过这样的模块把这个apache目录整个分发到其他机器上。模块配置文件如下：class apache&#123;file &#123;&quot;/usr/local/apache2&quot;:owner =&gt; &quot;root&quot;,group =&gt; &quot;root&quot;,source =&gt; &quot;puppet://$puppetserver/modules/apache/apache2&quot;,recurse =&gt; true,purge =&gt; true&#125;&#125;其中recurse=&gt;true 这个参数很关键，它表示递归的意思，没有这个不能同步目录。purge参数可以保证当服务端删除某个文件，客户端可以跟着删除。远程执行命令：exec &#123;&quot;123&quot;:unless =&gt; &quot;test -f /tmp/aminglinux.txt&quot;,path =&gt; [&quot;/bin&quot;, &quot;/sbin&quot;, &quot;/usr/bin&quot;, &quot;/usr/sbin&quot;],command =&gt; &quot;/bin/touch /tmp/aminglinux.txt&quot;&#125;说明：unless后面的命令作为一个条件，当条件成立时，不会执行下面的命令，如果想要条件成立时，执行下面的命令，用 onlyif。要注意的是，我们一定要给执行的这条命令加个条件，使用unless就可以，必须满足这个条件才能执行命令，否则这个命令会一直执行，不太妥当。cron资源：cron &#123;&quot;aming1&quot;:command =&gt; &quot;/sbin/ntpdate time.windows.com&quot;,user =&gt; &quot;root&quot;,minute =&gt; &quot;*/10&quot;,# ensure =&gt; &quot;absent&quot; //当增加了这行配置，则会把该cron删除掉&#125;说明：分时日月周分别对应puppet里面的minute，hour，monthday，month，weekday 扩展学习 http://blog.chinaunix.net/uid-20639775-id-3314583.html 资源： package http://puppet.wikidot.com/package service http://puppet.wikidot.com/srv exec http://puppet.wikidot.com/exec cron http://puppet.wikidot.com/cron","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"},{"name":"运维自动化工具","slug":"linux/运维自动化工具","permalink":"https://www.zhangqifei.top/categories/linux/运维自动化工具/"}],"tags":[{"name":"puppet","slug":"puppet","permalink":"https://www.zhangqifei.top/tags/puppet/"}]},{"title":"运维自动化工具saltstack","slug":"linux/运维自动化工具saltstack","date":"2017-08-06T10:42:22.000Z","updated":"2018-04-22T09:29:33.156Z","comments":true,"path":"2017/08/06/linux/运维自动化工具saltstack/","link":"","permalink":"https://www.zhangqifei.top/2017/08/06/linux/运维自动化工具saltstack/","excerpt":"","text":"Saltstack简介SaltStack是一个服务器基础架构集中化管理平台，具备配置管理、远程执行、监控等功能，一般可以理解为简化版的puppet和加强版的func。SaltStack基于Python语言实现，结合轻量级消息队列（ZeroMQ）与Python第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack和PyYAML等）构建。通过部署SaltStack环境，我们可以在成千上万台服务器上做到批量执行命令，根据不同业务特性进行配置集中化管理、分发文件、采集服务器数据、操作系统基础及软件包管理等，SaltStack是运维人员提高工作效率、规范业务配置与操作的利器。 特点 简单 兼顾大规模部署与更小的系统的同时提供多功能性是很困难的，Salt是非常简单配置和维护，不管项目的大小。Salt可以胜任管理任意的数量的服务器，不管是本地网络，还是跨数据中心。架构采用C/S模式，在一个后台程序中集成必要功能。默认不需要复杂的配置就可以工作，同时可以定制用于特殊的需求。 并行执行 Salt的核心功能： 通过并行方式让远端节点执行命令 采用安全的加密/解析协议 最小化使用网络和负载 提供简单的程序接口 Salt引入了更细粒度的控制，允许不通过目标名字，二是通过系统属性分类 构建在成熟技术之上 Salt采用了很多技术和技巧。网络层采用优秀的ZeroMQ库，所以守护进程里面包含AMQ代理。Salt采用公钥和主控通讯，同时使用更快的AES加密通信，验证和加密都已经集成在Salt里面。Salt使用msgpack通讯，所以更快速和更轻量网络交换。 Python 客户端接口 为了实现简单的扩展，Salt执行例程可以写成简单的Python模块。客户端程序收集的数据可以发送回主控端，可以是其他任意程序。可以通过Python API调用Salt程序，或者命令行，因此，Salt可以用来执行一次性命令，或者大型应用程序中的一部分模块。 快速，灵活，可扩展 结果是一个系统可以高速在一台或者一组服务器执行命令。Salt速度很快，配置简单，扩展性好，提供了一个远程执行架构，可以管理多样化需求的任何数量的服务器。整合了世界上最好的远程执行方法，增强处理能力，扩展使用范围，使得可以适用任何多样化复杂的网络。 开源 Salt基于Apache 2.0 licence开发，可以用于开源或者自有项目。请反馈你的扩展给项目组，以便更多人受益，共同促进Salt发展。请在你的系统部署 系统，让运维更便捷。 架构saltstack是基于C/S服务模式，在该架构中，服务器端叫做Master，客户端叫做Minion。传统的C/S模式我们这样理解，客户端发送请求给服务器端，服务器端接受到来自客户端的请求并处理完成后再返回客户端。 在saltstack架构中，不仅有传统的C/S服务模式，而且有消息队列中的发布与订阅（pub/sub）服务模式。目前我们一般用其C/S架构做批量管理。 Master：控制中心,salt命令运行和资源状态管理 Minion : 需要管理的客户端机器,会主动去连接Mater端,并从Master端得到资源状态 信息,同步资源管理信息 States：配置管理的指令集 Modules：在命令行中和配置文件中使用的指令模块,可以在命令行中运行 Grains：minion端的变量,静态的 Pillar：minion端的变量,动态的比较私密的变量,可以通过配置文件实现同步minions定义 highstate：为minion端下发永久添加状态,从sls配置文件读取.即同步状态配置 salt_schedule：会自动保持客户端配置 连接方式Master与Minion认证 minion在第一次启动时，会在/etc/salt/pki/minion/（该路径在/etc/salt/minion里面设置）下自动生成minion.pem（private key）和 minion.pub（public key），然后将 minion.pub发送给master。 master在接收到minion的public key后，通过salt-key命令accept minion public key，这样在master的/etc/salt/pki/master/minions下的将会存放以minion id命名的 public key，然后master就能对minion发送指令了。 SaltStack master启动后默认监听4505和4506两个端口。4505（publish_port）为saltstack的消息发布系统，4506（ret_port）为saltstack客户端与服务端通信的端口。如果使用lsof 查看4505端口，会发现所有的minion在4505端口持续保持在ESTABLISHED状态 安装部署1234主机名 IP地址 系统saltstack-server 172.20.4.50 CentOS release 6.9 (Final)saltstack-1 172.20.4.51 CentOS release 6.9 (Final)saltstack-2 172.20.4.52 CentOS release 6.9 (Final) 初始化环境：123456789101112131415yum install ntpdate -y &amp;&amp; ntpdate time1.aliyun.com #同步时间service iptables stop #关闭iptablessed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/&quot; /etc/selinux/config #关闭selinuxsetenforce 0 cat &gt; saltstack.repo &lt;&lt;EOF[saltstack-repo]name=SaltStack repo for RHEL/CentOS $releaseverbaseurl=https://repo.saltstack.com/yum/RedHat/$releasever/$basearch/latestenabled=1gpgcheck=1gpgkey=https://repo.saltstack.com/yum/redhat/$releasever/$basearch/latest/SALTSTACK-GPG-KEY.pubEOFrpm --import https://repo.saltstack.com/yum/redhat/6/x86_64/latest/SALTSTACK-GPG-KEY.pubyum cleanall &amp;&amp; yum makecache #更新yum源 master 端安装123456789yum -y install salt-mastermkdir /etc/salt/states 编辑/etc/salt/statesinterface: 0.0.0.0state_top: top.slsfile_roots: base: - /etc/salt/states 123启动服务，并设置开机自启/etc/init.d/salt-master startchkconfig salt-master on monitor端安装1234配置yum源和master方法一致yum -y install salt-minion修改/etc/salt/minion文件（slatstack-1/2 都更改成对应的id，master指向master的ip地址） 启动客户端，并设置开机自启动 证书管理12#执行salt-key -L 查看秘钥验证#执行Salt-key -a 加ID添加认证秘钥 验证测试 常见模块(1)、cp模块（实现远程文件、目录的复制，以及下载URL文件等操作）12345678将主服务器file_roots指定位置下的目录复制到被控主机salt &quot;*&quot; cp.get_dir salt://testdir /tmp/test将主服务器file_roots指定位置下的文件复制到被控主机salt &quot;*&quot; cp.get_file salt://testdir/testfile /tmp/testfile下载指定URL内容到被控主机指定位置salt &quot;*&quot; cp.get_url http://mirrors.163.com/.help/CentOS6-Base-163.repo /etc/yum.repos.d/CentOS6-Base-163.repo (2)、cmd模块（实现远程的命令行调用执行）1salt &quot;*&quot; cmd.run &apos;netstat -lntup&apos; (3)、cron模块（实现被控主机的crontab操作）12345678为指定的被控主机、root用户添加crontab信息salt &quot;*&quot; cron.set_job root &apos;*/5&apos; &apos;*&apos; &apos;*&apos; &apos;*&apos; &apos;*&apos; &apos;/usr/sbin/ntpdate time1.aliyun.com&apos;删除指定的被控主机、root用户的crontab信息salt &quot;*&quot; cron.rm_job root &apos;/usr/sbin/ntpdate time1.aliyun.com&apos;查看定时任务salt &apos;*&apos; cron.raw_cron root (4)、dnsutil模块（实现被控主机通用DNS操作）12为被控主机添加指定的hosts主机配置项salt &apos;*&apos; dnsutil.hosts_append /etc/hosts 127.0.0.1 test.saltstack.com (5)、file模块（被控主机文件常见操作，包括文件读写、权限、查找、校验等）12salt &apos;*&apos; file.get_sum /etc/resolv.conf md5salt &apos;*&apos; file.stats /etc/resolv.conf (6)、network模块（返回被控主机网络信息）12salt &apos;*&apos; network.ip_addrssalt &apos;*&apos; network.interfaces (7)、pkg包管理模块（被控主机程序包管理，如yum、apt-get等）12salt &apos;*&apos; pkg.install sysstatsalt &apos;*&apos; pkg.file_list sysstat (8)、service 服务模块（被控主机程序包服务管理）1234567salt &apos;*&apos; service.enable crondsalt &apos;*&apos; service.disable crondsalt &apos;*&apos; service.status crondsalt &apos;*&apos; service.stop crondsalt &apos;*&apos; service.start crondsalt &apos;*&apos; service.restart crondsalt &apos;*&apos; service.reload crond","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"},{"name":"运维自动化工具","slug":"linux/运维自动化工具","permalink":"https://www.zhangqifei.top/categories/linux/运维自动化工具/"}],"tags":[{"name":"saltstack","slug":"saltstack","permalink":"https://www.zhangqifei.top/tags/saltstack/"}]},{"title":"8分钟带你深入浅出搞懂Nginx","slug":"linux/8分钟带你深入浅出搞懂Nginx","date":"2017-06-06T01:41:22.000Z","updated":"2018-04-22T09:29:33.065Z","comments":true,"path":"2017/06/06/linux/8分钟带你深入浅出搞懂Nginx/","link":"","permalink":"https://www.zhangqifei.top/2017/06/06/linux/8分钟带你深入浅出搞懂Nginx/","excerpt":"","text":"Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。 架构图 上图基本上说明了当下流行的技术架构，其中Nginx有点入口网关的味道。 反向代理服务器？经常听人说到一些术语，如反向代理，那么什么是反向代理，什么又是正向代理呢？ 正向代理： 正向代理示意图 由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理“代理”的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。 反向代理： 反向代理示意图 当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。 Nginx的Master-Worker模式nginx进程 启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。 Master-Worker模式 nginx.conf Master进程的作用是？读取并验证配置文件nginx.conf；管理worker进程； Worker进程的作用是？每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。 思考：Nginx如何做到热部署？ 所谓热部署，就是配置文件nginx.conf修改后，不需要stop Nginx，不需要中断请求，就能让配置文件生效！（nginx -s reload 重新加载 nginx -t检查配置 nginx -s stop停止） 通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象： 方案一： 修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点valatile的味道） 方案二： 修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。 Nginx采用的就是方案二来达到热部署的！ 思考：Nginx如何做到高并发下的高效处理？上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞…要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。思考：Nginx挂了怎么办?Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。答案是：Keepalived+Nginx实现高可用。Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）Keepalived+Nginx实现高可用的思路：第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）Keepalived+Nginx 我们的主战场：nginx.conf 很多时候，在开发、测试环境下，我们都得自己去配置Nginx，就是去配置nginx.conf。 nginx.conf是典型的分段配置文件，下面我们来分析下。 其实这是把Nginx作为web server来处理静态资源。 第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开） 第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。 第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。 第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。 反向代理【proxy_pass】 所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。 反向代理，上面已经说了，过程是透明的，比如说request -&gt; Nginx -&gt; Tomcat，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置HTTP HEADER。 负载均衡【upstream】 上面的反向代理中，我们通过proxy_pass来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？ 第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。 第二，将proxy_pass替换成upstream指定的值即可。 负载均衡可能带来的问题？ 负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。 缓存 缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。具体配置，大家可以参考Nginx官方文档，这里就不在展开了","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"Nginx","slug":"Nginx","permalink":"https://www.zhangqifei.top/tags/Nginx/"}]},{"title":"Systemd 入门教程：命令篇","slug":"linux/Systemd 入门教程：命令篇","date":"2017-05-06T01:31:25.000Z","updated":"2018-04-22T09:30:14.835Z","comments":true,"path":"2017/05/06/linux/Systemd 入门教程：命令篇/","link":"","permalink":"https://www.zhangqifei.top/2017/05/06/linux/Systemd 入门教程：命令篇/","excerpt":"","text":"Systemd 是 Linux 系统工具，用来启动守护进程，已成为大多数发行版的标准配置。本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，下一篇介绍如何用于实战。历史上，Linux 的启动一直采用init进程。下面的命令用来启动服务。123$ /etc/init.d/apache2 start# 或者$ service apache2 start这种方法有两个缺点。1. 启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。2. 启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。（Systemd 作者 Lennart Poettering） 使用了 Systemd，就不需要再用init了。Systemd 取代了initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。1$ systemctl --version //查看 Systemd 的版本。 Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的Unix 哲学 （Systemd 架构图）Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。 systemd1234POST --&gt; Boot Sequence --&gt; Bootloader --&gt; kernel + initramfs(initrd) --&gt; rootfs--&gt; /sbin/init init:CentOS 5: SysV init CentOS 6: Upstart CentOS 7: Systemd Systemd：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程 Systemd新特性： 系统引导时实现服务并行启动 按需启动守护进程 自动化的服务依赖关系管理 同时采用socket式与D-Bus总线式激活服务 系统状态快照 核心概念： unit表示不同类型的systemd对象，通过配置文件进行标识和配置；文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息 配置文件： /usr/lib/systemd/system:每个服务最主要的启动脚本设置,类似于之前的/etc/init.d/ /run/systemd/system:系统执行过程中所产生的服务脚本,比上面目录优先运行 /etc/systemd/system:管理员建立的执行脚本,类似于/etc/rc.d/rcN.d/Sxx类的功能,比上面目录优先运行 Unit类型 Systemctl –t help 查看unit类型 Service unit: 文件扩展名为.service, 用于定义系统服务 Target unit: 文件扩展名为.target，用于模拟实现运行级别 Device unit: .device, 用于定义内核识别的设备 Mount unit: .mount, 定义文件系统挂载点 Socket unit: .socket,用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动 Scope Unit：不是由 Systemd 启动的外部进程 Slice Unit：进程组 Snapshot unit: .snapshot, 管理系统快照 Swap unit: .swap, 用于标识swap设备 Automount unit: .automount，文件系统的自动挂载点 Path unit: .path，用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时，延迟激活服务，如：spool 目录 特性关键特性： 基于socket的激活机制：socket与服务程序分离 基于d-bus的激活机制： 基于device的激活机制： 基于path的激活机制： 系统快照：保存各unit的当前状态信息于持久存储设备中向后兼容sysvinit脚本 不兼容： systemctl命令固定不变，不可扩展 非由systemd启动的服务，systemctl无法与之通信和控制 管理服务 管理系统服务：CentOS 7: service unit 注意：能兼容早期的服务脚本 命令：systemctl COMMAND name.service 启动：service name start ==&gt; systemctl start name.service 停止：service name stop ==&gt; systemctl stop name.service 重启：service name restart ==&gt; systemctl restart name.service 状态：service name status ==&gt; systemctl status name.service 条件式重启：已启动才重启，否则不做操作 service name condrestart ==&gt; systemctl try-restart name.service 重载或重启服务：先加载，再启动 systemctl reload-or-restart name.service 重载或条件式重启服务： systemctl reload-or-try-restart name.service 禁止自动和手动启动： systemctl mask name.service 取消禁止： systemctl unmask name.service 服务查看 查看某服务当前激活与否的状态：systemctl is-active name.service 查看所有已经激活的服务：systemctl list-units –type|-t service 查看所有服务：systemctl list-units –type service –all|-a chkconfig命令的对应关系： 设定某服务开机自启：chkconfig name on ==&gt; systemctl enable name.service 设定某服务开机禁止启动：chkconfig name off ==&gt; systemctl disable name.service 查看所有服务的开机自启状态：chkconfig –list ==&gt; systemctl list-unit-files –type service 用来列出该服务在哪些运行级别下启用和禁用chkconfig sshd–list ==&gt;ls /etc/systemd/system/*.wants/sshd.service 查看服务是否开机自启：systemctl is-enabled name.service 其它命令：查看服务的依赖关系：systemctl list-dependencies name.service 杀掉进程：systemctl kill unitname 服务状态 123456789systemctl list-unit-files --type service --all显示状态 loaded:Unit:配置文件已处理 active(running):一次或多次持续处理的运行 active(exited):成功完成一次性的配置 active(waiting):运行中，等待一个事件 inactive:不运行 enabled:开机启动 disabled:开机不启动 static:开机不启动，但可被另一个启用的服务激活 注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。 一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。 systemctl 命令示例 显示所有单元状态systemctl或systemctl list-units 只显示服务单元的状态systemctl –type=service ==&gt;systemctl -t=service 显示sshd服务单元systemctl –l status sshd.service 验证sshd服务当前是否活动systemctl is-active sshd 启动，停止和重启sshd服务systemctl start sshd.servicesystemctl stop sshd.servicesystemctl restart sshd.service 重新加载配置systemctl reload sshd.service 列出活动状态的所有服务单元systemctl list-units –type=service 列出所有服务单元systemctl list-units –type=service –all 查看服务单元的启用和禁用状态systemctl list-unit-files –type=service 列出失败的服务systemctl –failed –type=servicesy 列出依赖的单元systemctl list-dependencies sshd 验证sshd服务是否开机启动systemctl is-enabled sshd 禁用network，使之不能自动启动,但手动可以systemctl disable network 启用networksystemctl enable network 禁用network，使之不能手动或自动启动systemctl mask network 启用networksystemctl unmask network systemd-analyze 1234567891011# 查看启动耗时$ systemd-analyze # 查看每个服务的启动耗时$ systemd-analyze blame# 显示瀑布状的启动过程流$ systemd-analyze critical-chain # 显示指定服务的启动流$ systemd-analyze critical-chain atd.service hostnamectl查看当前主机的信息。12345# 显示当前主机的信息$ hostnamectl# 设置主机名。$ hostnamectl set-hostname rhel7 localectl查看本地化设置。12345678910111213141516171819# 查看本地化设置$ localectl# 设置本地化参数。$ localectl set-locale LANG=en_GB.utf8$ localectl set-keymap en_GB ``` ### timedatectl查看当前时区设置。```bash# 查看当前时区设置$ timedatectl# 显示所有可用的时区$ timedatectl list-timezones # 设置当前时区$ timedatectl set-timezone America/New_York$ timedatectl set-time YYYY-MM-DD$ timedatectl set-time HH:MM:SS loginctl查看当前登录的用户。12345678# 列出当前session$ loginctl list-sessions# 列出当前登录用户$ loginctl list-users# 列出显示指定用户的信息$ loginctl show-user ruanyf service unit文件格式 /etc/systemd/system：系统管理员和用户使用/usr/lib/systemd/system：发行版打包者使用 以“#” 开头的行后面的内容会被认为是注释 相关布尔值，1、yes、on、true 都是开启，0、no、off、false 都是关闭 时间单位默认是秒，所以要用毫秒（ms）分钟（m）等须显式说明 service unit file文件通常由三部分组成：[Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等[Service]：与特定类型相关的专用选项；此处为Service类型[Install]：定义由“systemctlenable”以及”systemctldisable“命令在实现服务启用或禁用时用到的一些选项 [Unit]段的常用选项： Description：描述信息 Documentation：文档地址 Requires：依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活 Wants：依赖到的其它units，弱依赖 Conflicts：定义units间的冲突关系 Condition…：当前 Unit 运行必须满足的条件，否则不会运行 Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败 After：定义unit的启动次序，表示当前unit应该晚于哪些unit启动，其功能与Before相反 BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行 Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动 从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。每个区块内部是一些等号连接的键值对;注意，键值对的等号两侧不能有空格. [Service]段的常用选项：[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。 Type：定义影响ExecStart及相关参数的功能的unit进程启动类型Type=simple：默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中Type=forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止Type=oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中Type=dbus：与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行Type=notify：在启动完成后会发送一个通知消息。还需要配合NotifyAccess 来让Systemd 接收消息Type=idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务 EnvironmentFile：环境配置文件 ExecStart：指明启动unit要运行命令或脚本的绝对路径 ExecStartPre：ExecStart前运行(启动当前服务之前执行的命令) ExecStartPost：ExecStart后运行(启动当前服务之后执行的命令) ExecStop：指明停止unit要运行的命令或脚本(停止当前服务时执行的命令) Restart：当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务(定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog) ExecReload：重启当前服务时执行的命令 ExecStopPost：停止当其服务之后执行的命令 RestartSec：自动重启当前服务间隔的秒数 TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数 Environment：指定环境变量 [Install]段的常用选项：[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。 Alias：别名，可使用systemctlcommand Alias.service RequiredBy：被哪些units所依赖，强依赖(它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中) WantedBy：被哪些units所依赖，弱依赖(它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中) Also：安装本服务的时候还要安装别的相关服务 注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载此配置文件,而后可以选择重启systemctl daemon-reloadUnit 配置文件的完整字段清单，请参考官方文档。 服务Unit文件示例： 123456789vim /etc/systemd/system/bak.service [Unit]Description=backup /etcRequires=atd.service[Service]Type=simpleExecStart=/bin/bash -c \"echo /testdir/bak.sh|at now\"[Install]WantedBy=multi-user.target systemctl daemon-reload systemctl start bak 启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。 简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。 传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。 运行级别 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950 target units： unit配置文件：.target ls /usr/lib/systemd/system/*.target systemctl list-unit-files --type target --all 运行级别： 0 ==&gt; runlevel0.target -&gt; poweroff.target 1 ==&gt; runlevel1.target -&gt; rescue.target 2 ==&gt; runlevel2.target -&gt; multi-user.target 3 ==&gt; runlevel3.target -&gt; multi-user.target 4 ==&gt; runlevel4.target -&gt; multi-user.target 5 ==&gt; runlevel5.target -&gt; graphical.target 6 ==&gt; runlevel6.target -&gt; reboot.target （1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。 （2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。 （3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。 查看依赖性： systemctl list-dependencies graphical.target 级别切换： initN ==&gt; systemctl isolate name.target systemctl isolate multi-user.target 注：只有/lib/systemd/system/*.target文件中AllowIsolate=yes 才能切换(修改文件需执行systemctl daemon-reload才能生效) 查看target： runlevel; who -r systemctl list-units --type target 获取默认运行级别： /etc/inittab==&gt; systemctl get-default 修改默认级别： /etc/inittab==&gt; systemctl set-default name.target systemctl set-default multi-user.target ls –l /etc/systemd/system/default.target 其它命令 切换至紧急救援模式（单用户状态）： systemctl rescue 切换至emergency模式： systemctl emergency 其它常用命令： 传统命令init，poweroff，halt，reboot都成为systemctl的软链接 关机：systemctl halt、systemctl poweroff 重启：systemctl reboot 挂起：systemctl suspend 休眠：systemctl hibernate 休眠并挂起：systemctl hybrid-sleep Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用journalctl一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是/etc/systemd/journald.conf journalctl功能强大，用法非常多。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980# 查看所有日志（默认情况下 ，只保存本次启动的日志）$ journalctl# 查看内核日志（不显示应用日志）$ journalctl -k# 查看系统本次启动的日志$ journalctl -b$ journalctl -b -0# 查看上一次启动的日志（需更改设置）$ journalctl -b -1# 查看指定时间的日志$ journalctl --since=\"2012-10-30 18:17:16\"$ journalctl --since \"20 min ago\"$ journalctl --since yesterday$ journalctl --since \"2015-01-10\" --until \"2015-01-11 03:00\"$ journalctl --since 09:00 --until \"1 hour ago\"# 显示尾部的最新10行日志$ journalctl -n# 显示尾部指定行数的日志$ journalctl -n 20# 实时滚动显示最新日志$ journalctl -f# 查看指定服务的日志$ journalctl /usr/lib/systemd/systemd# 查看指定进程的日志$ journalctl _PID=1# 查看某个路径的脚本的日志$ journalctl /usr/bin/bash# 查看指定用户的日志$ journalctl _UID=33 --since today# 查看某个 Unit 的日志$ journalctl -u nginx.service$ journalctl -u nginx.service --since today# 实时滚动显示某个 Unit 的最新日志$ journalctl -u nginx.service -f# 合并显示多个 Unit 的日志$ journalctl -u nginx.service -u php-fpm.service --since today# 查看指定优先级（及其以上级别）的日志，共有8级# 0: emerg# 1: alert# 2: crit# 3: err# 4: warning# 5: notice# 6: info# 7: debug$ journalctl -p err -b# 日志默认分页输出，--no-pager 改为正常的标准输出$ journalctl --no-pager# 以 JSON 格式（单行）输出$ journalctl -b -u nginx.service -o json# 以 JSON 格式（多行）输出，可读性更好$ journalctl -b -u nginx.serviceqq-o json-pretty# 显示日志占据的硬盘空间$ journalctl --disk-usage# 指定日志文件占据的最大空间$ journalctl --vacuum-size=1G# 指定日志文件保存多久$ journalctl --vacuum-time=1years","categories":[{"name":"centos","slug":"centos","permalink":"https://www.zhangqifei.top/categories/centos/"}],"tags":[{"name":"centos7","slug":"centos7","permalink":"https://www.zhangqifei.top/tags/centos7/"}]},{"title":"一次完整的http请求处理过程","slug":"随笔/一次完整的http请求处理过程","date":"2017-05-05T01:12:22.000Z","updated":"2018-04-23T07:12:14.436Z","comments":true,"path":"2017/05/05/随笔/一次完整的http请求处理过程/","link":"","permalink":"https://www.zhangqifei.top/2017/05/05/随笔/一次完整的http请求处理过程/","excerpt":"","text":"Web服务请求处理步骤 一次完整的http请求处理过程12345678910111213141516171819202122232425262728291、建立连接：接收或拒绝连接请求2、接收请求：接收客户端请求报文中对某资源的一次请求的过程3、处理请求：服务器对请求报文进行解析，并获取请求的资源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理 元数据：请求报文首部 &lt;method&gt; &lt;URL&gt; &lt;VERSION&gt; HEADERS格式name:value &lt;request body&gt; 示例： Host: www.chuyuni.cn 请求的主机名称 Server: Apache/2.4.7HTTP常用请求方式，MethodGET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS4、访问资源：服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源 资源放置于本地文件系统特定的路径：DocRoot DocRoot → /var/www/html /var/www/html/images/logo.jpg http://www.magedu.com/images/logo.jpg web服务器资源路径映射方式： (a) docroot (b) alias (c) 虚拟主机docroot(d) 用户家目录docroot5、构建响应报文：一旦Web服务器识别除了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体 1）响应实体：如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。响应报文中通常包括：描述了响应主体MIME类型的Content-Type首部描述了响应主体长度的Content-Length实际报文的主体内容 2）URL重定向：web服务构建的响应并非客户端请求的资源，而是资源另外一个访问路径 永久重定向：http://www.360buy.com 临时重定向：http://www.taobao.com 3）MIME类型：Web服务器要负责确定响应主体的MIME类型。多种配置服务器的方法可将MIME类型与资源管理起来魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名时显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型类型协商：有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)&quot;最好&quot; 6、发送响应报文：Web服务器通过连接发送数据时也会面临与接收数据一样的问题。服务器可能有很多条到各个客户端的连接，有些是空闲的，有些在向服务器发送数据，还有一些在向客户端回送响应数据。服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束了7、记录日志：最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务 Web访问响应模型（Web I/O） 单进程I/O模型：启动一个进程处理用户请求，而且一次只处理一个，多个请求被串行响应 多进程I/O模型：并行启动多个进程,每个进程响应一个连接请求 复用I/O结构：启动一个进程，同时响应N个连接请求实现方法：多线程模型和事件驱动多线程模型：一个进程生成N个线程，每线程响应一个连接请求事件驱动：一个进程处理N个请求 复用的多进程I/O模型：启动M个进程，每个进程响应N个连接请求，同时接收M*N个请求","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.zhangqifei.top/tags/HTTP/"}]},{"title":"Linux各发行版时间线2017年版本","slug":"linux/Linux各发行版时间线2017年版本","date":"2017-03-05T14:47:20.000Z","updated":"2018-04-22T09:30:14.906Z","comments":true,"path":"2017/03/05/linux/Linux各发行版时间线2017年版本/","link":"","permalink":"https://www.zhangqifei.top/2017/03/05/linux/Linux各发行版时间线2017年版本/","excerpt":"","text":"时间线目前版本16.12，于2017年2月1日发布，参见wikipedia svg图片太长，无法显示，可以点击链接下载:点这儿","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://www.zhangqifei.top/tags/Linux/"}]},{"title":"Linux防火墙","slug":"linux/Linux防火墙","date":"2017-03-04T01:42:22.000Z","updated":"2018-04-22T09:29:33.353Z","comments":true,"path":"2017/03/04/linux/Linux防火墙/","link":"","permalink":"https://www.zhangqifei.top/2017/03/04/linux/Linux防火墙/","excerpt":"","text":"安全技术 入侵检测与管理系统（Intrusion Detection Systems）：特点是不阻断任何网络访问，量化、定位来自内外网络的威胁情况，主要以提供报告和事后监督为主，提供有针对性的指导措施和安全决策依据。一般采用旁路部署方式 入侵防御系统（Intrusion Prevention System）：以透明模式工作，分析数据包的内容如：溢出攻击、拒绝服务攻击、木马、蠕虫、系统漏洞等进行准确的分析判断，在判定为攻击行为后立即予以阻断，主动而有效的保护网络的安全，一般采用在线部署方式 防火墙（FireWall ）：隔离功能，工作在网络或主机边缘，对进出网络或主机的数据包基于一定的规则检查，并在匹配某规则时由规则定义的行为进行处理的一组功能的组件，基本上的实现都是默认情况下关闭所有的通过型访问，只开放允许访问的策略 防火墙的分类 主机防火墙：服务范围为当前主机 网络防火墙：服务范围为防火墙一侧的局域网 硬件防火墙：在专用硬件级别实现部分功能的防火墙；另一个部分功能基于软件实现，Checkpoint,NetScreen 软件防火墙：运行于通用硬件平台之上的防火墙的应用软件 网络层防火墙：OSI下面第三层 应用层防火墙/代理服务器：代理网关，OSI七层 网络型防火墙 包过滤防火墙 网络层对数据包进行选择，选择的依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL），通过检查数据流中每个数据的源地址，目的地址，所用端口号和协议状态等因素，或他们的组合来确定是否允许该数据包通过 优点：对用户来说透明，处理速度快且易于维护 缺点：无法检查应用层数据，如病毒等 应用层防火墙应用层防火墙/代理服务型防火墙（Proxy Service） 将所有跨越防火墙的网络通信链路分为两段 内外网用户的访问都是通过代理服务器上的“链接”来实现 优点：在应用层对数据进行检查，比较安全 缺点：增加防火墙的负载 现实生产环境中所使用的防火墙一般都是二者结合体 即先检查网络数据，通过之后再送到应用层去检查 iptables的基本认识Netfilter组件 内核空间，集成在linux内核中 扩展各种网络服务的结构化底层框架 内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则 由信息过滤表（table）组成，包含控制IP包处理的规则集（rules），规则被分组放在链（chain）上 内核中数据包的传输过程 当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去 如果数据包就是进入本机的，数据包就会沿着图向下移动，到达INPUT链。数据包到达INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包经过OUTPUT链，然后到达POSTROUTING链输出 如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过FORWARD链，然后到达POSTROUTING链输出 三种报文流向： 流入本机： PREROUTING –&gt; INPUT–&gt;用户空间进程 流出本机： 用户空间进程–&gt;OUTPUT–&gt; POSTROUTING 转发： PREROUTING –&gt; FORWARD –&gt; POSTROUTING 防火墙工具12345678iptables 命令行工具，工作在用户空间 用来编写规则，写好的规则被送往netfilter，告诉内核如何去处理信息包firewalld CentOS 7引入了新的前端管理工具 管理工具： firewall-cmd命令行 firewall-config图形 iptables的组成iptables由四个表和五个链以及一些规则组成四个表table： filter表: 过滤规则表，根据预定义的规则过滤符合条件的数据包 nat表: network address translation 地址转换规则表 mangle: 修改数据标记位规则表 Raw: 关闭NAT表上启用的连接跟踪机制，加快封包穿越防火墙速度 优先级由高到低: raw–&gt;mangle–&gt;nat–&gt;filter五个内置链chain INPUT OUTPUT FORWARD PREROUTING POSTROUTING Netfilter表和链对应关系优先级由高到低: raw -&gt; mangle -&gt; nat -&gt; filter 数据包过滤匹配流程 iptables规则规则rule：根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作作出处理123456匹配条件：默认为与条件，同时满足 基本匹配：IP,端口,TCP的Flags（SYN,ACK等） 扩展匹配：通过复杂高级功能匹配处理动作：称为target，跳转目标 内建处理动作：ACCEPT(接收),DROP(婉转的拒绝),REJECT(强硬的拒绝),SNAT,DNAT,MASQUERADE,MARK,LOG... 自定义处理动作：自定义chain，利用分类管理复杂情形 规则要添加在链上，才生效；添加在自定义上不会自动生效链chain：: 内置链：每个内置链对应于一个钩子函数 自定义链：用于对内置链进行扩展或补充，可实现更灵活的规则组织管理机制；只有Hook钩子调用自定义链时，才生效 iptables规则添加时考量点 要实现哪种功能：判断添加在哪张表上 报文流经的路径：判断添加在哪个链上 报文的流向：判断源和目的 匹配规则：业务需要 链上规则的次序，即为检查的次序，因此隐含一定的法则 同类规则(访问同一应用)，匹配范围小的放上面 不同类规则(访问不同应用)，匹配到报文频率较大的放上面 将那些可由一条规则描述的多个规则合并为一个 设置默认策略 实验环境准备： Centos7: systemctl stop firewalld.service systemctl disable firewalld.service Centos6: service iptables stop chkconfig iptables off iptables命令123456789101112131415161718192021222324252627man 8 iptablesiptables [-t table] &#123;-A|-C|-D&#125; chain rule-specificationiptables [-t table] -I chain [rulenum] rule-specificationiptables [-t table] -R chain rulenum rule-specificationiptables [-t table] -D chain rulenumiptables [-t table] -S [chain [rulenum]]iptables [-t table] &#123;-F|-L|-Z&#125; [chain [rulenum]] [options...]iptables [-t table] -N chainiptables [-t table] -X [chain]iptables [-t table] -P chain targetiptables [-t table] -E old-chain-name new-chain-namerule-specification = [matches...] [target]match = -m matchname [per-match-options]target = -j targetname [per-target-options] 示例1：从172.18.99.1来的所有全部拒绝访问12[root@centos7 ~]#iptables -A INPUT -s 172.18.99.1 -j DROP-A 添加 -I 插入 -s 后指定源地址 -j 策略 iptables命令规则格式：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586iptables [-t table] SUBCOMMAND chain [-m matchname[per-match-options]] -j targetname[per-target-options]---------------------------------t table(表)：raw, mangle, nat, [filter]默认--------------------------------SUBCOMMAND(子命令)： 1、链管理： -N：new, 自定义一条新的规则链 -X：delete，删除自定义的空的规则链 -P：Policy，设置默认策略；对filter表中的链而言，其默认策略有： ACCEPT：接受 DROP：丢弃 -E：重命名自定义链；引用计数不为0的自定义链不能够被重命名，也不能被删除 2、查看： -L：list, 列出指定鏈上的所有规则，本选项须置后 -n：numberic，以数字格式显示地址和端口号 -v：verbose，详细信息 -vv更详细 -x：exactly，显示计数器结果的精确值,而非单位转换后的易读值(字节数更精确) --line-numbers：显示规则的序号 常用组合： --vnL --vvnxL --line-numbers -S selected,以iptables-save 命令格式显示链上规则 3、规则管理： -A：append，追加 -I：insert, 插入，要指明插入至的规则编号，默认为第一条 -D：delete，删除(1) 指明规则序号(2) 指明规则本身 -R：replace，替换指定链上的指定规则编号 -F：flush，清空指定的规则链 -Z：zero，置零(包数指从头开始) iptables的每条规则都有两个计数器 (1) 匹配到的报文的个数 (2) 匹配到的所有报文的大小之和--------------------------------chain：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING匹配条件 基本：通用的，PARAMETERS 扩展：需加载模块，MATCH EXTENTIONS1、基本匹配条件：无需加载模块，由iptables/netfilter自行提供 [!] -s, --source address[/mask][,...]：源IP地址或范围 [!] -d, --destination address[/mask][,...]：目标IP地址或范围 [!] -p, --protocol protocol：指定协议，可使用数字如0（all） protocol: tcp, udp, icmp, icmpv6,udplite,esp, ah, sctp, mhor \"all\" 参看：/etc/protocols [!] -i, --in-interface name：报文流入的接口；只能应用于数据报文流入环节，只应用于INPUT、FORWARD、PREROUTING链 [!] -o, --out-interface name：报文流出的接口；只能应用于数据报文流出的环节，只应用于FORWARD、OUTPUT、POSTROUTING链2 扩展匹配条件：需要加载扩展模块（/usr/lib64/xtables/*.so），方可生效 查看帮助man iptables-extensions (1)隐式扩展：在使用-p选项指明了特定的协议时，无需再用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块 tcp协议的扩展选项 [!] --source-port, --sport port[:port]：匹配报文源端口,可为端口范围 [!] --destination-port,--dportport[:port]：匹配报文目标端口,可为范围 [!] --tcp-flags mask comp mask 需检查的标志位列表，用,分隔 例如SYN,ACK,FIN,RST comp 在mask列表中必须为1的标志位列表，无指定则必须为0，用,分隔 示例： --tcp-flags SYN,ACK,FIN,RST SYN 表示要检查的标志位为SYN,ACK,FIN,RST四个，其中SYN必须为1，余下的必须为0 --tcp-flags SYN,ACK,FIN,RST SYN,ACK --tcp-flags ALL ALL --tcp_flagsALL NONE [!] --syn：用于匹配第一次握手 相当于：--tcp-flags SYN,ACK,FIN,RST SYN udp协议的扩展选项 [!] --source-port, --sport port[:port]：匹配报文的源端口；可以是端口范围 [!] --destination-port,--dportport[:port]：匹配报文的目标端口；可以是端口范围 icmp协议的扩展选项 [!] --icmp-type &#123;type[/code]|typename&#125; type/code 0/0 echo-replyicmp应答 8/0 echo-request icmp请求 (2)显式扩展：必须使用-m选项指明要调用的扩展模块的扩展机制，要手动加载扩展模块 [-m matchname[per-match-options]] 处理动作： -j targetname [per-target-options] 简单：ACCEPT，DROP 扩展：REJECT：--reject-with:icmp-port-unreachable默认 RETURN：返回调用链 REDIRECT：端口重定向 LOG：记录日志，dmesg MARK：做防火墙标记 DNAT：目标地址转换 SNAT：源地址转换 MASQUERADE：地址伪装 ... 自定义链： 12345678910111213Chain INPUT (policy ACCEPT 21144 packets, 3008K bytes) pkts bytes target prot opt in out source destination 21 1954 DROP all -- * * 172.18.99.1 0.0.0.0/0 16 1320 REJECT all -- * * 172.18.99.1 0.0.0.0/0 reject-with icmp-port-unreachable pkts:包数 bytes:字节数 target:处理动作 prot:协议 opt: in:传入 out:传出 source:原地址 destination:目标地址 ······持续更新中······","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"防火墙","slug":"防火墙","permalink":"https://www.zhangqifei.top/tags/防火墙/"}]},{"title":"Chrome浏览器最牛插件之一 Vimium","slug":"工具/Chrome浏览器最牛插件之一 Vimium","date":"2017-02-08T00:33:59.000Z","updated":"2018-04-23T07:12:34.107Z","comments":true,"path":"2017/02/08/工具/Chrome浏览器最牛插件之一 Vimium/","link":"","permalink":"https://www.zhangqifei.top/2017/02/08/工具/Chrome浏览器最牛插件之一 Vimium/","excerpt":"","text":"vimiumVimium 这个名字其实是 Vim 和 Chromium 的合体。很多人可能不知道 Vim，Vim 其实是 Linux 等平台上的一款文本编辑器，熟练的运用它可以彻底脱离鼠标，通过一系列快捷键，来操作写代码。而 Vimium 则继承了 Vim 中的常用操作，让你在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。想像一下，你再也不需要移动鼠标去打开一个链接，手指不用离开键盘，这一切将会是多么的幸福。 废话不多说，直接上快捷键😁.上操作命令 导航当页123456789101112131415161718? 显示help，查询vimium的所有使用方法h 向左滚动j 向下滚动k 向上滚动l 向右滚动gg 滚动到顶部G 滚动到底部d 向下滚动半页u 向上滚动半页面f 显示链接字母，在当前页面打开F 显示链接字母，在新的页面打开r 刷新gs 显示网页源代码i 进入插入模式，所有按键的命令都无效，直至ESC键退出yy 将当前的网址复制到剪贴板yf 显示链接字母，并将网址拷贝到剪贴板gf cycle forward to the next framegF focus the main/top frame 打开新的页面1234o 搜索网址，书签，或历史记录，在当前页面打开O 搜索网址，书签，或历史记录，在新的页面打开b 搜索书签，在当前页面打开B 搜索书签，在新的页面打开 查找123/ 进入查找模式，输入关键字查找，ESC退出n 切换到下一个匹配N 切换到上一个匹配 前进后退12H 后退L 前进 切换tab1234567891011J, gT 切换到左边tabK, gt 切换到右边tabg0 切换到第一个tabg$ 切换到最后一个tab^ 切换到刚才的tabt 创建一个新的页面yt 复制当前页面x 关闭当前页面X 恢复刚才关闭的页面T 在当前所有的tab页面中搜索&lt;a-p&gt; pin/unpin current tab 标记12345ma 当页标记，只能在当前tab页面跳转，m + 一个小写字母mA 全局标记，可以再切换到其他tab的跳转过来，m + 一个大写字母`a 跳转到当页标记`A 跳转到全局标记`` 跳回之前的位置 进阶控制命令123456789101112]], [[ Follow the link labeled &apos;next&apos; or &apos;&gt;&apos; (&apos;previous&apos; or &apos;&lt;&apos;) - helpful for browsing paginated sites&lt;a-f&gt; open multiple links in a new tabgi focus the first (or n-th) text input box on the pagegu 跳转到当前网址的上一级网址gU 跳转到当前网址的跟网址ge 编辑当前的网址，在当前页面打开gE 编辑当前网址，在新的页面打开zH 滚动到最左边zL 滚动到最右边v enter visual mode; use p/P to paste-and-go, use y to yankV enter visual line mode 其他125t 数字num + t，打开num个tab页面&lt;Esc&gt; ESC按钮，可以从任意控制命令中退出，也可以从任意模式中退出（例如插入模式、查找模式）","categories":[{"name":"浏览器","slug":"浏览器","permalink":"https://www.zhangqifei.top/categories/浏览器/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://www.zhangqifei.top/tags/Chrome/"}]},{"title":"CentOS7启动及排错","slug":"linux/CentOS7启动及排错","date":"2017-01-06T17:50:32.000Z","updated":"2018-04-22T08:27:28.687Z","comments":true,"path":"2017/01/07/linux/CentOS7启动及排错/","link":"","permalink":"https://www.zhangqifei.top/2017/01/07/linux/CentOS7启动及排错/","excerpt":"","text":"CentOS7引导顺序 UEFi或BIOS初始化，运行POST开机自检 选择启动设备 引导装载程序, centos7是grub2 加载装载程序的配置文件：/etc/grub.d//etc/default/grub/boot/grub2/grub.cfg 加载initramfs驱动模块加载内核选项 内核初始化，centos7使用systemd代替init 执行initrd.target所有单元，包括挂载/etc/fstab 从initramfs根文件系统切换到磁盘根目录 systemd执行默认target配置，配置文件/etc/systemd/system/default.target systemd执行sysinit.target初始化系统及basic.target准备操作系统 systemd启动multi-user.target下的本机与服务器服务 systemd执行multi-user.target下的/etc/rc.d/rc.local Systemd执行multi-user.target下的getty.target及登录服务 systemd执行graphical需要的服务 设置内核参数 设置内核参数，只影响当次启动 启动时，在linux16行后添加systemd.unit=desired.target systemd.unit=emergency.target systemd.unit=rescue.target rescue.target 比emergency 支持更多的功能，例如日志等 systemctl default 进入默认target 启动排错 文件系统损坏先尝试自动修复，失败则进入emergency shell，提示用户修复 在/etc/fstab不存在对应的设备和UUID等一段时间，如不可用，进入emergency shell 在/etc/fstab不存在对应挂载点systemd尝试创建挂载点，否则提示进入emergency shell. 在/etc/fstab不正确的挂载选项提示进入emergency shell 破解CentOS7的root口令方法一 启动时任意键暂停启动 按e键进入编辑模式 将光标移动linux16开始的行，添加内核参数rd.break 按ctrl-x启动 mount –o remount,rw /sysroot chroot /sysroot passwd root touch /.autorelabel exit reboot破解 破解CentOS7的root口令方法二 启动时任意键暂停启动 按e键进入编辑模式 将光标移动linux16开始的行，改为rw init=/sysroot/bin/sh 按ctrl-x启动 chroot /sysroot passwd root touch /.autorelabel exit reboot centous7设置默认启动内核，并删除配置文件 ：/boot/grub2/grub.cfg修改：/etc/default/grub GRUB_DEFAULT=saved saved改为0grub2-mkconfig -o /boot/grub2/grub.crg 重新生成 删除没用的内核/boot/ 和 /lib/modules/ 里面内核版本的东西 3.10.0.xxxxgrub2-mkconfig -o /boot/grub2/grub.crg 重新生成 修复GRUB2 GRUB”the Grand Unified Bootloader”引导提示时可以使用命令行界面可从文件系统引导 主要配置文件/boot/grub2/grub.cfg 修复配置文件grub2-mkconfig &gt; /boot/grub2/grub.cfg 修复grub grub2-install /dev/sdaBIOS环境grub2-install UEFI环境 调整默认启动内核vim /etc/default/grubGRUB_DEFAULT=0 ![grub.cfg破坏][1] 删除boot下所有 进入救援模式 输入 1 continue 2 进入shell chroot /mnt/sysimage mkdir /mnt/cdroom mount -o /dev/cdroom /mnt/cdroom rpm -ivh /mnt/cdroom/Packages/kernel-3.10.0.693.e17.x86.rpm –force grub2-install /dev/sda 修复配置文件grub2-mkconfig &gt; /boot/grub2/grub.cfg exit reboot","categories":[{"name":"centos","slug":"centos","permalink":"https://www.zhangqifei.top/categories/centos/"}],"tags":[{"name":"centos7","slug":"centos7","permalink":"https://www.zhangqifei.top/tags/centos7/"}]},{"title":"自建CA认证和证书","slug":"linux/自建CA认证和证书","date":"2016-09-05T16:07:24.000Z","updated":"2018-04-22T09:29:32.785Z","comments":true,"path":"2016/09/06/linux/自建CA认证和证书/","link":"","permalink":"https://www.zhangqifei.top/2016/09/06/linux/自建CA认证和证书/","excerpt":"","text":"一些概念： PKI：Public Key Infrastructure 签证机构：CA（Certificate Authority） 注册机构：RA（Register Authority） 证书吊销列表：CRL（Certificate Revoke Lists） 证书存取库 X.509：定义了证书的结构和认证协议的标准。包括版本号、序列号、签名算法、颁发者、有效期限、主体名称、主体公钥、CRL分发点、扩展信息、发行者签名等 获取证书的两种方法： 使用证书授权机构 生成签名请求（csr） 将csr发送给CA 从CA处接收签名 自签名的证书 自已签发自己的公钥重点介绍一下自建CA颁发机构和自签名。 自建CA颁发机构和自签名实验用两台服务器，一台做ca颁发证书，一台去请求签名证书。 证书申请及签署步骤： 生成申请请求 CA核验 CA签署 获取证书 我们先看一下openssl的配置文件：/etc/pki/tls/openssl.cnf1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556####################################################################[ ca ]default_ca = CA_default # The default ca section(默认的CA配置，是CA_default,下面第一个小节就是)####################################################################[ CA_default ]dir = /etc/pki/CA # Where everything is kept （dir变量）certs = $dir/certs # Where the issued certs are kept（认证证书目录）crl_dir = $dir/crl # Where the issued crl are kept（注销证书目录）database = $dir/index.txt # database index file.（数据库索引文件）new_certs_dir = $dir/newcerts # default place for new certs.（新证书的默认位置）certificate = $dir/cacert.pem # The CA certificate（CA机构证书）serial = $dir/serial # The current serial number（当前序号，默认为空，可以指定从01开始）crlnumber = $dir/crlnumber # the current crl number（下一个吊销证书序号） # must be commented out to leave a V1 CRLcrl = $dir/crl.pem # The current CRL（下一个吊销证书）private_key = $dir/private/cakey.pem# The private key（CA机构的私钥）RANDFILE = $dir/private/.rand # private random number file（随机数文件）x509_extensions = usr_cert # The extentions to add to the cert# Comment out the following two lines for the \"traditional\"# (and highly broken) format.name_opt = ca_default # Subject Name options（被颁发者，订阅者选项）cert_opt = ca_default # Certificate field options（认证字段参数）# Extension copying option: use with caution.# copy_extensions = copy# Extensions to add to a CRL. Note: Netscape communicator chokes on V2 CRLs# so this is commented out by default to leave a V1 CRL.# crlnumber must also be commented out to leave a V1 CRL.# crl_extensions = crl_extdefault_days = 365 # how long to certify for （默认的有效期天数是365）default_crl_days= 30 # how long before next CRLdefault_md = sha256 # use SHA-256 by defaultpreserve = no # keep passed DN ordering# A few difference way of specifying how similar the request should look# For type CA, the listed attributes must be the same, and the optional# and supplied fields are just that :-)policy = policy_match # 是否匹配规则# For the CA policy[ policy_match ]countryName = match # 国家名是否匹配，match为匹配stateOrProvinceName = match # 州或省名是否需要匹配organizationName = match # 组织名是否需要匹配organizationalUnitName = optional # 组织的部门名字是否需要匹配commonName = supplied # 注释emailAddress = optional # 邮箱地址# For the 'anything' policy# At this point in time, you must list all acceptable 'object'# types.[ policy_anything ]countryName = optionalstateOrProvinceName = optionallocalityName = optionalorganizationName = optionalorganizationalUnitName = optionalcommonName = suppliedemailAddress = optional#################################################################### 重点关注下面的几个参数：1234567dir = /etc/pki/CA # Where everything is kept （dir变量）certs = $dir/certs # Where the issued certs are kept（认证证书目录）database = $dir/index.txt # database index file.（数据库索引文件）new_certs_dir = $dir/newcerts # default place for new certs.（新证书的默认位置）certificate = $dir/cacert.pem # The CA certificate（CA机构证书）serial = $dir/serial # The current serial number（当前序号，默认为空，可以指定从01开始）private_key = $dir/private/cakey.pem# The private key（CA机构的私钥） 1、创建所需要的文件touch /etc/pki/CA/index.txt生成证书索引数据库文件 echo 01 &gt; /etc/pki/CA/serial指定第一个颁发证书的序列号,16进制数，比如可以从1a开始，一般从01开始。 2、CA自签证书在作为CA的服务器上操作： 生成私钥 1234[root@aliyun ~]#(umask 066;openssl genrsa -out /etc/pki/CA/private/cakey.pem 4096)Generating RSA private key, 4096 bit long modulus.....++..............................................++ 生成自签名证书 123456789101112131415[root@aliyun ~]#openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem -days 7300 -out /etc/pki/CA/cacert.pemYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [XX]:CN (国名（2个字母代码）[XX]：CN）State or Province Name (full name) []:Beijing （州或省名称（全称）北京）Locality Name (eg, city) [Default City]:Beijing （地区名称（如城市）[默认城市]：北京）Organization Name (eg, company) [Default Company Ltd]:shangdigongsi （组织名称（如公司）：上帝公司）Organizational Unit Name (eg, section) []:opt （组织单位名称：opt）Common Name (eg, your name or your server's hostname) []:centos （通用名称（例如，您的名字或您的服务器的主机名）[]：centos）Email Address []:1353250703@qq.com （电子邮件地址[]：1353250703@qq.com） 参数解析： -new: 生成新证书签署请求-x509: 专用于CA生成自签证书-key: 生成请求时用到的私钥文件-days n：证书的有效期限-out /PATH/TO/SOMECERTFILE: 证书的保存路径 3、颁发证书 在需要使用证书的主机生成证书请求(比如给一台作为博客web服务的服务器生成私钥) 12345[root@aliyun ~]#(umask 066; openssl genrsa -out /etc/pki/tls/private/blog.key 4096)Generating RSA private key, 4096 bit long modulus.....................................++......................................................................................................................++e is 65537 (0x10001) 生成证书申请文件 1234567891011121314151617181920[root@aliyun ~]#openssl req -new -key /etc/pki/tls/private/blog.key -days 3560 -out /etc/pki/tls/blog.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [XX]:CN (国名（2个字母代码）[XX]：CN）State or Province Name (full name) []:Beijing（州或省名称（全称）北京）Locality Name (eg, city) [Default City]:Bejing （地区名称（如城市）[默认城市]：北京）Organization Name (eg, company) [Default Company Ltd]:shangdigongsi（组织名称（如公司）：上帝公司）Organizational Unit Name (eg, section) []:centos（组织单位名称：opt）Common Name (eg, your name or your server's hostname) []:opt （通用名称（例如，您的名字或您的服务器的主机名）[]：centos）Email Address []:（电子邮件地址[]：1353250703@qq.com）Please enter the following 'extra' attributes （请输入以下“额外”属性）to be sent with your certificate request（要发送您的证书请求）A challenge password []:（密码[ ]：）An optional company name []:（可选的公司名称） 将证书请求文件传输给CA 123[root@aliyun ~]#scp /etc/pki/tls/blog.csr root@172.16.111.100:/tmp/root@172.16.111.100s passwordblog.csr 100% 1773 1.7Mb/s CA签署证书，并将证书颁发给请求者 注意：默认国家，省，公司名称三项必须和CA一致 把blog.crt证书回传给申请者，申请者可以使用此证书。 证书可以放在网站里，比如tomacat服务有专门存放证书的地方，还有可能需要转化格式，此处使用方法暂略 4、吊销证书 在客户端获取要吊销的证书的serial 1openssl x509 -in /PATH/FROM/CERT_FILE -noout -serial -subject 在CA上，根据客户提交的serial与subject信息，对比检验是否与index.txt文件中的信息一致，吊销证书： 1openssl ca -revoke /etc/pki/CA/newcerts/SERIAL.pem 指定第一个吊销证书的编号1echo 01 &gt; /etc/pki/CA/crlnumber 注意：这里只有在第一次更新证书吊销列表前，才需要执行指定编号。 更新证书吊销列表 1openssl ca -gencrl -out /etc/pki/CA/crl/crl.pem 查看crl文件： 1openssl crl -in /etc/pki/CA/crl/crl.pem -noout -text 更加详细的步骤以及代码实现hexo","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"CA","slug":"CA","permalink":"https://www.zhangqifei.top/tags/CA/"}]},{"title":"linux命令-head","slug":"linux/linux命令-head","date":"2016-07-06T09:12:42.000Z","updated":"2018-04-22T09:29:33.121Z","comments":true,"path":"2016/07/06/linux/linux命令-head/","link":"","permalink":"https://www.zhangqifei.top/2016/07/06/linux/linux命令-head/","excerpt":"","text":"head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 命令格式： head [参数]… [文件]… 命令功能： head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 命令参数： -q 隐藏文件名 -v 显示文件名 -c&lt;字节&gt; 显示字节数 -n&lt;行数&gt; 显示的行数 使用实例： 实例1：显示文件的前n行命令：head -n n /etc/passwd 实例2：显示文件前n个字节命令：head -c n /etc/passwd 实例3：文件的除了最后n个字节以外的内容命令：head -c -n /etc/passwd 实例4：输出文件除了最后n行的全部内容命令：head -n -n /etc/passwd","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://www.zhangqifei.top/tags/命令/"}]},{"title":"linux命令-seq","slug":"linux/linux命令-seq","date":"2016-07-06T08:12:42.000Z","updated":"2018-04-22T09:29:32.809Z","comments":true,"path":"2016/07/06/linux/linux命令-seq/","link":"","permalink":"https://www.zhangqifei.top/2016/07/06/linux/linux命令-seq/","excerpt":"","text":"seq命令用于产生从某个数到另外一个数之间的所有整数。 语法123seq [选项]... 尾数seq [选项]... 首数 尾数 seq [选项]... 首数 增量 尾数 选项123-f, --format=格式 使用printf 样式的浮点格式-s, --separator=字符串 使用指定字符串分隔数字（默认使用：\\n）-w, --equal-width 在列前添加0 使得宽度相同 练习-f选项：指定格式12345[root@centos7 ~]#seq -f &quot;%3g&quot; 9 11 9 10 11 注意：%后面指定数字的位数默认是%g，%3g那么数字位数不足部分是空格。 12345[root@centos7 ~]#seq -f &quot;str%03g&quot; 9 11 str009str010str011注意：这样的话数字位数不足部分是0，%前面制定字符串。 -w选项：指定输出数字同宽123456[root@centos7 ~]#seq -w 98 101098 099100 101 注意：不能和-f一起用，输出是同宽的。 s选项：指定分隔符（默认是回车）12[root@centos7 ~]#seq -s&quot; &quot; -f&quot;str%03g&quot; 9 11 str009 str010 str011 指定\\n作为分隔符号：12[root@centos7 ~]#seq -s&quot;`echo -e &quot;/t&quot;`&quot; 9 119/t10/t11","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://www.zhangqifei.top/tags/命令/"}]},{"title":"linux命令-grep","slug":"linux/linux命令-grep","date":"2016-07-06T07:12:42.000Z","updated":"2018-04-22T09:29:33.091Z","comments":true,"path":"2016/07/06/linux/linux命令-grep/","link":"","permalink":"https://www.zhangqifei.top/2016/07/06/linux/linux命令-grep/","excerpt":"","text":"Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。 grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。 grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。 1．命令格式： grep [option] pattern file 2．命令功能：用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。 3．命令参数：1234567891011121314151617181920212223242526-a --text #不要忽略二进制的数据。 -A&lt;显示行数&gt; --after-context=&lt;显示行数&gt; #除了显示符合范本样式的那一列之外，并显示该行之后的内容。 -b --byte-offset #在显示符合样式的那一行之前，标示出该行第一个字符的编号。 -B&lt;显示行数&gt; --before-context=&lt;显示行数&gt; #除了显示符合样式的那一行之外，并显示该行之前的内容。 -c --count #计算符合样式的列数。 -C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt; #除了显示符合样式的那一行之外，并显示该行之前后的内容。 -d &lt;动作&gt; --directories=&lt;动作&gt; #当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。 -e&lt;范本样式&gt; --regexp=&lt;范本样式&gt; #指定字符串做为查找文件内容的样式。 -E --extended-regexp #将样式为延伸的普通表示法来使用。 -f&lt;规则文件&gt; --file=&lt;规则文件&gt; #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。 -F --fixed-regexp #将样式视为固定字符串的列表。 -G --basic-regexp #将样式视为普通的表示法来使用。 -h --no-filename #在显示符合样式的那一行之前，不标示该行所属的文件名称。 -H --with-filename #在显示符合样式的那一行之前，表示该行所属的文件名称。 -i --ignore-case #忽略字符大小写的差别。 -l --file-with-matches #列出文件内容符合指定的样式的文件名称。 -L --files-without-match #列出文件内容不符合指定的样式的文件名称。 -n --line-number #在显示符合样式的那一行之前，标示出该行的列数编号。 -q --quiet或--silent #不显示任何信息。 -r --recursive #此参数的效果和指定“-d recurse”参数相同。 -s --no-messages #不显示错误信息。 -v --revert-match #显示不包含匹配文本的所有行。 -V --version #显示版本信息。 -w --word-regexp #只显示全字符合的列。 -x --line-regexp #只显示全列符合的列。 -y #此参数的效果和指定“-i”参数相同。 4．规则表达式：grep的规则表达式:12345678910111213141516^ #锚定行的开始 如：&apos;^grep&apos;匹配所有以grep开头的行。 $ #锚定行的结束 如：&apos;grep$&apos;匹配所有以grep结尾的行。 . #匹配一个非换行符的字符 如：&apos;gr.p&apos;匹配gr后接一个任意字符，然后是p。 * #匹配零个或多个先前字符 如：&apos;*grep&apos;匹配所有一个或多个空格后紧跟grep的行。 .* #一起用代表任意字符。 [] #匹配一个指定范围内的字符，如&apos;[Gg]rep&apos;匹配Grep和grep。 [^] #匹配一个不在指定范围内的字符，如：&apos;[^A-FH-Z]rep&apos;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。 \\(..\\) #标记匹配字符，如&apos;\\(love\\)&apos;，love被标记为1。 \\&lt; #锚定单词的开始，如:&apos;\\&lt;grep&apos;匹配包含以grep开头的单词的行。 \\&gt; #锚定单词的结束，如&apos;grep\\&gt;&apos;匹配包含以grep结尾的单词的行。 x\\&#123;m\\&#125; #重复字符x，m次，如：&apos;0\\&#123;5\\&#125;&apos;匹配包含5个o的行。 x\\&#123;m,\\&#125; #重复字符x,至少m次，如：&apos;o\\&#123;5,\\&#125;&apos;匹配至少有5个o的行。 x\\&#123;m,n\\&#125; #重复字符x，至少m次，不多于n次，如：&apos;o\\&#123;5,10\\&#125;&apos;匹配5--10个o的行。 \\w #匹配文字和数字字符，也就是[A-Za-z0-9]，如：&apos;G\\w*p&apos;匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b #单词锁定符，如: &apos;\\bgrep\\b&apos;只匹配grep。 POSIX字符:为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。 1234567891011[:alnum:] #文字数字字符 [:alpha:] #文字字符 [:digit:] #数字字符 [:graph:] #非空字符（非空格、控制字符） [:lower:] #小写字符 [:cntrl:] #控制字符 [:print:] #非空字符（包括空格） [:punct:] #标点符号 [:space:] #所有空白字符（新行，空格，制表符） [:upper:] #大写字符 [:xdigit:] #十六进制数字（0-9，a-f，A-F）","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://www.zhangqifei.top/tags/命令/"}]},{"title":"linux命令-echo","slug":"linux/linux命令-echo","date":"2016-07-06T04:12:42.000Z","updated":"2018-04-22T09:29:32.654Z","comments":true,"path":"2016/07/06/linux/linux命令-echo/","link":"","permalink":"https://www.zhangqifei.top/2016/07/06/linux/linux命令-echo/","excerpt":"","text":"echo命令向文件中写入内容，例如:使用echo指令覆盖文件内容，使用echo指令向文件追加内容，使用echo指令往文件中追加制表符。 echo向文件中输出内容的基本方法是使用IO重定向指令”&gt;”，默认情况下echo输出到标准输出中，使用”&gt;”指令可重定向输出到文件中。 123456789101112131415161718192021用法：echo [短选项]... [字符串]... 或：echo 长选项 将 string 回显到标准输出。 -n 不尾随换行符 -e 启用解释反斜杠的转义功能 -E 禁用解释反斜杠的转义功能(默认) --help 显示此帮助信息并退出 --version 显示版本信息并退出 若-e 可用，则以下序列即可识别： \\\\ 反斜杠 \\a 响铃声 \\b 会删除字符间的所有空格 * \\c 不再产生新的输出 \\e 转义符 \\f 换页 \\n 新行 * \\r 回车 \\t 水平制表符 \\v 竖直制表符 \\0NNN 字节数以八进制数 NNN (1至3位)表示 \\xHH 字节数以十六进制数 HH (1至2位)表示 使用’\\b’选项 ‘-e’后带上’\\b’会删除字符间的所有空格。注意： Linux中的选项’-e’扮演了转义字符反斜线的翻译器。 12[root@centos7 ~]# echo -e &quot;Tecmint \\bis \\ba \\bcommunity \\bof \\bLinux \\bNerds&quot; TecmintisacommunityofLinuxNerds 使用’\\n’选项 “-e”后面的带上’\\n’行会在遇到的地方作为新的一行 12345678[root@centos7 ~]# echo -e &quot;Tecmint \\nis \\na \\ncommunity \\nof \\nLinux \\nNerds&quot; Tecmint is a community of Linux Nerds 使用’\\t’选项 ‘-e’后面跟上’\\t’会在空格间加上水平制表符。 12[root@centos7 ~]# echo -e &quot;Tecmint \\tis \\ta \\tcommunity \\tof \\tLinux \\tNerds&quot; Tecmint is a community of Linux Nerds 也可以同时使用换行‘\\n‘与水平制表符‘\\t‘123456789[root@centos7 ~]# echo -e &quot;\\n\\tTecmint \\n\\tis \\n\\ta \\n\\tcommunity \\n\\tof \\n\\tLinux \\n\\tNerds&quot; Tecmint is a community of Linux Nerds 使用’\\v’选项 ‘-e’后面跟上’\\v’会加上垂直制表符。 123456789[root@centos7 ~]# echo -e &quot;\\vTecmint \\vis \\va \\vcommunity \\vof \\vLinux \\vNerds&quot; Tecmint is a community of Linux Nerds 也可以同时使用换行’\\n’与垂直制表符’\\v’ 注意： 你可以按照你的需求连续使用两个或者多个垂直制表符，水平制表符与换行符。 12345678910111213141516[root@centos7 ~]# echo -e &quot;\\n\\vTecmint \\n\\vis \\n\\va \\n\\vcommunity \\n\\vof \\n\\vLinux \\n\\vNerds&quot; Tecmint is a community of Linux Nerds 使用’\\r’选项 ‘-e’后面跟上‘\\r’来指定输出中的回车符。（LCTT 译注：会覆写行开头的字符） 123[root@centos7 ~]# echo -e &quot;Tecmint \\ris a community of Linux Nerds&quot; is a community of Linux Nerds 使用’\\c’选项 ‘-e’后面跟上’\\c’会抑制输出后面的字符并且最后不会换新行。 12[root@centos7 ~]# echo -e &quot;Tecmint is a community \\cof Linux Nerds&quot; Tecmint is a community [root@centos7 ~]# ‘-n’会在echo完后不会输出新行12[root@centos7 ~]# echo -n &quot;Tecmint is a community of Linux Nerds&quot; Tecmint is a community of Linux Nerds[root@centos7 ~]# 使用’\\a’选项 ‘-e’后面跟上’\\a’选项会听到声音警告。 12[root@centos7 ~]# echo -e &quot;Tecmint is a community of \\aLinux Nerds&quot; Tecmint is a community of Linux Nerds 注意： 在你开始前，请先检查你的音量设置。 使用echo命令打印所有的文件和文件夹（ls命令的替代） 比如，让我们假设你想要打印所有的’.sh’文件，使用下面的命令。 1234[root@centos7 app]#echo *.shbackup73.sh f1.sh hello.sh scp73.sh systeminfo.sh[root@centos7 ~]# echo * //打印所有与ls相当backup73.sh etc f1.sh hello.sh scp73.sh systeminfo.sh wang","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://www.zhangqifei.top/tags/命令/"}]},{"title":"ASCII对照表","slug":"工具/ASCII对照表","date":"2016-07-06T01:41:22.000Z","updated":"2018-04-23T07:11:04.469Z","comments":true,"path":"2016/07/06/工具/ASCII对照表/","link":"","permalink":"https://www.zhangqifei.top/2016/07/06/工具/ASCII对照表/","excerpt":"","text":"ASCII（American Standard Code for Information Interchange，美国信息交换标准代码）是基于拉丁字母的一套电脑编码系统，主要用于显示现代英语和其他西欧语言。它是现今最通用的单字节编码系统，并等同于国际标准ISO/IEC 646。请注意，ASCII是American Standard Code for Information Interchange缩写，而不是ASCⅡ(罗马数字2)，有很多人在这个地方产生误解。 ASCII值控制字符ASCII值控制字符ASCII值控制字符ASCII值控制字符0NUT32(space)64@96、1SOH33!65A97a2STX34“66B98b3ETX35#67C99c4EOT36$68D100d5ENQ37%69E101e6ACK38&amp;70F102f7BEL39,71G103g8BS40(72H104h9HT41)73I105i10LF42*74J106j11VT43+75K107k12FF44,76L108l13CR45-77M109m14SO46.78N110n15SI47/79O111o16DLE48080P112p17DCI49181Q113q18DC250282R114r19DC351383S115s20DC452484T116t21NAK53585U117u22SYN54686V118v23TB55787W119w24CAN56888X120x25EM57989Y121y26SUB58:90Z122z27ESC59;91[123{28FS60&lt;92/124|29GS61=93]125}30RS62&gt;94^126`31US63?95_127DEL特殊字符解释NUL空VT 垂直制表SYN 空转同步STX 正文开始CR 回车CAN 作废ETX 正文结束SO 移位输出EM 纸尽EOY 传输结束SI 移位输入SUB 换置ENQ 询问字符DLE 空格ESC 换码ACK 承认DC1 设备控制1FS 文字分隔符BEL 报警DC2 设备控制2GS 组分隔符BS 退一格DC3 设备控制3RS 记录分隔符HT 横向列表DC4 设备控制4US 单元分隔符LF 换行NAK 否定DEL 删除","categories":[{"name":"工具","slug":"工具","permalink":"https://www.zhangqifei.top/categories/工具/"}],"tags":[{"name":"ASCII","slug":"ASCII","permalink":"https://www.zhangqifei.top/tags/ASCII/"}]},{"title":"linux命令-cat","slug":"linux/linux命令-cat","date":"2016-07-06T01:32:42.000Z","updated":"2018-04-22T09:29:32.718Z","comments":true,"path":"2016/07/06/linux/linux命令-cat/","link":"","permalink":"https://www.zhangqifei.top/2016/07/06/linux/linux命令-cat/","excerpt":"","text":"cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。语法格式 cat [-AbeEnstTuv] [–help] [–version] fileName 参数说明：12345678910-n 或 --number：由 1 开始对所有输出的行数编号。-b 或 --number-nonblank：和 -n : 相似，只不过对于空白行不编号。-s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。-v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。-E 或 --show-ends : 在每行结束处显示 $。-T 或 --show-tabs: 将 TAB 字符显示为 ^I。-e : 等价于 -vE。-A, --show-all：等价于 -vET。-e：等价于&quot;-vE&quot;选项；-t：等价于&quot;-vT&quot;选项； 实例1：把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2 实例2：把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：cat -b textfile1 textfile2 &gt;&gt; textfile3 实例3：清空 /etc/test.txt 文档内容：cat /dev/null &gt; /etc/test.txt 实例4：cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：cat /dev/fd0 &gt; OUTFILE 实例5：相反的，如果想把 image file 写到软盘，输入：cat IMG_FILE &gt; /dev/fd0 tac (反向列示)命令：tac log.txt输出：123456789101112[root@localhost ~]# cat log.txt 12345[root@localhost ~]# tac log.txt 54321 说明：tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat 是由第一行到最后一行连续显示在萤幕上，而 tac 则是由最后一行到第一行反向在萤幕上显示出来！","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://www.zhangqifei.top/tags/命令/"}]},{"title":"linux命令-bc","slug":"linux/linux命令-bc","date":"2016-07-06T01:12:42.000Z","updated":"2018-04-22T09:29:33.238Z","comments":true,"path":"2016/07/06/linux/linux命令-bc/","link":"","permalink":"https://www.zhangqifei.top/2016/07/06/linux/linux命令-bc/","excerpt":"","text":"语法 bc (选项) (参数) 选项值123456-i：强制进入交互式模式；-l：定义使用的标准数学库； -w：对POSIX bc的扩展给出警告信息；-q：不打印正常的GNU bc环境信息；-v：显示指令版本信息；-h：显示指令的帮助信息。 实例1：命令：1234567[root@centos7 ~]#bcbc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty&apos;. 15*230 //输入 quit 退出。 实例2：通过管道符:命令：[root@centos7 ~]#echo &quot;15+5&quot; | bc //20 实例3：scale=2 设小数位，2 代表保留两位:命令：[root@centos7 ~]#echo &#39;scale=2;(2.777-1.44444)/1&#39; |bc //1.33 进制转换bc 除了 scale 来设定小数位之外，还有 ibase 和 obase 来其它进制的运算: 把十进制11000000;转换为二进制192命令：12[root@centos7 ~]#abc=11000000 [root@centos7 ~]#echo &quot;obase=10;ibase=2;$abc&quot; | bc //192 把十进制11000000;转换为二进制192命令：[root@centos7 ~]#echo &quot;obase=2;192&quot; |bc //11000000 实例4、计算平方和平方根：命令：12[root@centos7 ~]#echo &quot;10^10&quot; | bc //10000000000[root@centos7 ~]#echo &quot;sqrt(100)&quot; | bc //10","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://www.zhangqifei.top/tags/命令/"}]},{"title":"linux命令-test","slug":"linux/linux命令-test","date":"2016-07-06T00:42:42.000Z","updated":"2018-04-22T09:29:32.910Z","comments":true,"path":"2016/07/06/linux/linux命令-test/","link":"","permalink":"https://www.zhangqifei.top/2016/07/06/linux/linux命令-test/","excerpt":"","text":"test命令是shell环境中测试条件表达式的实用工具。 语法： test(选项) 选项 选项 :12345678910111213141516-b&lt;文件&gt;：如果文件为一个块特殊文件，则为真；-c&lt;文件&gt;：如果文件为一个字符特殊文件，则为真；-d&lt;文件&gt;：如果文件为一个目录，则为真；-e&lt;文件&gt;：如果文件存在，则为真；-f&lt;文件&gt;：如果文件为一个普通文件，则为真；-g&lt;文件&gt;：如果设置了文件的SGID位，则为真；-G&lt;文件&gt;：如果文件存在且归该组所有，则为真；-k&lt;文件&gt;：如果设置了文件的粘着位，则为真；-O&lt;文件&gt;：如果文件存在并且归该用户所有，则为真；-p&lt;文件&gt;：如果文件为一个命名管道，则为真；-r&lt;文件&gt;：如果文件可读，则为真；-s&lt;文件&gt;：如果文件的长度不为零，则为真；-S&lt;文件&gt;：如果文件为一个套接字特殊文件，则为真；-u&lt;文件&gt;：如果设置了文件的SUID位，则为真；-w&lt;文件&gt;：如果文件可写，则为真；-x&lt;文件&gt;：如果文件可执行，则为真。 实例:linux中shell编程中的test常见用法： 判断表达式12345if test #表达式为真if test ! #表达式为假 test 表达式1 –a 表达式2 #两个表达式都为真 test 表达式1 –o 表达式2 #两个表达式有一个为真 test 表达式1 ! 表达式2 #条件求反 判断字符串1234test –n 字符串 #字符串的长度非零 test –z 字符串 #字符串的长度是否为零 test 字符串1＝字符串2 #字符串是否相等，若相等返回true test 字符串1!＝字符串2 #字符串是否不等，若不等反悔false 判断整数123456test 整数1 -eq 整数2 #整数相等 test 整数1 -ge 整数2 #整数1大于等于整数2 test 整数1 -gt 整数2 #整数1大于整数2 test 整数1 -le 整数2 #整数1小于等于整数2 test 整数1 -lt 整数2 #整数1小于整数2 test 整数1 -ne 整数2 #整数1不等于整数2 判断文件12345678910111213141516171819202122test File1 –ef File2 两个文件是否为同一个文件，可用于硬连接。主要判断两个文件是否指向同一个inode。 test File1 –nt File2 判断文件1是否比文件2新 test File1 –ot File2 判断文件1比是否文件2旧 test –b file #文件是否块设备文件 test –c File #文件并且是字符设备文件 test –d File #文件并且是目录 test –e File #文件是否存在 （常用） test –f File #文件是否为正规文件 （常用） test –g File #文件是否是设置了组id test –G File #文件属于的有效组ID test –h File #文件是否是一个符号链接（同-L） test –k File#文件是否设置了Sticky bit位 test –b File #文件存在并且是块设备文件 test –L File #文件是否是一个符号链接（同-h） test –o File #文件的属于有效用户ID test –p File #文件是一个命名管道 test –r File #文件是否可读 test –s File #文件是否是非空白文件 test –t FD #文件描述符是在一个终端打开的 test –u File #文件存在并且设置了它的set-user-id位 test –w File #文件是否存在并可写 test –x File #文件属否存在并可执行","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://www.zhangqifei.top/tags/命令/"}]},{"title":"CentOS（6、7）修改主机名(hostname)","slug":"linux/CentOS（6、7）修改主机名(hostname)","date":"2016-06-06T01:41:22.000Z","updated":"2018-04-22T09:29:33.283Z","comments":true,"path":"2016/06/06/linux/CentOS（6、7）修改主机名(hostname)/","link":"","permalink":"https://www.zhangqifei.top/2016/06/06/linux/CentOS（6、7）修改主机名(hostname)/","excerpt":"","text":"centos6需要修改两处：一处是/etc/sysconfig/network，另一处是/etc/hosts，只修改任一处会导致系统启动异常。首先切换到root用户。 /etc/sysconfig/network打开该文件，里面有一行 `HOSTNAME=localhost.localdomain，修改 localhost.localdomain 为你的主机名。 /etc/hosts打开该文件，会有一行 127.0.0.1 localhost.localdomain localhost其中 127.0.0.1 是本地环路地址， localhost.localdomain 是主机名(hostname)，也就是你待修改的。 将上面两个文件修改完后，并不能立刻生效。如果要立刻生效的话，可以用 hostname your-hostname 作临时修改(或者修改完之后执行exec bash立即改变)，它只是临时地修改主机名，查看主机名uname -n系统重启后会恢复原样的。 但修改上面两个文件是永久的，重启系统会得到新的主机名。最后，重启后查看主机名 uname -n 。 centos7临时生效123[root@centos7 ~]# hostname 132[root@centos7 ~]# hostname132 永久生效（不会立刻修改，需重启）12[root@centos7 ~]# hostnamectl set-hostname centos7(或者修改完之后执行`exec bash`立即改变)，","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"CentOS","slug":"CentOS","permalink":"https://www.zhangqifei.top/tags/CentOS/"}]},{"title":"ab命令压力测试","slug":"linux/ab命令压力测试","date":"2016-06-06T01:41:22.000Z","updated":"2018-04-22T09:29:32.756Z","comments":true,"path":"2016/06/06/linux/ab命令压力测试/","link":"","permalink":"https://www.zhangqifei.top/2016/06/06/linux/ab命令压力测试/","excerpt":"","text":"网站性能压力测试是服务器网站性能调优过程中必不可缺少的一环。只有让服务器处在高压情况下，才能真正体现出软件、硬件等各种设置不当所暴露出的问题。 性能测试工具目前最常见的有以下几种：ab、http_load、webbench、siege。今天我们专门来介绍ab。 ab是apache自带的压力测试工具。ab非常实用，它不仅可以对apache服务器进行网站访问压力测试，也可以对或其它类型的服务器进行压力测试。比如nginx、tomcat、IIS等。 官方参数文档 一、ab的原理ab是apachebench命令的缩写。 ab的原理：ab命令会创建多个并发访问线程，模拟多个访问者同时对某一URL地址进行访问。它的测试目标是基于URL的，因此，它既可以用来测试apache的负载压力，也可以测试nginx、lighthttp、tomcat、IIS等其它Web服务器的压力。 ab命令对发出负载的计算机要求很低，它既不会占用很高CPU，也不会占用很多内存。但却会给目标服务器造成巨大的负载，其原理类似CC攻击。自己测试使用也需要注意，否则一次上太多的负载。可能造成目标服务器资源耗完，严重时甚至导致死机。 二、ab的安装ab的安装非常简单，如果是源码安装apache的话，那就更简单了。apache安装完毕后ab命令存放在apache安装目录的bin目录下。如下：1/usr/local/apache2/bin 如果apache 是通过yum的RPM包方式安装的话，ab命令默认存放在/usr/bin目录下。如下：1which ab 注意：如果不想安装apache但是又想使用ab命令的话，我们可以直接安装apache的工具包httpd-tools。如下：1yum -y install httpd-tools 查看ab是否安装成功，可以切换到上述目录下，使用ab –V命令进行检测。如下：1ab -V 如果ab安装成功，通过ab –V命令则会显示ab的相迎版本，如上图示。 注意以上是在linux平台下进行安装的，如果是windows平台下，我们也可以下载对应的apache版本进行安装。 目前apache最新版2.4.10，apache官网已经没有windows下载的版本。 三、ab参数说明有关ab命令的使用，我们可以通过帮助命令进行查看。如下：1ab --help 下面我们对这些参数，进行相关说明。如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647-n 在测试会话中所执行的请求个数。默认时，仅执行一个请求。-c 一次产生的请求个数。默认是一次一个。-t 测试所进行的最大秒数。其内部隐含值是-n 50000，它可以使对服务器的测试限制在一个固定的总时间以内。默认时，没有时间限制。-p 包含了需要POST的数据的文件。-P 对一个中转代理提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即, 是否发送了401认证需求代码)，此字符串都会被发送。-T POST数据所使用的Content-type头信息。-v 设置显示信息的详细程度-4或更大值会显示头信息，3或更大值可以显示响应代码(404,200等),2或更大值可以显示警告和其他信息。-V 显示版本号并退出。-w 以HTML表的格式输出结果。默认时，它是白色背景的两列宽度的一张表。-i 执行HEAD请求，而不是GET。-x 设置&lt;table&gt;属性的字符串。-X 对请求使用代理服务器。-y 设置&lt;tr&gt;属性的字符串。-z 设置&lt;td&gt;属性的字符串。-C 对请求附加一个Cookie:行。其典型形式是name=value的一个参数对，此参数可以重复。-H 对请求附加额外的头信息。此参数的典型形式是一个有效的头信息行，其中包含了以冒号分隔的字段和值的对(如,&quot;Accept-Encoding:zip/zop;8bit&quot;)。-A 对服务器提供BASIC认证信任。用户名和密码由一个:隔开，并以base64编码形式发送。无论服务器是否需要(即,是否发送了401认证需求代码)，此字符串都会被发送。-h 显示使用方法。-d 不显示&quot;percentage served within XX [ms] table&quot;的消息(为以前的版本提供支持)。-e 产生一个以逗号分隔的(CSV)文件，其中包含了处理每个相应百分比的请求所需要(从1%到100%)的相应百分比的(以微妙为单位)时间。由于这种格式已经“二进制化”，所以比&apos;gnuplot&apos;格式更有用。-g 把所有测试结果写入一个&apos;gnuplot&apos;或者TSV(以Tab分隔的)文件。此文件可以方便地导入到Gnuplot,IDL,Mathematica,Igor甚至Excel中。其中的第一行为标题。-i 执行HEAD请求，而不是GET。-k 启用HTTP KeepAlive功能，即在一个HTTP会话中执行多个请求。默认时，不启用KeepAlive功能。-q 如果处理的请求数大于150，ab每处理大约10%或者100个请求时，会在stderr输出一个进度计数。此-q标记可以抑制这些信息。 四、ab性能指标在进行性能测试过程中有几个指标比较重要： 1、吞吐率（Requests per second） 服务器并发处理能力的量化描述，单位是reqs/s，指的是在某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。 记住：吞吐率是基于并发用户数的。这句话代表了两个含义： a、吞吐率和并发用户数相关 b、不同的并发用户数下，吞吐率一般是不同的 计算公式：总请求数/处理完成这些请求数所花费的时间，即Request per second=Complete requests/Time taken for tests必须要说明的是，这个数值表示当前机器的整体性能，值越大越好。 2、并发连接数（The number of concurrent connections） 并发连接数指的是某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。 3、并发用户数（Concurrency Level） 要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。在HTTP/1.1下，IE7支持两个并发连接，IE8支持6个并发连接，FireFox3支持4个并发连接，所以相应的，我们的并发用户数就得除以这个基数。 4、用户平均请求等待时间（Time per request） 计算公式：处理完成所有请求数所花费的时间/（总请求数/并发用户数），即：Time per request=Time taken for tests/（Complete requests/Concurrency Level） 5、服务器平均请求等待时间（Time per request:across all concurrent requests） 计算公式：处理完成所有请求数所花费的时间/总请求数，即：Time taken for/testsComplete requests可以看到，它是吞吐率的倒数。 同时，它也等于用户平均请求等待时间/并发用户数，即Time per request/Concurrency Level 五、ab实际使用123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@centos7 ~]#ab -c 10 -n 100 http://a.ilanni.com/index.php -c 10表示并发用户数为10 -n 100表示请求总数为100 http://a.ilanni.com/index.php表示请求的目标URL 这行表示同时处理100个请求并运行10次index.php文件。[root@centos7 ~]#ab -c 10 -n 100 http://a.ilanni.com/index.phpBenchmarking 47.93.96.25 (be patient).....doneServer Software: Apache/2.4.29 ##apache版本 Server Hostname: ip地址 ##请求的机子 Server Port: 80 ##请求端口Document Path: index.phpDocument Length: 18483 bytes ##页面长度Concurrency Level: 10 ##并发数Time taken for tests: 25.343 seconds ##共使用了多少时间Complete requests: 100 ##请求数Failed requests: 11 ##失败请求 (Connect: 0, Receive: 0, Length: 11, Exceptions: 0)Total transferred: 1873511 bytes ##总共传输字节数，包含http的头信息等HTML transferred: 1848311 bytes ##html字节数，实际的页面传递字节数Requests per second: 3.95 [#/sec] (mean) ##每秒多少请求，这个是非常重要的参数数值，服务器的吞吐量Time per request: 2534.265 [ms] (mean) ##用户平均请求等待时间Time per request: 253.426 [ms] (mean, across all concurrent requests) ##服务器平均处理时间，Transfer rate: 72.19 [Kbytes/sec] received ##每秒获取的数据长度Connection Times (ms) min mean[+/-sd] median maxConnect: 0 8 3.9 10 13Processing: 1222 2453 322.6 2520 3436Waiting: 1175 2385 320.4 2452 3372Total: 1222 2461 322.5 2528 3444Percentage of the requests served within a certain time (ms) 50% 2528 ## 50%的请求在25ms内返回 66% 2534 ## 60%的请求在26ms内返回 75% 2538 80% 2539 90% 2545 95% 2556 98% 3395 99% 3444 100% 3444 (longest request) apache的ab工具也算是一种ddos攻击工具nginx吞吐率就是要比apache高。根据前面我们提到的性能指标Requests per second吞吐率越高，服务器性能越好。","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"命令","slug":"命令","permalink":"https://www.zhangqifei.top/tags/命令/"}]},{"title":"apache2.4版本与2.2版本的差异","slug":"linux/apache2.4版本与2.2版本的差异","date":"2016-05-06T01:41:22.000Z","updated":"2018-04-22T09:29:32.872Z","comments":true,"path":"2016/05/06/linux/apache2.4版本与2.2版本的差异/","link":"","permalink":"https://www.zhangqifei.top/2016/05/06/linux/apache2.4版本与2.2版本的差异/","excerpt":"","text":"在2.2版本中eventMPM还处于测试阶段，而2.4版本event已经可以正常使用了 2.4版本的3个MPM工作模式使用的是DSO动态模块来实现的，而2.2则是直接编译成了静态模块 2.4版本切换MPM工作模式是在/etc/httpd/conf.modules.d/00-mpm.conf文件中实现的，而2.2版本则是在/etc/sysconfig/httpd文件中进行的切换 2.4版本mod_userdir.c模块配置文件默认存放在/etc/httpd/conf.d/userdir.conf 中 ，而2.2版本则是在主配置文件/etc/httpd/conf/httpd.conf文件中 2.4版本在对目录进行访问控制设置时使用的语句如下： 基于IP的访问控制:123无明确授权的目录，默认拒绝允许所有主机访问：Require all granted拒绝所有主机访问：Require all denied 控制特定的IP访问：12Require ip IPADDR：授权指定来源的IP访问Require not ip IPADDR：拒绝特定的IP访问 控制特定的主机访问：12345Require host HOSTNAME：授权特定主机访问Require not host HOSTNAME：拒绝HOSTNAME：FQDN：特定主机domin.tld：指定域名下的所有主机 不能有失败，至少有一个成功匹配才成功，即失败优先1234&lt;RequireAll&gt;Require all grantedRequire not ip 172.16.1.1 拒绝特定IP&lt;/RequireAll&gt; 多个语句有一个成功，则成功，即成功优先1234&lt;RequireAny&gt;Require all deniedrequire ip 172.16.1.1 允许特定IP&lt;/RequireAny&gt; 2.2版本在对目录进行访问控制设置时使用的语句如下： order和allow、deny放在directory, .htaccess中，order：定义生效次序；写在后面的表示默认法则12Order allow,denyOrder deny,allow Allow from和Deny from：定义客户端地址客户端地址：12345IP网络: 172.16172.16.0.0172.16.0.0/16172.16.0.0/255.255.0.0 实例：12345678910&lt;files &quot;*.txt&quot;&gt;order deny,allowdeny from 172.16. 100.100allow from 172.16&lt;/files&gt;&lt;files &quot;*.txt&quot;&gt;order allow,denydeny from 172.16.100.100allow from 172.16&lt;/files&gt; 注意：2.2版本和2.4版本对目录权限的控制两者语句不通用，用错不生效 6、基于FQDN的虚拟主机配置中，2.4版本不需要“NameVirtualHost”标签头，而2.2版本的必须加。 7、2.4版本的模板加载配置默认存放在/etc/httpd/conf.modules.d/下，而2.2版本则全部卸载了主配置文件/etc/httpd/conf/httpd.conf内","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"apache","slug":"apache","permalink":"https://www.zhangqifei.top/tags/apache/"}]},{"title":"Git 常用命令大全，赶紧收藏吧！！","slug":"工具/Git 常用命令大全，赶紧收藏吧！！","date":"2016-04-06T01:41:22.000Z","updated":"2018-04-23T07:11:04.499Z","comments":true,"path":"2016/04/06/工具/Git 常用命令大全，赶紧收藏吧！！/","link":"","permalink":"https://www.zhangqifei.top/2016/04/06/工具/Git 常用命令大全，赶紧收藏吧！！/","excerpt":"","text":"常用到四个专业名词： Workspace：工作区 Index / Stage：暂存区 Repository：仓库区（或本地仓库） Remote：远程仓库 一、新建代码库12345678# 在当前目录新建一个Git代码库$ git init# 新建一个目录，将其初始化为Git代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone[url] 二、配置Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。123456789# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件1234567891011121314151617181920# 添加指定文件到暂存区$ git add [file1] [file2]...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .# 添加每个变化前，都会要求确认 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2]...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交1234567891011121314151617# 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a# 提交时显示所有diff信息$ git commit -v# 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message]# 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支123456789101112131415161718192021222324252627282930313233343536373839404142# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 新建一个分支，指向指定commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签1234567891011121314151617181920212223242526# 列出所有tag$ git tag# 新建一个tag在当前commit$ git tag [tag]# 新建一个tag在指定commit$ git tag [tag] [commit]# 删除本地tag$ git tag -d [tag]# 删除远程tag$ git push origin :refs/tags/[tagName]# 查看tag信息$ git show [tag]# 提交指定tag$ git push [remote] [tag]# 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次diff$ git log -p [file]# 显示过去5次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个commit的差异$ git diff --cached [file]# 显示工作区与当前分支最新commit之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog 八、远程同步1234567891011121314151617181920212223# 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库，并命名$ git remote add [shortname] [url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销123456789101112131415161718192021222324252627282930# 恢复暂存区的指定文件到工作区$ git checkout [file]# 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file]# 恢复暂存区的所有文件到工作区$ git checkout .# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file]# 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit]# 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个commit，用来撤销指定commit 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit]# 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop 十、其他12# 生成一个可供发布的压缩包$ git archive","categories":[{"name":"工具","slug":"工具","permalink":"https://www.zhangqifei.top/categories/工具/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://www.zhangqifei.top/tags/Git/"}]},{"title":"计算机专业术语-socket","slug":"linux/计算机专业术语-socket","date":"2016-04-04T01:41:22.000Z","updated":"2018-04-22T09:29:33.034Z","comments":true,"path":"2016/04/04/linux/计算机专业术语-socket/","link":"","permalink":"https://www.zhangqifei.top/2016/04/04/linux/计算机专业术语-socket/","excerpt":"","text":"解释 网络上的两个程序通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。 建立网络通信连接至少要一对端口号(socket)。socket本质是编程接口(API)，对TCP/IP的封装，TCP/IP也要提供可供程序员做网络开发所用的接口，这就是Socket编程接口；HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。 Socket的英文原义是“孔”或“插座”。作为BSD UNIX的进程通信机制，取后一种意思。通常也称作”套接字”，用于描述IP地址和端口，是一个通信链的句柄，可以用来实现不同虚拟机或不同计算机之间的通信。在Internet上的主机一般运行了多个服务软件，同时提供几种服务。每种服务都打开一个Socket，并绑定到一个端口上，不同的端口对应于不同的服务。Socket正如其英文原义那样，像一个多孔插座。一台主机犹如布满各种插座的房间，每个插座有一个编号，有的插座提供220伏交流电， 有的提供110伏交流电，有的则提供有线电视节目。 客户软件将插头插到不同编号的插座，就可以得到不同的服务。 客户/服务器程序连接过程 根据连接启动的方式以及本地套接字要连接的目标，套接字之间的连接过程可以分为三个步骤：服务器监听，客户端请求，连接确认。（1）服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态。（2）客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。（3）连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了。而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。 Socket:套接字，进程间通信IPC的一种实现，允许位于不同主机（或同一主机）上不同进程之间进行通信和数据交换，SocketAPI出现于1983年，4.2 BSD实现 Socket API：封装了内核中所提供的socket通信相关的系统调用 Socket Domain：根据其所使用的地址 AF_INET：Address Family，IPv4 AF_INET6：IPv6 AF_UNIX：同一主机上不同进程之间通信时使用 Socket Type：根据使用的传输层协议 SOCK_STREAM：流，tcp套接字，可靠地传递、面向连接 SOCK_DGRAM：数据报，udp套接字，不可靠地传递、无连接 SOCK_RAW: 裸套接字,无须tcp或tdp,APP直接通过IP包通信 示例：12345在建立通信连接的每一端，进程间的传输要有两个标志： IP地址和端口号，合称为套接字地址socket address 客户机套接字地址定义了一个唯一的客户进程 服务器套接字地址定义了一个唯一的服务器进程 套接字地址 172.18.0.18:80 套接字相关的系统调用： 名字 含义 名字 含义 socket() 创建一个套接字 bind() 绑定IP和端口 listen() 监听 accept() 接收请求 connect() 请求连接建立 write() 发送 read() 接收 close() 关闭连接 Socket通信过程示例：下面用一段简单Python程序具体实现下： 服务器端tcpserver.py1234567891011121314151617181920#!/usr/bin/pythonimport socket HOST=&apos;172.18.2.232&apos;PORT=9527BUFFER=4096sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)sock.bind((HOST,PORT))sock.listen(3)print(&apos;tcpServer listen at: %s:%s\\n\\r&apos; %(HOST,PORT))while True: client_sock,client_addr=sock.accept() print(&apos;%s:%s connect&apos; %client_addr) while True: recv=client_sock.recv(BUFFER) if not recv: client_sock.close() break print(&apos;[Client %s:%s said]:%s&apos; %(client_addr[0],client_addr[1],recv)) client_sock.send(&apos;tcpServer has received your message&apos;)sock.close() 客户端tcpclient.py1234567891011#!/usr/bin/pythonimport socketHOST=&apos;172.18.2.232&apos;PORT=9527BUFFER=4096sock=socket.socket(socket.AF_INET,socket.SOCK_STREAM)sock.connect((HOST,PORT))sock.send(&apos;hello, tcpServer!&apos;)recv=sock.recv(BUFFER)print(&apos;[tcpServer said]: %s&apos; % recv)sock.close() 执行tcpserver.py12345[root@centos7 ~]#python tcpserver.py tcpServer listen at: 172.18.2.232:9527172.18.2.232:46004 connect[Client 172.18.2.232:46004 said]:hello, tcpServer! 执行tcpclient.py12[fei@centos7 ~]$python tcpclient.py [tcpServer said]: tcpServer has received your message","categories":[{"name":"术语","slug":"术语","permalink":"https://www.zhangqifei.top/categories/术语/"}],"tags":[]},{"title":"HTTPS和HTTP的区别？","slug":"随笔/HTTPS和HTTP的区别？","date":"2016-04-04T01:41:22.000Z","updated":"2018-04-23T07:12:14.291Z","comments":true,"path":"2016/04/04/随笔/HTTPS和HTTP的区别？/","link":"","permalink":"https://www.zhangqifei.top/2016/04/04/随笔/HTTPS和HTTP的区别？/","excerpt":"","text":"什么是 HTTPS?HTTPS (基于安全套接字层的超文本传输协议 或者是 HTTP over SSL) 是一个 Netscape 开发的 Web 协议。 你也可以说：HTTPS = HTTP + SSL HTTPS 在 HTTP 应用层的基础上使用安全套接字层作为子层。 为什么需要 HTTPS ？超文本传输协议 (HTTP) 是一个用来通过互联网传输和接收信息的协议。HTTP 使用请求/响应的过程，因此信息可在服务器间快速、轻松而且精确的进行传输。当你访问 Web 页面的时候你就是在使用 HTTP 协议，但 HTTP 是不安全的，可以轻松对窃听你跟 Web 服务器之间的数据传输。 在很多情况下，客户和服务器之间传输的是敏感歇息，需要防止未经授权的访问。为了满足这个要求，网景公司(Netscape)推出了HTTPS，也就是基于安全套接字层的 HTTP 协议。 HTTP 和 HTTPS 的相同点大多数情况下，HTTP 和 HTTPS 是相同的，因为都是采用同一个基础的协议，作为 HTTP 或 HTTPS 客户端——浏览器，设立一个连接到 Web 服务器指定的端口。当服务器接收到请求，它会返回一个状态码以及消息，这个回应可能是请求信息、或者指示某个错误发送的错误信息。系统使用统一资源定位器 URI 模式，因此资源可以被唯一指定。 而 HTTPS 和 HTTP唯一不同的只是一个协议头(https)的说明，其他都是一样的。 HTTP 和 HTTPS 的不同之处 HTTP 的 URL 以http://开头，而 HTTPS 的 URL 以 https:// 开头 HTTP 是不安全的，而 HTTPS 是安全的 HTTP 标准端口是 80 ，而 HTTPS 的标准端口是443 在 OSI 网络模型中，HTTP 工作于应用层，而 HTTPS 工作在传输层 HTTP 无需加密，而 HTTPS 对传输的数据进行加密 HTTP 无需证书，而 HTTPS 需要认证证书 HTTPS 如何工作?使用 HTTPS 连接时，服务器要求有公钥和签名的证书。 当使用 https 连接，服务器响应初始连接，并提供它所支持的加密方法。作为回应，客户端选择一个连接方法，并且客户端和服务器端交换证书验证彼此身份。完成之后，在确保使用相同密钥的情况下传输加密信息，然后关闭连接。为了提供 https 连接支持，服务器必须有一个公钥证书，该证书包含经过证书机构认证的密钥信息，大部分证书都是通过第三方机构授权的，以保证证书是安全的。 换句话说，HTTPS 跟 HTTP 一样，只不过增加了 SSL。 HTTP 包含如下动作： 浏览器打开一个 TCP 连接 浏览器发送 HTTP 请求到服务器端 服务器发送 HTTP 回应信息到浏览器 TCP 连接关闭 SSL 包含如下动作： 验证服务器端 允许客户端和服务器端选择加密算法和密码，确保双方都支持 验证客户端(可选) 使用公钥加密技术来生成共享加密数据 创建一个加密的 SSL 连接 基于该 SSL 连接传递 HTTP 请求 什么时候该使用 HTTPS?银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应该使用 HTTPS，例如： 支付宝: https://www.alipay.com/淘宝网: https://www.taobao.com/ 如果某个网站要求你填写信用卡信息，首先你要检查该网页是否使用 https 加密连接，如果没有，那么请不要输入任何敏感信息如信用卡号。 浏览器集成 多数浏览器在收到一个无效证书的时候都会显示警告信息，而一些老的浏览器会弹出对话框让用户选择是否继续浏览。新的浏览器一般在整个窗口显示横幅的警告信息，同时在地址栏上显示该网站的安全信息。如果网站中包含加密和非加密的混合内容，多数浏览器会提示警告信息。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.zhangqifei.top/categories/随笔/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://www.zhangqifei.top/tags/HTTP/"}]},{"title":"免费IP地址查询API接口","slug":"工具/免费IP地址查询API接口","date":"2016-04-04T01:41:22.000Z","updated":"2018-04-23T07:11:04.392Z","comments":true,"path":"2016/04/04/工具/免费IP地址查询API接口/","link":"","permalink":"https://www.zhangqifei.top/2016/04/04/工具/免费IP地址查询API接口/","excerpt":"","text":"快递查询1234567http://www.kuaidi100.com/query?type=quanfengkuaidi&amp;postid=390011492112(PS:快递公司编码：申通&quot;shentong&quot; EMS&quot;ems&quot; 顺丰&quot;shunfeng&quot; 圆通 &quot;yuantong&quot; 中通 &quot;zhongtong&quot; 韵达&quot;yunda&quot; 天天&quot;tiantian&quot; 汇通&quot;huitongkuaidi&quot; 全峰 &quot;quanfengkuaidi&quot; 德邦&quot;debangwuliu&quot;宅急送&quot;zhaijisong&quot;)https://www.kuaidi100.com/frame/index.html 查快递type值 新浪天气:1http://php.weather.sina.com.cn/iframe/index/w_cl.php?code=js&amp;;day=0&amp;city=柏乡&amp;dfc=1&amp;charset=utf-8 百度天气1http://api.map.baidu.com/telematics/v3/weather?location=北京&amp;output=json&amp;ak=11ffd27d38deda622f51c9d314d46b17 手机号查询1https://tcc.taobao.com/cc/json/mobile_tel_segment.htm?tel=18632097220 百度搜索1http://suggestion.baidu.com/su?wd=a&amp;cd=xxx 京东获取单个商品价格接口:1234//ps:商品ID这么获取:http://item.jd.com/954086.htmlhttp://p.3.cn/prices/mgets?skuIds=J_商品ID&amp;type=1 淘宝商品搜索建议:1234https://suggest.taobao.com/sug?code=utf-8&amp;q=救援&amp;callback=cb//ps:callback是回调函数设定 阿里云根据地区名获取经纬度123//参数解释: 纬度,经度 type 001 (100代表道路，010代表POI，001代表门址，111可以同时显示前三项)http://gc.ditu.aliyun.com/geocoding?a=苏州市 简/繁/火星字体转换1http://japi.juhe.cn/charconvert/change.from?text=%E6%88%91%E7%88%B1%E4%BD%A0&amp;type=2&amp;key=0e27c575047e83b407ff9e517cde9c76 笑话接口123456789http://api.laifudao.com/open/xiaohua.jsontitle 标题content 内容poster 笑话插图（不是全部笑话都有插图）url 来源地址 搞笑图片接口12345678910111213http://api.laifudao.com/open/tupian.jsontitle 标题thumburl 大图地址sourceurl 小图地址（宽度为230的图）height 大图高度width 大图宽度url 来源地址 搜索歌曲接口123http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.search.catalogSug&amp;query=海阔天空参数：query = 搜索关键字 搜索歌词接口123http://tingapi.ting.baidu.com/v1/restserver/ting?method=baidu.ting.song.lry&amp;songid=877578参数：songid = 歌曲id 1http://baobab.kaiyanapp.com/api/v1/feed?num=1 开眼APP精选（视频列表地址，包括标题，图片，视频信息)1https://api.miaopai.com/m/cate2_channel.json?cateid=132&amp;extend=1&amp;os=ios&amp;page=1&amp;per=20×tamp=1474441405.7232&amp;type=news&amp;unique_id=6d43a571caf7abe9e29f08d6bf94ee792483732007&amp;uuid=6d43a571caf7abe9e29f08d6bf94ee792483732007&amp;vend=miaopai&amp;version=6.5.7 视频地址1https://api.budejie.com/api/api_open.php?a=list&amp;c=data&amp;type=41&amp;page=1&amp;maxtime=0 视频地址1https://api.budejie.com/api/api_open.php?a=list&amp;c=data&amp;type=29&amp;page=1&amp;maxtime=0 搞笑段子123https://api.jiefu.tv/app2/api/article/list.html?mediaType=1&amp;deviceCode=7EE523B5BBF72B94E3F8D16C3EDF8264&amp;token=&amp;pageNum=1&amp;pageSize=20https://api.budejie.com/api/api_open.php?a=list&amp;c=data&amp;type=10&amp;page=1&amp;maxtime=0 搞笑图片1https://api.budejie.com/api/api_open.php?a=list&amp;c=data&amp;type=31&amp;page=1&amp;maxtime=0 音频列表123http://114.55.128.192:800/article/getpage?cateid=3&amp;siteid=1https://qianming.sinaapp.com/index.php/AndroidApi10/index/cid/qutu/lastId/","categories":[{"name":"工具","slug":"工具","permalink":"https://www.zhangqifei.top/categories/工具/"}],"tags":[{"name":"API接口","slug":"API接口","permalink":"https://www.zhangqifei.top/tags/API接口/"}]},{"title":"linux禁止ping以及开启ping的方法","slug":"linux/linux禁止ping以及开启ping的方法","date":"2016-03-06T01:42:22.000Z","updated":"2018-04-22T09:29:32.967Z","comments":true,"path":"2016/03/06/linux/linux禁止ping以及开启ping的方法/","link":"","permalink":"https://www.zhangqifei.top/2016/03/06/linux/linux禁止ping以及开启ping的方法/","excerpt":"","text":"Linux默认是允许Ping响应的，系统是否允许Ping由2个因素决定的：A、内核参数，B、防火墙，需要2个因素同时允许才能允许Ping，2个因素有任意一个禁Ping就无法Ping。A、内核参数12[root@centos7 ~]# cat /proc/sys/net/ipv4/icmp_echo_ignore_all 0 //（0表示允许，1表示禁止）。 B、防火墙（注：此处的方法的前提是内核配置是默认值，也就是没有禁止Ping）这里以Iptables防火墙为例，其他防火墙操作方法可参考防火墙的官方文档。 允许PING设置1234iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPTiptables -A OUTPUT -p icmp --icmp-type echo-reply -j ACCEPT或者也可以临时停止防火墙操作的。service iptables stop 禁止PING设置 [root@centos7 ~]# iptables -A INPUT -p icmp --icmp-type 8 -s 0/0 -j DROP","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"ping","slug":"ping","permalink":"https://www.zhangqifei.top/tags/ping/"}]},{"title":"Linux服务器时间同步","slug":"linux/Linux服务器时间同步","date":"2016-03-05T01:42:22.000Z","updated":"2018-04-22T09:29:33.308Z","comments":true,"path":"2016/03/05/linux/Linux服务器时间同步/","link":"","permalink":"https://www.zhangqifei.top/2016/03/05/linux/Linux服务器时间同步/","excerpt":"","text":"123date -s &quot;2018-01-20 14:08:00&quot; 设置当前时间clock -s 把BIOS时间同步当前系统hwclock -w 把当前时间同步到BIOS里面","categories":[{"name":"linux","slug":"linux","permalink":"https://www.zhangqifei.top/categories/linux/"}],"tags":[{"name":"date","slug":"date","permalink":"https://www.zhangqifei.top/tags/date/"}]},{"title":"linux 安装rz和sz命令","slug":"随笔/linux 安装rz和sz命令","date":"2016-03-04T01:42:22.000Z","updated":"2018-04-23T07:12:14.373Z","comments":true,"path":"2016/03/04/随笔/linux 安装rz和sz命令/","link":"","permalink":"https://www.zhangqifei.top/2016/03/04/随笔/linux 安装rz和sz命令/","excerpt":"","text":"lrzsz在linux里可代替ftp上传和下载。 lrzsz 官网入口 lrzsz是一个unix通信套件提供的X，Y，和ZModem文件传输协议windows 需要向centos服务器上传文件，可直接在centos上执行命令yum -y install lrzsz 程序会自动安装好，然后如你要下载者sz [找到你要下载的文件] 如果你要上传，者rz 浏览找到你本机要上传的文件。需要注意的事这个命令无法在putty界面使用哦！ 12345678// 首先安装lrzsz# yum -y install lrzsz// 上传文件，执行命令rz，会跳出文件选择窗口，选择好文件，点击确认即可。# rz// 下载文件，执行命令sz# sz","categories":[{"name":"随笔","slug":"随笔","permalink":"https://www.zhangqifei.top/categories/随笔/"}],"tags":[]},{"title":"状态码大全","slug":"工具/状态码大全","date":"2016-01-04T01:41:22.000Z","updated":"2018-04-23T07:11:04.439Z","comments":true,"path":"2016/01/04/工具/状态码大全/","link":"","permalink":"https://www.zhangqifei.top/2016/01/04/工具/状态码大全/","excerpt":"2xx 成功 状态码 含义 200 正常 请求已完成。 201 正常 紧接 POST 命令。 202 正常 已接受用于处理，但处理尚未完成。 203 正常 部分信息 — 返回的信息只是一部分。 204 正常 无响应 — 已接收请求，但不存在要回送的信息。","text":"2xx 成功 状态码 含义 200 正常 请求已完成。 201 正常 紧接 POST 命令。 202 正常 已接受用于处理，但处理尚未完成。 203 正常 部分信息 — 返回的信息只是一部分。 204 正常 无响应 — 已接收请求，但不存在要回送的信息。 3xx 重定向 状态码 含义 301 已移动 请求的数据具有新的位置且更改是永久的。 302 已找到 请求的数据临时具有不同 URI。 303 请参阅其它 可在另一 URI 下找到对请求的响应，且应使用 GET 方法检索此响应。 304 未修改 未按预期修改文档。 305 使用代理 必须通过位置字段中提供的代理来访问请求的资源。 306 未使用 不再使用；保留此代码以便将来使用。 4xx 客户机中出现的错误 状态码 含义 400 错误请求 请求中有语法问题，或不能满足请求。 401 未授权 未授权客户机访问数据。 402 需要付款 表示计费系统已有效。 403 禁止 即使有授权也不需要访问。 404 找不到 服务器找不到给定的资源；文档不存在。 407 代理认证请求 客户机首先必须使用代理认证自身。 415 介质类型不受支持 服务器拒绝服务请求，因为不支持请求实体的格式。 5xx 服务器中出现的错误 状态码 含义 500 内部错误 因为意外情况，服务器不能完成请求。 501 未执行 服务器不支持请求的工具。 502 错误网关 服务器接收到来自上游服务器的无效响应。 503 无法获得服务 由于临时过载或维护，服务器无法处理请求。 一分耕耘，一分收获，未必;九分耕耘，会有收获，一定! 参考……","categories":[{"name":"工具","slug":"工具","permalink":"https://www.zhangqifei.top/categories/工具/"}],"tags":[{"name":"状态码","slug":"状态码","permalink":"https://www.zhangqifei.top/tags/状态码/"}]},{"title":"笔记所使用的markdown语法","slug":"工具/markdown","date":"2015-09-30T03:10:28.000Z","updated":"2018-04-23T07:11:04.557Z","comments":true,"path":"2015/09/30/工具/markdown/","link":"","permalink":"https://www.zhangqifei.top/2015/09/30/工具/markdown/","excerpt":"","text":"Markdown是什么？Markdown是web上的一种格式文本。Markdown功能强大，我们可以使用Markdown控制文档的显示、把文字格式为粗体或斜体、添加图像、创建列表等等。特别值得一提的是，Markdown编写只需普通文字与一些非字母字符，比如#或*，易于学习与掌握。 Markdown文件的后缀是.md或.markdown,此篇教程就是用Markdown编写的. 创始人 John Gruber 的 Markdown 语法说明 Markdown 中文版语法说明 markdown软件马克飞象（用过） 支持平台： web/chrome app/windows/macOS 官网： https://maxiang.io/ 收费情况：试用10天，无免费版，收费版79/年。 优点：有浏览器就能使用，可随便贴图，而不用指定图片路径，可与印象笔记同步，可导出md源格式，导出生成pdf或html格式。 缺点：收费，联网才能使用。 网上评价：https://www.zhihu.com/question/24676344 简书博客平台（正在使用） 支持平台：Web/Android/iOS 官网：www.jianshu.com 收费情况：完全免费 优点：支持直接贴图，可以做为博客使用，界面美观 缺点：无法导出md源文件(连图片都导出的那种功能)，无法导出pdf 作业部落（正在使用） 支持平台：web/chrome app/windows/macOS 官网：https://www.zybuluo.com/mdeditor 收费情况：收费99 元 / 年，联网离线都能使用。 优点：可以做为博客使用，界面美观.可导出md源格式，导出生成pdf或html格式。 Markdown语法讲解标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。 # 一级标题 ## 二级标题 ### 三级标题以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上-或 *即可变为无序列表，有序列表则直接在文字前加1. 2. 3.符号要和文字之间加上一个字符的空格。 无序列表 1 * 1 2 * 2 3 * 3 注意*前后都有空格 有序列表 1 1. 1 2 2. 2 3 3. 3 注意1.前后都有空格 引用 如果你需要引用一小段别处的句子，那么就要用引用的格式。 例如这样 只需要在文本前加入&gt;这种尖括号（大于号）即可&gt;后有空格 图片与链接 插入链接与插入图片的语法很像，区别在一个 !号 图片为：![]() 链接为：[]() []里面是name; ()里面是图片路径 粗体与斜体 Markdown 的粗体和斜体也非常简单，用两个*包含一段文本就是粗体的语法，用一个*包含一段文本就是斜体的语法。 例如：这里是粗体 这里是斜体 .代码：**粗体** *斜体* 表格 表格是我觉得 Markdown 比较累人的地方，例子如下： | Tables | Are | Cool | | ------------- |:-------------:| -----:| | col 3 is | right-aligned | $1600 | | col 2 is | centered | $12 | | zebra stripes | are neat | $1 | 这种语法生成的表格如下： Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要前三,后三个这个`把中间的代码包裹起来就行。 分割线分割线的语法只需要三个 * 号，例如： 到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。","categories":[{"name":"工具","slug":"工具","permalink":"https://www.zhangqifei.top/categories/工具/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://www.zhangqifei.top/tags/markdown/"}]}]}