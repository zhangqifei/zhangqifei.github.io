<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老朋友好久不见！</title>
  <icon>https://www.gravatar.com/avatar/a5e53349669dc1fb687a74eb208773ae</icon>
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.zhangqifei.top/"/>
  <updated>2019-05-13T07:29:54.012Z</updated>
  <id>https://www.zhangqifei.top/</id>
  
  <author>
    <name>咻一咻</name>
    <email>1353250703@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>测试测试测试测试</title>
    <link href="https://www.zhangqifei.top/2019/08/01/%E9%80%9A%E7%9F%A5/1/"/>
    <id>https://www.zhangqifei.top/2019/08/01/通知/1/</id>
    <published>2019-08-01T01:41:22.000Z</published>
    <updated>2019-05-13T07:29:54.012Z</updated>
    
    <content type="html"><![CDATA[<p>测试</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;测试&lt;/p&gt;

      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
    
      <category term="Nginx" scheme="https://www.zhangqifei.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>恢复更新</title>
    <link href="https://www.zhangqifei.top/2018/08/01/%E9%80%9A%E7%9F%A5/%E6%81%A2%E5%A4%8D%E6%9B%B4%E6%96%B0/"/>
    <id>https://www.zhangqifei.top/2018/08/01/通知/恢复更新/</id>
    <published>2018-08-01T01:41:22.000Z</published>
    <updated>2019-05-13T07:29:54.012Z</updated>
    
    <content type="html"><![CDATA[<p>菜鸟终于决定要更新了！地址：<a href="https://www.zhangqifei.top/book/">https://www.zhangqifei.top/book/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;菜鸟终于决定要更新了！地址：&lt;a href=&quot;https://www.zhangqifei.top/book/&quot;&gt;https://www.zhangqifei.top/book/&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
    
      <category term="Nginx" scheme="https://www.zhangqifei.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>一次说清什么是正向代理，什么是反向代理？</title>
    <link href="https://www.zhangqifei.top/2018/03/05/%E9%9A%8F%E7%AC%94/%E4%B8%80%E6%AC%A1%E8%AF%B4%E6%B8%85%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%EF%BC%9F/"/>
    <id>https://www.zhangqifei.top/2018/03/05/随笔/一次说清什么是正向代理，什么是反向代理？/</id>
    <published>2018-03-05T01:42:22.000Z</published>
    <updated>2018-04-23T07:12:14.352Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>比如你现在缺钱，想找马云爸爸去借钱，可想而知人家可能鸟都不鸟你，到最后碰一鼻子灰借不到钱。不过你认识你家隔壁老王，而老王认识马云同志，而且关系还很好。这时候你托老王去找马云借钱，当然这事最后成了，你从马云那里借到了500万！这时候马云并不知道钱是你借的，只知道这钱是老王借的。最后由老王把钱转交给你。在这里，老王就充当了一个重要的角色：代理。</p><p>此时的代理，就是我们常说的正向代理。代理客户端去请求服务器，隐藏了真实客户端，服务器并不知道真实的客户端是谁。正向代理应用最广泛的莫过于现在的某些“科学上网工具”，你访问不了谷歌、Facebook的时候，你可以在国外搭建一台代理服务器，代理你访问，代理服务器再把请求到的数据转交给你，你就可以看到内容了</p><center><br><img src="http://zhangqifei.top/picture/httpd/20180307210726782.png" alt="正向代理"><br></center><p><strong>相对专业点解释：</strong></p><p>正向代理是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。</p><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>比如你现在很无聊，想找人聊天，这时候你拨通了联通客服10010电话，联通的总机可能随机给你分配一个闲置的客服给你接通。这时候你如愿以偿的和客服聊了起来，问了问她目前有没有结婚、有没有对象、家住哪里、她的微信号、她的手机号。。。</p><p>此时联通总机充当的角色就是反向代理，你只知道和客服接通并聊了起来，具体为什么会接通这个客服MM，怎么接通的，你并不知道。</p><p>反向代理隐藏了真正的服务端，就像你每天使用百度的时候，只知道敲打<a href="http://www.baidu.com就可以打开百度搜索页面，但背后成千上万台百度服务器具体是哪一台为我们服务的，我们并不知道。我们只知道这个代理服务器，它会把我们的请求转发到真实为我们服务的那台服务器那里去。" target="_blank" rel="noopener">www.baidu.com就可以打开百度搜索页面，但背后成千上万台百度服务器具体是哪一台为我们服务的，我们并不知道。我们只知道这个代理服务器，它会把我们的请求转发到真实为我们服务的那台服务器那里去。</a></p><p>软件层面一般常用Nginx来做反向代理服务器，它的性能非常好，用来做负载均衡。</p><center><br><img src="http://zhangqifei.top/picture/httpd/20180307210840303.png" alt="反向代理"><br></center><p><strong>相对专业点解释：</strong></p><ul><li>反向代理（Reverse Proxy）方式是指以代理服务器来接受Internet上的连接请求，然后将请求转发给内部网络上的服务器；并将从服务器上得到的结果返回给Internet上请求连接的客户端，此时代理服务器对外就表现为一个服务器。</li><li>通常的代理服务器，只用于代理内部网络对Internet的连接请求，客户机必须指定代理服务器,并将本来要直接发送到Web服务器上的http请求发送 到代理服务器中。当一个代理服务器能够代理外部网络上的主机，访问内部网络时，这种代理服务的方式称为反向代理服务。</li></ul><blockquote><p>综上所述：正向代理代理对象是客户端，反向代理代理对象是服务端。</p></blockquote><h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><center><br><img src="http://zhangqifei.top/picture/httpd/20180307211940945" alt="这里写图片描述"><br></center><br><strong>从用途 上来讲：</strong></p><ul><li>正向代理的典型用途是为在防火墙内的局域网客户端提供访问Internet的途径。正向代理还可以使用缓冲特性减少网络使用率。反向代理的典型用途是将 防火墙后面的服务器提供给Internet用户访问。反向代理还可以为后端的多台服务器提供负载平衡，或为后端较慢的服务器提供缓冲服务。</li><li>另外，反向代理还可以启用高级URL策略和管理技术，从而使处于不同web服务器系统的web页面同时存在于同一个URL空间下。</li></ul><p><strong>从安全性 来讲：</strong></p><ul><li>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此你必须采取安全措施以确保仅为经过授权的客户端提供服务。</li><li>反向代理对外都是透明的，访问者并不知道自己访问的是一个代理。</li></ul><blockquote><p>最后一句话总结：<br>打个比方，有a,b,c三个人<br>正向代理是： a通过b向C借钱，a知道c的存在 。<br>反向代理是： a向b借钱，b又向C借，a不知道c的存在。</p></blockquote><p><a href="https://baijiahao.baidu.com/s?id=1566988836622068&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">原文链接</a> 之所以转载这篇文章，是因为例子举的太好了，非常适合初学者理解。但是样式有点乱 自己稍微整理了下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正向代理&quot;&gt;&lt;a href=&quot;#正向代理&quot; class=&quot;headerlink&quot; title=&quot;正向代理&quot;&gt;&lt;/a&gt;正向代理&lt;/h3&gt;&lt;p&gt;比如你现在缺钱，想找马云爸爸去借钱，可想而知人家可能鸟都不鸟你，到最后碰一鼻子灰借不到钱。不过你认识你家隔壁老王，而老王认识
      
    
    </summary>
    
      <category term="随笔" scheme="https://www.zhangqifei.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>程序员为什么一定要用Linux？</title>
    <link href="https://www.zhangqifei.top/2018/03/04/%E9%9A%8F%E7%AC%94/%E7%A8%8B%E5%BA%8F%E5%91%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%80%E5%AE%9A%E8%A6%81%E7%94%A8Linux%EF%BC%9F/"/>
    <id>https://www.zhangqifei.top/2018/03/04/随笔/程序员为什么一定要用Linux？/</id>
    <published>2018-03-04T01:41:22.000Z</published>
    <updated>2018-04-23T07:12:14.222Z</updated>
    
    <content type="html"><![CDATA[<p>大多数人推荐Linux，基本上都会说Linux让你更高效、更优秀。</p><p><strong>然而工具只是工具。</strong></p><p><strong>然而工具只是工具。</strong></p><p><strong>然而工具只是工具。</strong></p><p>优秀程序员和不优秀程序员的区别首先是态度上的区别。</p><p>他们有自己的理想，思考很多，不管是项目开始之前还是在项目进行中，项目完成之后也会进行总结。</p><p>他们对待问题比较严谨，思考比较全面，在动手写代码之前肯定经过了一定的思考，对可能引入的问题进行预估。</p><p>而不优秀的程序员对待问题比较随意，也就是态度上不是那么认真，代码写的也比较随意：他们不会意识到他们的代码已经污染了整个项目。</p><p>除了态度上的不同，在能力上也有很大的差别。</p><p>遇到比较难缠的问题，优秀的程序员总是能从原理出发，一针见血的看出问题的真正原因，进而解决问题，而不优秀的程序员总是停留在表面——认为Linux会把你变得优秀就是停留在表面，只有你自己才能把你变优秀。</p><p><strong>那么Linux的好处到底在哪里呢？</strong></p><h3 id="1-开源"><a href="#1-开源" class="headerlink" title="1.开源"></a>1.开源</h3><blockquote><p>这个我想不用解释。</p></blockquote><h3 id="2-多用户、多任务、多线程"><a href="#2-多用户、多任务、多线程" class="headerlink" title="2.多用户、多任务、多线程"></a>2.多用户、多任务、多线程</h3><blockquote><p>Linux系统同时可以支持多个用户，每个用户对自己的文件设备有特殊的权利，能够保证各用户之间互不干扰，就像手机开了助手一样，同时登陆多个qq账号，当硬件配置非常高时，每个用户还可以同时执行多个任务、多个线程同时工作、提高效率，简直是完美的一塌糊涂，单凭多用户而言就完爆其他操作系统。</p></blockquote><h3 id="3-稳定性和高效性"><a href="#3-稳定性和高效性" class="headerlink" title="3.稳定性和高效性"></a>3.稳定性和高效性</h3><blockquote><p>你也许会听到Windows服务器长时间运行而突然宕机，但你绝不会听到Linux系统服务器因为长时间不关机会卡死，在Linux上几乎是不会出现这种情况的。Linux服务器可以无休止的运行下去不宕机，因为它继承了Unix卓越的稳定性和高效性。正因为它的稳定才获得了众多用户的青睐，因为它的高效，它的使用范围更加广阔，然而Linux还可以提供一些高可靠性的服务，比如:LNMP、虚拟化、数据库服务等等。</p></blockquote><h3 id="4-安全性和SELinux"><a href="#4-安全性和SELinux" class="headerlink" title="4.安全性和SELinux"></a>4.安全性和SELinux</h3><blockquote><p>其安全性相比其他系统也要安全很多，由于Linux拥有相当庞大的用户和开源社区支持，因此能很快发现系统漏洞，并迅速发布安全补丁及时更新，同时还具有很强的“免疫力”特点，很少受到病毒攻击，对于一个开放式系统而言，在方便用户的同时，很可能存在安全隐患。不过，利用Linux自带防火墙（iptables，firewalld）、入侵检测和安全认证等工具，及时修补系统的漏洞，就能大大提高Linux系统的安全性，让黑客们无机可乘，同时还有安全增强机制SElinux，在linux内核中提供强制访问控制，功能非常全面，能够很好保护系统和服务，不过很多人喜欢把它关闭，这相对安全性就不是很好了。还有Tcp_wrappers也能够提供很好的网络服务访问控制，Linux系统对于用户和文件管理权限的管理也是相当出色的，能够很好的控制权限，保证文件的机密性，也是其他系统无法比拟，所以Linux系统在一定程度上是坚不可摧的。</p></blockquote><h3 id="5-性能优势"><a href="#5-性能优势" class="headerlink" title="5.性能优势"></a>5.性能优势</h3><blockquote><p>由于Linux要保证其稳定性，所以并没有像其它操作系统一样内核如此臃肿庞大、漏洞百出，随着Linux内核的不断更新，不断提升着优势，Linux操作系统能把服务器的硬件优势体现的淋漓尽致，因为Linux系统吸取了Unix系统近1/4世纪发展的经验，最主要的是Linux开放源代码，保证系统稳定性，更好的调用硬件功能，同时还提供了丰富的系统资源工具top，freee，df，vmstat，dmesg，iostat，sar，uptime等，方便查看资源的利用率。</p></blockquote><p>以上这些足够让你投向Linux的怀抱了。当然，除了这些，还有一些说不定道不明的定西，比如：</p><p><font color="#0099ff" size="5" face="黑体">bigger than bigger</font><br>把你的Linux系统拿出去，开始用命令行做点事情。<br>比如说，输入<code>sudo rm -rf /*</code>在外行人看来，非常之酷炫！</p><blockquote><p>文章来源：<a href="https://www.zhihu.com/question/21048284/answer/170226604" target="_blank" rel="noopener">https://www.zhihu.com/question/21048284/answer/170226604</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大多数人推荐Linux，基本上都会说Linux让你更高效、更优秀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而工具只是工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而工具只是工具。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;然而工具只是工具。&lt;/strong&gt;&lt;/
      
    
    </summary>
    
      <category term="随笔" scheme="https://www.zhangqifei.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？</title>
    <link href="https://www.zhangqifei.top/2018/02/07/linux/%E9%87%91%E4%B8%9D%E9%9B%80%E5%8F%91%E5%B8%83%E3%80%81%E6%BB%9A%E5%8A%A8%E5%8F%91%E5%B8%83%E3%80%81%E8%93%9D%E7%BB%BF%E5%8F%91%E5%B8%83%E5%88%B0%E5%BA%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%B7%AE%E5%88%AB%EF%BC%9F%E5%85%B3%E9%94%AE%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://www.zhangqifei.top/2018/02/07/linux/金丝雀发布、滚动发布、蓝绿发布到底有什么差别？关键点是什么？/</id>
    <published>2018-02-07T11:42:22.000Z</published>
    <updated>2018-04-22T09:24:20.026Z</updated>
    
    <content type="html"><![CDATA[<p>根据 2017 年的 DevOps 发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。</p><p>作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不清楚这些术语背后的原理。本文试图总结当前主流的发布策略，每个的优劣，适用性，让开发人员特别是架构师对现代发布技术有一个更为清晰全面的认识，让大家能够根据自己的企业上下文，对发布策略做出正确的选型和实践。</p><h3 id="一、单服务器组发布"><a href="#一、单服务器组发布" class="headerlink" title="一、单服务器组发布"></a>一、单服务器组发布</h3><p>先解释下单服务器组的概念，早先我们机器资源比较紧张，不像现在云计算和虚拟化（包括容器技术）这么发达，所以应用机器基本是预先静态分配好的（一般由运维负责分配），原来应用 A 住在这 n 台机器上，那么下次升级发布的应用 A 也住在这 n 台机器上，所以称为单服务器组发布方式。</p><h4 id="蛮力发布"><a href="#蛮力发布" class="headerlink" title="蛮力发布"></a>蛮力发布</h4><p>如下图所示，这种发布方式比较简单粗暴，有点像我们传统的软件升级方式，主要靠手工完成，先将老版本 V1 全部下掉，再将新版本发到机器上去。这种方式会引入服务中断（停机），在开发测试环境是可行的，但对于生产环境发布，其会直接影响用户的使用体验，这种方式一般是不建议的。</p><center><br><img src="https://img-blog.csdn.net/20180413152557349" alt="这里写图片描述"><br></center><p><strong>优势：</strong></p><ul><li>简单成本低</li></ul><p><strong>不足：</strong></p><ul><li>服务中断用户受影响，出了问题回退也慢</li></ul><p><strong>适用场合：</strong></p><ul><li>开发测试环境</li><li>非关键应用（用户影响面小）</li><li>初创公司什么都缺，找夜深人静用户访问量小的时间干</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413151836748" alt="这里写图片描述"><br>蛮力发布会引入服务中断时间<br></center><h4 id="金丝雀发布（单服务器组）"><a href="#金丝雀发布（单服务器组）" class="headerlink" title="金丝雀发布（单服务器组）"></a>金丝雀发布（单服务器组）</h4><p>在蛮力发布基础上的一种简单改进发布方式，目前仍然是不少成长型技术组织的主流发布方式。单服务器组下的金丝雀发布的简化步骤如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413152452336" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>金丝雀发布一般先发 1 台，或者一个小比例，例如 2% 的服务器，主要做流量验证用，也称为金丝雀 (Canary) 测试（国内常称灰度测试）。以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。简单的金丝雀测试一般通过手工测试验证，复杂的金丝雀测试需要比较完善的监控基础设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回退的依据。</li><li>如果金丝测试通过，则把剩余的 V1 版本全部升级为 V2 版本。如果金丝雀测试失败，则直接回退金丝雀，发布失败。</li></ul><p><strong>优势：</strong></p><ul><li>用户体验影响小，金丝雀发布过程出现问题只影响少量用户</li></ul><p><strong>不足：</strong></p><ul><li>发布自动化程度不够，发布期间可引发服务中断</li></ul><p><strong>适用场合：</strong></p><ul><li>对新版本功能或性能缺乏足够信心</li><li>用户体验要求较高的网站业务场景</li><li>缺乏足够的自动化发布工具研发能力</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413152919230" alt="这里写图片描述"><br>少量金丝雀先接受流量，再全量发布<br></center><h4 id="滚动式发布（单服务器组）"><a href="#滚动式发布（单服务器组）" class="headerlink" title="滚动式发布（单服务器组）"></a>滚动式发布（单服务器组）</h4><p>在金丝雀发布基础上的进一步优化改进，是一种自动化程度较高的发布方式，用户体验比较平滑，是目前成熟型技术组织所采用的主流发布方式。单服务器组下的滚动发布的简化步骤如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413160543532" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>滚动式发布一般先发 1 台，或者一个小比例，如 2% 服务器，主要做流量验证用，类似金丝雀 (Canary) 测试。</li><li>滚动式发布需要比较复杂的发布工具和智能 LB，支持平滑的版本替换和流量拉入拉出。</li><li>每次发布时，先将老版本 V1 流量从 LB 上摘除，然后清除老版本，发新版本 V2，再将 LB 流量接入新版本。这样可以尽量保证用户体验不受影响。</li><li>一次滚动式发布一般由若干个发布批次组成，每批的数量一般是可以配置的（可以通过发布模板定义）。例如第一批 1 台（金丝雀），第二批 10%，第三批 50%，第四批 100%。每个批次之间留观察间隔，通过手工验证或监控反馈确保没有问题再发下一批次，所以总体上滚动式发布过程是比较缓慢的 (其中金丝雀的时间一般会比后续批次更长，比如金丝雀 10 分钟，后续间隔 2 分钟)。</li><li>回退是发布的逆过程，将新版本流量从 LB 上摘除，清除新版本，发老版本，再将 LB 流量接入老版本。和发布过程一样，回退过程一般也比较慢的。</li><li>滚动式发布国外术语通常叫 Rolling Update Deployment。</li></ul><p><strong>优势：</strong></p><ul><li>用户体验影响小，体验较平滑</li></ul><p><strong>不足：</strong></p><ul><li>发布和回退时间比较缓慢</li><li>发布工具比较复杂，LB 需要平滑的流量摘除和拉入能力</li></ul><p><strong>适用场合：</strong></p><ul><li>用户体验不能中断的网站业务场景</li><li>有一定的复杂发布工具研发能力；</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413160829601" alt="这里写图片描述"><br>滚动式发布，流量平滑过渡，<br></center><h3 id="二、双服务器组发布"><a href="#二、双服务器组发布" class="headerlink" title="二、双服务器组发布"></a>二、双服务器组发布</h3><p>蓝绿发布仅适用于双服务器组发布，可以认为是对蛮力发布的一种简单优化发布方式。简化过程如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413161359955" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>V1 版本称为蓝组，V2 版本称为绿组，发布时通过 LB 一次性将流量从蓝组直接切换到绿组，不经过金丝雀和滚动发布，蓝绿发布由此得名；</li><li>出现问题回退也很直接，通过 LB 直接将流量切回蓝组。</li><li>发布初步成功后，蓝组机器一般不直接回收，而是留一个待观察期，视具体情况观察期的时间可长可短，观察期过后确认发布无问题，则可以回收蓝组机器。</li></ul><p><strong>优势：</strong></p><ul><li>升级切换和回退速度非常快</li></ul><p><strong>不足：</strong></p><ul><li>切换是全量的，如果 V2 版本有问题，则对用户体验有直接影响；</li><li>需要两倍机器资源；</li></ul><p><strong>适用场合：</strong></p><ul><li>对用户体验有一定容忍度的场景</li><li>机器资源有富余或者可以按需分配（AWS 云，或自建容器云）</li><li>暂不具备复杂滚动发布工具研发能力；</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413161716274" alt="这里写图片描述"><br>蓝绿发布一次完成流程切换<br></center><h4 id="金丝雀发布（双服务器组）"><a href="#金丝雀发布（双服务器组）" class="headerlink" title="金丝雀发布（双服务器组）"></a>金丝雀发布（双服务器组）</h4><p>对蓝绿部署的一种简单优化，发布时先从绿组拉入 1 台金丝雀，待金丝雀验证通过再发全量。对比蓝绿发布，该发布方式的优势是有一个生产流量的金丝雀验证过程，可以减轻 V2 可能有问题的风险和影响面。简化发布过程如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413162041469" alt="这里写图片描述"><br></center><h4 id="滚动式发布（双服务器组）"><a href="#滚动式发布（双服务器组）" class="headerlink" title="滚动式发布（双服务器组）"></a>滚动式发布（双服务器组）</h4><p>滚动式发布是对上面的蓝绿和金丝雀发布的进一步优化，按批次增量滚动发布，提供更平滑的用户体验。</p><center><br><img src="https://img-blog.csdn.net/20180413162342844" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>发布前先申请一批新服务器，数量一般和 V1 版本相同，将 V2 版本应用发布到新服务器上。例如如果在 AWS 云上，则可以直接调用 API 申请一批新 VM，如果用容器云 Kubernetes，则可以直接启动一批新容器（使用 V2 版本容器镜像）。</li><li>一般会先通过 LB 拉入 1 台 V2 版本的机器，这台机器也相当于金丝雀，用于流量验证。</li><li>逐步按批次完成发布，每批只需要通过 LB 拉入 V2 版本，再拉出对应数量的 V1 版本。批次之间留有观察间隔，通过手工或监控反馈确保没有问题再继续发布。</li><li>发布有问题回退很快，直接通过 LB 将流量切回 V1 即可。</li><li>完成发布后，一般 V1 版本要保留观察以备万一，比如留 1 天，1 天后没有问题则回收 V1 机器资源。</li></ul><p><strong>优势：</strong></p><ul><li>用户体验影响小；</li><li>升级切换和回退（rollback）速度比单服务器组滚动发布要快，LB 切流量即可；</li></ul><p><strong>不足：</strong></p><ul><li>需要两倍机器资源；</li><li>发布工具比较复杂，LB 需要流量切换能力</li></ul><p><strong>适用场合：</strong></p><ul><li>用户体验不能中断的网站业务场景</li><li>机器资源有富余或者可以按需分配（AWS 云，或自建容器云）</li><li>有一定的发布工具研发能力；</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413162608274" alt="这里写图片描述"><br>滚动式发布，流量平滑过渡<br></center><h3 id="三、其它发布方式"><a href="#三、其它发布方式" class="headerlink" title="三、其它发布方式"></a>三、其它发布方式</h3><p>上述都是偏传统的发布方式，能覆盖大部分应用发布场景。针对一些关键新功能的上线发布，或者一些特定的场景，还有一些特殊的发布方式。</p><h4 id="功能开关发布"><a href="#功能开关发布" class="headerlink" title="功能开关发布"></a>功能开关发布</h4><p>利用代码中的功能开关（Feature Flag/Toggle/Switch）来控制发布逻辑，一般不需要复杂的发布工具和智能 LB 配合，是一种相对比较低成本和简单的发布方式。这种方式也是支持现代 DevOps 理念，研发人员可以灵活定制和自助完成的发布方式。功能开关的原理如下图所示：</p><center><br><img src="https://img-blog.csdn.net/20180413162726916" alt="这里写图片描述"><br>功能开关发布<br></center><p><strong>实践要点</strong></p><ul><li>功能开关发布需要一个配置中心或者开关中心这样的服务支持，例如携程的 Apollo 配置中心附录 6.3，或者开源的 FF4J附录 6.4，这些都支持开关发布，业界还有专门的功能开关 SaaS 服务，例如 LaunchDarkly附录 6.5。通过配置中心，运维或研发人员可以在运行期动态配置功能开关的值。当然，功能开关发布只是配置中心的一种使用场景，配置中心还能支持其它很多动态配置场景。</li><li>功能开关服务一般提供客户端 SDK，方便开发人员集成。在运行期，客户端 SDK 会同步最新的开关值，技术实现有推方式 (push)，也有拉方式 (pull)，或者推拉结合方式。</li><li>新功能（V2 new feature）和老功能（V1 old feature）住在同一套代码中，新功能隐藏在开关后面，如果开关没有打开，则走老代码逻辑，如果开关打开，则走新代码逻辑。技术实现上可以理解为一个简单的 if/else 逻辑。</li><li>应用上线后，开关先不打开，然后运维或研发人员通过开关中心打开新功能，经过流量验证新功能没有问题，则发布完成；如果有问题，则随时可以通过开关中心切回老功能逻辑。</li></ul><p><strong>优势：</strong></p><ul><li>升级切换和回退速度非常快</li><li>相对于复杂的发布工具，实施比较简单，成本相对低廉</li><li>研发能够灵活定制发布逻辑，支持 DevOps 自助发布</li></ul><p><strong>不足：</strong></p><ul><li>切换是全量的，如果 V2 版本有问题，则对用户体验有直接影响；</li><li>对代码有侵入，代码逻辑会变复杂，需要定期清理老版本逻辑，维护成本变高</li></ul><p><strong>适用场合：</strong></p><ul><li>对用户体验有一定容忍度的场景</li><li>已有配置中心或开关中心服务</li><li>暂不具备研发复杂发布工具能力；</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413162936972" alt="这里写图片描述"><br>通过功能开关一次完成流量切换<br></center><h4 id="A-B-测试"><a href="#A-B-测试" class="headerlink" title="A/B 测试"></a>A/B 测试</h4><p>A/B 测试附录 7.10原来主要用于产品功能的比对测试，收集用户反馈和对比数据做产品功能设计的决策。实际上，A/B 测试也可以作为一种新功能发布技术。下图展示基于 LB 实现的一种 A/B 测试发布。</p><center><br><img src="https://img-blog.csdn.net/20180413163047576" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>上图中，原来 PC 端和手机端都访问老版本 V1 服务（也称 A 组或控制组），当 V2 新版本（也称 B 组或实验组）发布以后，为了验证 V2 的功能正确性，同时也为了避免 V2 有问题时影响所有用户，先通过 LB 将手机端的流量切换到 V2 版本，经过一段时间的 A/B 比对测试和观察（主要通过用户和监控反馈），确保 V2 正常，则通过 LB 将全部流量切换到 V2。</li><li>基于 LB 方式实现 A/B 测试，LB 需要能够通过某种条件做流量路由，例如通过 client ip，设备类型，浏览器类型，甚至是定制的 HTTP Header 或查询字符串。</li><li>高级的 A/B 测试需要专门的平台支撑，wasabi附录 6.6就是 intuit 开源的一个支持高级 A/B 测试的平台，这类平台可以细粒度到针对某类用户做 A/B 测试，例如针对某个地区的用户，某个年龄段的用户，公司内部用户等等。举了例子，假设一个关键业务的新功能上线，为了降低风险采用 A/B 测试，可以做到先只让公司内部员工能访问到新功能，待新功能验证过，再全量放开给外部用户使用。</li><li>功能开关和 A/B 测试有点相似，但功能开关一般是无状态和全量的，无法做到针对某类特定用户进行测试，而 A/B 测试一般是有状态的，能够跟踪事务和用户级别的状态，可以实现针对某类特定用户进行测试。</li></ul><p><strong>优势：</strong></p><ul><li>用户体验影响小；</li><li>可以使用生产流量测试；</li><li>可以做到针对某类特定目标用户进行测试；</li></ul><p><strong>不足：</strong></p><ul><li>搭建复杂度相对高，有一定技术门槛</li></ul><p><strong>适用场合：</strong></p><ul><li>核心关键业务，比如涉及资金的</li><li>具备一定的 A/B 测试平台研发能力</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/201804131632311" alt="这里写图片描述"><br>针对某类目标用户进行 A/B 测试<br></center><h4 id="影子测试"><a href="#影子测试" class="headerlink" title="影子测试"></a>影子测试</h4><p>对于一些涉及核心业务的遗留系统的升级改造，为了确保万无一失，有一种称为影子测试的大招，采用比较复杂的流量复制、回放和比对技术实现。下面是影子测试的一个样例架构图，</p><center><br><img src="https://img-blog.csdn.net/20180413163342859" alt="这里写图片描述"><br></center><p><strong>实践要点</strong></p><ul><li>目标实现老的 legacy 服务迁移升级到新的 experimental 服务。</li><li>测试开始前，需要在测试环境部署一份 legacy 服务和 experimental 服务，同时将生产数据库复制两份到测试环境。同时需要将生产请求日志收集起来，一般可以通过 kafka 队列收集，然后通过类似 goreplay附录 6.8这样的工具，消费 kafka 里头的请求日志，复制回放，将请求分发到 legacy 服务和 experimental 服务，收到响应后进行比对，如果所有响应比对成功，则可以认为 legacy 服务和 experimental 服务在功能逻辑上是等价的；如果有响应比对失败，则认为两者在功能逻辑上不等价，需要修复 experimental 并重新进行影子测试，直到全部比对成功。根据系统复杂度和关键性不同，比对测试时间短的可能需要几周，长的可达半年之久。</li><li>影子测试因为旁路在独立测试环境中进行，可以对生产流量完全无影响。</li><li>影子测试一般适用于遗留系统的等价重构迁移，例如.net 转 Java，或者 SQLServer 数据库升级为 MySQL 数据库，且外部依赖不能太多，否则需要开发很多 mock，测试部署成本会很高，且比对测试更加复杂和不稳定。</li><li>当当网有一个比较成功的交易系统.NET 转 Java 迁移项目附录 6.9，采用了影子测试技术，值得参考借鉴。</li></ul><p><strong>优势：</strong></p><ul><li>对生产用户体验完全无影响</li><li>可以使用生产真实流量进行测试（复制比对）</li></ul><p><strong>不足：</strong></p><ul><li>搭建复杂度很高，技术门槛高，数据库的导出复制是难点</li><li>外部依赖不能太多，否则测试部署成本很高，且比对测试更加复杂和不稳定</li></ul><p><strong>适用场合：</strong></p><ul><li>核心关键业务，比如涉及资金的</li><li>具备一定影子测试平台研发能力，包括流量复制、数据库导出复制和分发比对系统。</li></ul><p><strong>流量模式</strong></p><center><br><img src="https://img-blog.csdn.net/20180413163538922" alt="这里写图片描述"><br>影子测试对生产流量无影响<br></center><h3 id="四、比较"><a href="#四、比较" class="headerlink" title="四、比较"></a>四、比较</h3><p>下表对各种发布策略，从各个维度进行综合比较，供参考：</p><center><br><img src="https://img-blog.csdn.net/20180413163634468" alt="这里写图片描述"><br></center><h3 id="五、结论和建议"><a href="#五、结论和建议" class="headerlink" title="五、结论和建议"></a>五、结论和建议</h3><p>下面是对发布策略的一些选型建议，供不同阶段公司参考：</p><ul><li>蛮力发布一般是不建议采用的，除非是开发测试环境，用户体验不敏感的非关键应用，或者是创业期什么都缺时候的无奈之举。</li><li>如果暂时还不具备研发较复杂的滚动发布工具和配套智能 LB，则功能开关是一种不错的轻量级发布技术，投入相对较小的成本，可以让研发人员灵活定制发布逻辑。</li><li>金丝雀发布通过少量新版本服务器接收生产流量的方式去验证新版本，可以显著降低风险。金丝雀发布适用于大部分场景，一般成长型公司就可以采用。</li><li>对于达到一定业务体量的公司，考虑到用户体验对业务的关键性，则需要投入研发资源开发支持滚动式发布的工具和配套的智能 LB，实现自动化和零停机的发布。滚动式发布一般和金丝雀发布配合，先发一台金丝雀去验证流量，再按批次增量发布。</li><li>随着轻量级虚拟化（例如容器）的普及，双服务器组发布方式具有更快的发布和回退速度，是值得投入的高级发布技术。蓝绿部署仅适用于双服务器组，滚动式发布既可以在单服务器组上实现，也可以在双服务器组上实现。</li><li>对于涉及关键核心业务的新功能上线，采用 A/B 测试，可以显著降低发布风险，A/B 测试是唯一一种支持针对特定用户组进行生产测试的高级发布技术。当然 A/B 测试的投入不低，建议有一定研发能力的组织采用。</li><li>对于关键核心业务的迁移重构，为确保万无一失，最后的一个大招是影子测试，影子测试对生产流量和用户完全无影响。当然这个大招的投入成本和门槛都高，建议有足够业务体量和研发能力的组织投入。</li><li>上述的各种发布策略并不是非此即彼的，一个公司常常会综合采用多种发布技术作为互补，实现灵活的发布能力。例如主流的发布手段是金丝雀 + 滚动式发布，某些业务线可能根据业务场景需要采用功能开关发布，还有一些业务线则可能采用高级的 A/B 测试发布手段。</li></ul><h3 id="六、附录"><a href="#六、附录" class="headerlink" title="六、附录"></a>六、附录</h3><p><a href="https://github.com/ContainerSolutions/k8s-deployment-strategies" target="_blank" rel="noopener">https://github.com/ContainerSolutions/k8s-deployment-strategies</a></p><p><a href="https://opensource.com/article/18/2/feature-flags-ring-deployment-model" target="_blank" rel="noopener">https://opensource.com/article/18/2/feature-flags-ring-deployment-model</a></p><p><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">https://github.com/ctripcorp/apollo</a></p><p><a href="http://www.ff4j.org/" target="_blank" rel="noopener">http://www.ff4j.org/</a></p><p><a href="https://launchdarkly.com/" target="_blank" rel="noopener">https://launchdarkly.com/</a></p><p><a href="https://github.com/intuit/wasabi" target="_blank" rel="noopener">https://github.com/intuit/wasabi</a></p><p><a href="https://blog.zenika.com/2017/04/19/migration-dun-legacy-avec-goreplay/" target="_blank" rel="noopener">https://blog.zenika.com/2017/04/19/migration-dun-legacy-avec-goreplay/</a></p><p><a href="https://github.com/buger/goreplay" target="_blank" rel="noopener">https://github.com/buger/goreplay</a></p><p><a href="http://blog.shurenyun.com/untitled-9/" target="_blank" rel="noopener">http://blog.shurenyun.com/untitled-9/</a></p><p><a href="https://en.wikipedia.org/wiki/A/B_testing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/A/B_testing</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;根据 2017 年的 DevOps 发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。&lt;/p&gt;
&lt;p&gt;作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
    
      <category term="发布" scheme="https://www.zhangqifei.top/tags/%E5%8F%91%E5%B8%83/"/>
    
  </entry>
  
  <entry>
    <title>吐血推荐珍藏的Chrome插件</title>
    <link href="https://www.zhangqifei.top/2018/01/08/%E5%B7%A5%E5%85%B7/%E5%90%90%E8%A1%80%E6%8E%A8%E8%8D%90%E7%8F%8D%E8%97%8F%E7%9A%84Chrome%E6%8F%92%E4%BB%B6/"/>
    <id>https://www.zhangqifei.top/2018/01/08/工具/吐血推荐珍藏的Chrome插件/</id>
    <published>2018-01-08T00:33:59.000Z</published>
    <updated>2018-04-23T07:11:04.528Z</updated>
    
    <content type="html"><![CDATA[<p>你应该知道的的Chrome插件！！！</p><h2 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h2><p>装逼利器，教你如何优雅的使用Chrome，新打开一个Tab的时候再也不是一片空白，每天一副精美图片，给你们看下我今天的桌面感受下。<a href="https://www.investopedia.com/terms/m/momentum.asp" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/0.png" width="500" height="200" alt="Momentum" align="center"></center><h2 id="OneTab"><a href="#OneTab" class="headerlink" title="OneTab"></a>OneTab</h2><p>　　强烈推荐，使用场景是这样的，我们使用Chrome经常会一次打开好多tab，很多是会用到的，又不舍得关，内存又耗着，这个时候点击下OneTab，直接把所有tab回收，然后每天的历史都给你记录着，接着你可以一键还原某一天的tab，真乃为Chrome而生。<a href="http://chromecj.com/productivity/2014-11/280.html" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/onetab.png" width="500" height="200" alt="OneTab" align="center"></center><h2 id="ZenHub"><a href="#ZenHub" class="headerlink" title="ZenHub"></a>ZenHub</h2><p>ZenHub增压您GitHub上的工作流程.ZenHub是第一个也是唯一的项目管理套件的作品本身内GitHub上;提高您的工作流程，专为初创内置功能，快速移动的工程团队，以及开源社区。该产品是一款浏览器扩展，注入先进的功能，包括实时拖动和拖放发行任务板，通过 1按钮同行的反馈，并直接上传任何文件类型到GitHub的接口支持。 ZenHub可以很容易地集中所有进程到GitHub上，保持你的团队的精益和敏捷。 <a href="https://www.zenhub.com/" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/zenhub.png" width="500" height="200" alt="ZenHub" align="center"></center><h2 id="草料二维码"><a href="#草料二维码" class="headerlink" title="草料二维码"></a>草料二维码</h2><p>点击生成当前网址二维码,草料二维码插件，实现快速获取二维码。<a href="https://cli.im/" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/1.png" width="500" height="200" alt="草料二维码" align="center"></center><h2 id="Adblock-Plus"><a href="#Adblock-Plus" class="headerlink" title="Adblock Plus"></a>Adblock Plus</h2><p>您有没有遇到过在使用chrome浏览器看视频或者是阅读文章的时候突然冒出一个大尺度的广告挡住了您的视线，不过这也可能还算是好的，如果那个大尺度的广告还没有关闭按钮的话我想您可能都有骂人的冲动了吧，而对于一篇自己喜欢的文章或者是喜爱的电影来说又舍不得放弃该怎么办？而今天为大家推荐的这款广告拦截插件：Adblock Plus可以轻松地帮您脱离”困境“。<a href="https://adblockplus.org/zh_CN/" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/adblock.png" width="500" height="200" alt="Adblock" align="center"></center><h2 id="开发工具箱"><a href="#开发工具箱" class="headerlink" title="开发工具箱"></a>开发工具箱</h2><p>功能比较强大，软件开发中常用的一些小工具这里都有，非常方便和全面<br>字符串编码解码 二维码生成 加密解密 HTML/JS/CSS 常用对照表。<a href="http://www.box3.cn/" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/jskf.png" width="500" height="200" alt="开发工具箱" align="center"></center><h2 id="WEB前端助手-FeHelper"><a href="#WEB前端助手-FeHelper" class="headerlink" title="WEB前端助手(FeHelper)"></a>WEB前端助手(FeHelper)</h2><p>FE助手：包括字符串编解码、代码压缩、美化、JSON格式化、正则表达式、时间转换工具、二维码生成与解码、编码规范检测、页面性能检测、页面取色、Ajax接口调试。<a href="http://www.cnplugins.com/devtool/webqianduanzhushoufehelper/" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/FeHelper.png" width="500" height="200" alt="WEB前端助手" align="center"></center><h2 id="Postman"><a href="#Postman" class="headerlink" title="Postman"></a>Postman</h2><p>这款网页调试工具不仅可以调试简单的css、html、脚本等简单的网页基本信息，它还可以发送几乎所有类型的HTTP请求！Postman在发送网络HTTP请求方面可以说是Chrome插件类产品中的代表产品之一。<a href="http://chromecj.com/web-development/2014-09/60.html" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/postman.png" width="500" height="200" alt="Postman" align="center"></center><h2 id="skyZIP™-Proxy"><a href="#skyZIP™-Proxy" class="headerlink" title="skyZIP™ Proxy"></a>skyZIP™ Proxy</h2><p>skyZIP浏览器扩展是完美的匿名互联网访问，如VPN服务，可以做更多，更快。skyZIP可以通过使用高性能代理服务器来优化网页，从而减少数据使用量。数据节省约50％.许多网站没有优化 - 但skyZIP正在将图像转码为WebP无损格式，因此产生的图像缩小了80％。<br><a href="https://www.skyzip.de/" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/skyzip.png" width="500" height="200" alt="skyZIP™ Proxy" align="center"></center><h2 id="Listen-1"><a href="#Listen-1" class="headerlink" title="Listen 1"></a>Listen 1</h2><p>我想大部分人对听音乐是强需求吧？如果没有音乐，那么你的生活里将不在有色彩。有人喜欢用网易云音乐、有人喜欢用虾米、QQ 音乐等，但是想大家不可能同时装这么多客户端吧？因为版权的原因，每个在线音乐网站都没有做到完全的曲库，你又不可能把每个音乐网站都买上会员，所以有时候你需要去不同的网站搜索音乐，这个时候请使用 Listen 1，简直不要太良心。界面也有点极客范，堪称程序员专属听歌工具。但是，Listen 1 并没有在 Chrome 应用商店上架，而是以开源的方式放在了 GitHub，只需要下载并让 Chrome 以开发者模式加载即可，安装方式见 GitHub 项目描述。<a href="https://github.com/listen1/listen1_chrome_extension" target="_blank" rel="noopener">链接地址</a></p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/listen1.png" width="500" height="200" alt="Listen" align="center"></center><h2 id="iBookmark-Bookmarks-收藏夹"><a href="#iBookmark-Bookmarks-收藏夹" class="headerlink" title="iBookmark Bookmarks 收藏夹"></a>iBookmark Bookmarks 收藏夹</h2><p>打造最好用的Chrome书签收藏夹插件，特性如下：</p><ol><li>将收藏夹以列表展示，相比树形图不用层层点击，可以直接看到所有网址；</li><li>支持搜索，快速查找；</li><li>支持在某分类下面新建收藏站点；</li><li>点击网址icon图标，可以对该书签进行修改以及删除操作；</li><li>支持最常访问统计，将常用网址置顶；</li><li><p>支持最新添加的网址展示。</p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/ibookmark.png" width="500" height="200" alt="收藏夹" align="center"></center></li></ol><center><h3>持续更新中·······</h3></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;你应该知道的的Chrome插件！！！&lt;/p&gt;
&lt;h2 id=&quot;Momentum&quot;&gt;&lt;a href=&quot;#Momentum&quot; class=&quot;headerlink&quot; title=&quot;Momentum&quot;&gt;&lt;/a&gt;Momentum&lt;/h2&gt;&lt;p&gt;装逼利器，教你如何优雅的使用Chrome
      
    
    </summary>
    
      <category term="浏览器" scheme="https://www.zhangqifei.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="Chrome" scheme="https://www.zhangqifei.top/tags/Chrome/"/>
    
  </entry>
  
  <entry>
    <title>如何管理自己的时间？</title>
    <link href="https://www.zhangqifei.top/2017/10/09/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/"/>
    <id>https://www.zhangqifei.top/2017/10/09/随笔/如何管理自己的时间/</id>
    <published>2017-10-09T04:35:22.000Z</published>
    <updated>2018-04-23T07:12:14.462Z</updated>
    
    <content type="html"><![CDATA[<p>我们每天都工作，生活。但有时候，每天都很忙碌，却不知道自己在忙些什么。每个人的时间都是有限的，我不想碌碌无为，终其一生。我需要知道自己做了些什么，为什么做，在哪个时候做。我以《Getting Things Done》与《小强升职记》为主，《番茄工作法》为辅，构建自己的时间管理体系。</p><h1 id="Getting-Things-Done"><a href="#Getting-Things-Done" class="headerlink" title="Getting Things Done"></a>Getting Things Done</h1><p>3个东西：确定目标，横向管理，纵向管理</p><p><img src="https://github.com/hirudy/article/blob/master/image/read/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/gtd.png?raw=true" alt="Getting Things Done.png"></p><h4 id="确定目标："><a href="#确定目标：" class="headerlink" title="确定目标："></a>确定目标：</h4><p>你如何判断你的目标，确定做事情的优先级？</p><ul><li>与同龄人沟通，一个人有时候会有太大的孤单感</li><li>与高等级比自己强大的人沟通（比如corey）</li><li>自我测验（如小强升职记）</li></ul><h4 id="横向管理"><a href="#横向管理" class="headerlink" title="横向管理"></a>横向管理</h4><p><img src="https://github.com/hirudy/article/blob/master/image/read/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/gtd_flow.png?raw=true" alt="GTD横向管理流程图"></p><p>这个流程图记录了一件事情如何进入gtd系统，最后被处理的</p><h4 id="纵向管理"><a href="#纵向管理" class="headerlink" title="纵向管理"></a>纵向管理</h4><p>是管理一个比较大的，重要的项目需要做的事情。</p><ul><li>有着自己想达到的目标和原则</li><li>想想可能达到的结果，最好的，最坏的。</li><li>头脑风暴，把跟这个项目关联的，所有信息都记录下来，不做评判</li><li>整理目标原则，整理结果展望，整理头脑风暴信息。</li><li>确定下一步该干什么</li></ul><h4 id="作者任务的观点"><a href="#作者任务的观点" class="headerlink" title="作者任务的观点"></a>作者任务的观点</h4><ul><li>清空大脑（专注）</li><li>生活中只存在两个问题：<ul><li>你知道要达到的目标，但不知道怎么去做？</li><li>你不知道你的目标是什么？</li></ul></li><li>我们的最终目标是把各种工作和情况赶出你的大脑，但绝不丢弃有潜在价值的想法</li></ul><h1 id="小强升职记"><a href="#小强升职记" class="headerlink" title="小强升职记"></a>小强升职记</h1><p>这是一本比较实用的时间管理，个人管理书籍，值得深读，精读，多读。</p><h4 id="寻找种子"><a href="#寻找种子" class="headerlink" title="寻找种子"></a>寻找种子</h4><ul><li>时间日志，找出时间黑洞，找出高效时间段，工作时间段法（基本的时间管理）</li><li>何为重要的事情，寻找自己的价值观，《职业价值观自测表》</li></ul><h4 id="让种子发芽"><a href="#让种子发芽" class="headerlink" title="让种子发芽"></a>让种子发芽</h4><ul><li>四象限法则</li><li>猴子法则：学会说NO, 合理安排时间</li><li>脑袋同时只装一件事情</li><li>gtd</li></ul><h4 id="长出主干和枝桠"><a href="#长出主干和枝桠" class="headerlink" title="长出主干和枝桠"></a>长出主干和枝桠</h4><ul><li>smart原则</li><li>分解</li></ul><h4 id="绿叶充实枝干"><a href="#绿叶充实枝干" class="headerlink" title="绿叶充实枝干"></a>绿叶充实枝干</h4><ul><li>习惯的养成</li></ul><h4 id="摘下够得着的果实"><a href="#摘下够得着的果实" class="headerlink" title="摘下够得着的果实"></a>摘下够得着的果实</h4><ul><li>每日回顾，反思和总结</li><li>处理零时突发事件</li></ul><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h4 id="如何处理中断？"><a href="#如何处理中断？" class="headerlink" title="如何处理中断？"></a>如何处理中断？</h4><p><img src="https://github.com/hirudy/article/blob/master/image/read/%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E8%87%AA%E5%B7%B1%E7%9A%84%E6%97%B6%E9%97%B4/interrupt_deal.png?raw=true" alt="中断处理.png"></p><h1 id="番茄工作法"><a href="#番茄工作法" class="headerlink" title="番茄工作法"></a>番茄工作法</h1><p>该方法，最总要的一个目的是讲一天的时间分成一个个不可分割的原子时间，确保原子时间内，保持高度集中。</p><p>番茄工作法是一套pdca流程（戴明环）</p><h2 id="五个基本问题"><a href="#五个基本问题" class="headerlink" title="五个基本问题"></a>五个基本问题</h2><h4 id="这是一本什么类型的书？"><a href="#这是一本什么类型的书？" class="headerlink" title="这是一本什么类型的书？"></a>这是一本什么类型的书？</h4><p>实用类型</p><h4 id="这本书描述了什么？"><a href="#这本书描述了什么？" class="headerlink" title="这本书描述了什么？"></a>这本书描述了什么？</h4><p>描述了如何运用番茄工作法，使自己如何在一天中专注的做事情。</p><ul><li>计划：早上起来，计划一天做的事情</li><li>跟踪：执行，定闹钟循环的执行（专注工作-休息-专注工作-休息…）</li><li>记录与分析：记录完成情况（记录中断数），分析改进的方式</li><li>可视化：执行改进方式</li></ul><p>在跟踪中，使用一个个番茄时间跟踪完成。</p><h4 id="作者的观点"><a href="#作者的观点" class="headerlink" title="作者的观点"></a>作者的观点</h4><ul><li>一次只干一件事（专注）</li><li>大项目拆分成小项目 </li><li>分清事情优先级</li><li>总结与反思</li><li>说no, 把预估当成承诺</li><li>清空脑子</li><li>树立自信心（ 前怕狼后怕虎，害怕失败和批评）</li><li>没有什么完美主义（完美主义，碍手碍脚）</li><li>今日待办是一种承诺。</li><li>预估，根据历史记录预估，虽然有一些偏差</li></ul><p>番茄工作法是一套pdca流程（戴明环）</p><h4 id="是否有道理？"><a href="#是否有道理？" class="headerlink" title="是否有道理？"></a>是否有道理？</h4><p>感觉更gtd说的比较像，只是更加专注于每一天的处理控制。</p><blockquote><p>番茄工作法是一套pdca流程（戴明环）</p></blockquote><h4 id="自身经验"><a href="#自身经验" class="headerlink" title="自身经验"></a>自身经验</h4><p>不会做时间管理，真在寻找一种合适自己的方式。感觉该方法比较死板。</p><h4 id="对我的用处"><a href="#对我的用处" class="headerlink" title="对我的用处"></a>对我的用处</h4><ul><li>看该方法是否适合我</li><li>结合gtd构建自己的时间管理系统</li></ul><h2 id="重要句子"><a href="#重要句子" class="headerlink" title="重要句子"></a>重要句子</h2><p>已在作者观点与书的描述中，提炼总结</p><h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><h4 id="如何处理中断？-1"><a href="#如何处理中断？-1" class="headerlink" title="如何处理中断？"></a>如何处理中断？</h4><p>中断分为内部中断和外部中断。<br>根据事情的紧急情况做区分。</p><ul><li>不紧急：记录在收集箱中，继续当前番茄时间，延后分类处理</li><li>紧急：作废当前番茄时间，处理紧急事情。</li></ul><h4 id="如何预估一个任务需要的时间？"><a href="#如何预估一个任务需要的时间？" class="headerlink" title="如何预估一个任务需要的时间？"></a>如何预估一个任务需要的时间？</h4><p>根据历史预估，然后当天总结反馈。调整，再预估，迭代处理。</p><h1 id="我的时间管理"><a href="#我的时间管理" class="headerlink" title="我的时间管理"></a>我的时间管理</h1><ul><li>确定自己的方向目标</li><li>用滴答清单，在收集箱中随时记录想到的东西</li><li>早上坐地铁，想想今天的事情</li><li>根据目标确定每一天/每一周/每一月的重要事情（四象限法则）</li><li>将复杂项目分解，成具体的可执行的下一步行动</li><li>每一天专注，我不适合使用番茄法。从清单中拿出一件事情，中断根据重要情况，紧急情况做适当处理，参加《小强升职记》中老付的处理方式</li><li>晚上回去，想想今天做了什么，为什么做？有什么改进的地方。</li></ul><p>向往着更好的生活，更自由的时间，我一直在这条路上奔跑，good luck。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们每天都工作，生活。但有时候，每天都很忙碌，却不知道自己在忙些什么。每个人的时间都是有限的，我不想碌碌无为，终其一生。我需要知道自己做了些什么，为什么做，在哪个时候做。我以《Getting Things Done》与《小强升职记》为主，《番茄工作法》为辅，构建自己的时间管
      
    
    </summary>
    
      <category term="随笔" scheme="https://www.zhangqifei.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>注意啦!</title>
    <link href="https://www.zhangqifei.top/2017/09/28/%E9%80%9A%E7%9F%A5/%E6%B3%A8%E6%84%8F%E5%95%A6%EF%BC%81/"/>
    <id>https://www.zhangqifei.top/2017/09/28/通知/注意啦！/</id>
    <published>2017-09-28T07:12:09.000Z</published>
    <updated>2019-05-13T07:29:54.012Z</updated>
    
    <content type="html"><![CDATA[<p>CSDN博客地址为： <a href="https://blog.csdn.net/qq_37187976/" target="_blank" rel="noopener">https://blog.csdn.net/qq_37187976/</a> 原有文章不迁移。</p><p><a href="http://www.dpbolvw.net/click-8789796-10780766" target="_top">iPage Web Hosting for only $1.99/Month</a><br><img src="http://www.awltovhc.com/image-8789796-10780766" width="1" height="1" border="0"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CSDN博客地址为： &lt;a href=&quot;https://blog.csdn.net/qq_37187976/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/qq_37187976/&lt;/a&gt; 原有文章不迁移。&lt;/p
      
    
    </summary>
    
      <category term="通知" scheme="https://www.zhangqifei.top/categories/%E9%80%9A%E7%9F%A5/"/>
    
    
  </entry>
  
  <entry>
    <title>如何阅读一本书？</title>
    <link href="https://www.zhangqifei.top/2017/09/04/%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/"/>
    <id>https://www.zhangqifei.top/2017/09/04/随笔/如何阅读一本书/</id>
    <published>2017-09-04T01:35:22.000Z</published>
    <updated>2018-04-23T07:12:14.323Z</updated>
    
    <content type="html"><![CDATA[<p>工欲善其事必先利其器，对于我们这些已经脱离了学校的指导学习的热，如果想要不断提高自己，就必须学会自我驱动学习。在自我驱动学习中，书籍成为我们获取知识的重要途径。如何从一本书中汲取知识成为重中之重。</p><p>我以艾德勒的《如何阅读一本书》为基本框架，以赵周的《这样读书就够了》与秋叶的《如何高效读懂一本书》为辅，构建我的读书体系。</p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>一图胜千言<br><img src="https://github.com/hirudy/article/blob/master/image/read/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93.png?raw=true" alt="如何阅读个人总结"></p><hr><h1 id="读《如何阅读一本书》"><a href="#读《如何阅读一本书》" class="headerlink" title="读《如何阅读一本书》"></a>读《如何阅读一本书》</h1><p>精读，分析阅读。</p><h2 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://github.com/hirudy/article/blob/master/image/read/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6.png?raw=true" alt="如何阅读一本书"></p><h2 id="五个基本问题"><a href="#五个基本问题" class="headerlink" title="五个基本问题"></a>五个基本问题</h2><h4 id="1-这本书什么类型？"><a href="#1-这本书什么类型？" class="headerlink" title="1. 这本书什么类型？"></a>1. 这本书什么类型？</h4><p>实用类型，指导类型，方法论</p><h4 id="2-这本书说了什么？"><a href="#2-这本书说了什么？" class="headerlink" title="2. 这本书说了什么？"></a>2. 这本书说了什么？</h4><p>阅读的价值，阅读的四个层次（基础阅读，检视阅读，分析阅读，主题阅读），他们成包含关系。以及如何做笔记等等</p><h4 id="3-作者观点是？"><a href="#3-作者观点是？" class="headerlink" title="3. 作者观点是？"></a>3. 作者观点是？</h4><p>阅读使人灵活。阅读要主动阅读（提问题，找答案）。</p><h4 id="4-所得是否有道理，还是部分有道理？"><a href="#4-所得是否有道理，还是部分有道理？" class="headerlink" title="4. 所得是否有道理，还是部分有道理？"></a>4. 所得是否有道理，还是部分有道理？</h4><ul><li>比较赞同阅读分层结构。分析阅读与对比阅读。</li><li>有点啰嗦，一个东西不同说法如“要理性判断，不做无理的辩驳”与“尊重知识与个人意见的不同，在做任何评判之前找到理论依据”。</li><li>比较适用于精读一本书或建立某个主题的知识体系。</li><li>这么读，时间成本有点高。</li></ul><h4 id="5-对我有什么价值？我怎么运用？"><a href="#5-对我有什么价值？我怎么运用？" class="headerlink" title="5. 对我有什么价值？我怎么运用？"></a>5. 对我有什么价值？我怎么运用？</h4><ul><li>有一个较为系统的读书方法。全局观。<ul><li>基础阅读，读书识字。</li><li>检视阅读，确定阅读价值与作者的观点，这里需要确定是否有价值，作者大概说了什么。</li><li>分析阅读，确定骨架，主旨，事实上，包含检视阅读。输出思维导图，一些重要思想与主旨。评判作者对与否</li><li>主题阅读，没有完美的书，不听信一家之言。完成一类主题的思维导图输出，构建该主题的知识骨架/框架。如同有招到无招的境界。</li></ul></li><li>构建一个主题（如数据库，摄影等等）的知识体系的方法，就用这种方式。</li></ul><h2 id="重要语句摘录"><a href="#重要语句摘录" class="headerlink" title="重要语句摘录"></a>重要语句摘录</h2><ul><li>阅读技巧不仅仅可以运用于书籍，还可以运用于其他的地方，如报纸，杂志，文章，新闻，甚至是广告。</li><li>一个技能或一个习惯，都是由一系列的动作组成。 为了忘掉这些单一的动作，一开始你必须先学会每一个动作。</li><li>思考、感觉、想象是主动阅读（多提问题，然后寻找答案）的重要组成部分。</li></ul><h2 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h2><h4 id="1-第一个主要议题是什么"><a href="#1-第一个主要议题是什么" class="headerlink" title="1. 第一个主要议题是什么"></a>1. 第一个主要议题是什么</h4><p>自我管理的阅读者</p><h4 id="2-第二个主要议题"><a href="#2-第二个主要议题" class="headerlink" title="2. 第二个主要议题"></a>2. 第二个主要议题</h4><p>主动阅读的四个基本问题</p><h4 id="3-如何对书籍分类？"><a href="#3-如何对书籍分类？" class="headerlink" title="3. 如何对书籍分类？"></a>3. 如何对书籍分类？</h4><p>我觉得应该根据用途来区分，毕竟学以致用</p><h4 id="4-检视阅读的两个阶段是在什么时候完成？"><a href="#4-检视阅读的两个阶段是在什么时候完成？" class="headerlink" title="4. 检视阅读的两个阶段是在什么时候完成？"></a>4. 检视阅读的两个阶段是在什么时候完成？</h4><p>第一个阶段，拿到一本新书确认是否有读的必要和价值。<br>第二个阶段，确认可以读，完成一遍粗读，知道在讲什么。</p><h4 id="5-分析阅读的几个阶段是并行完成？"><a href="#5-分析阅读的几个阶段是并行完成？" class="headerlink" title="5. 分析阅读的几个阶段是并行完成？"></a>5. 分析阅读的几个阶段是并行完成？</h4><p>第一二个阶段，如果可能，应该在检视阅读中完成。<br>第三个阶段需要阅读完成，一定思考，理解后。</p><h4 id="6-主题阅读是主题分享？"><a href="#6-主题阅读是主题分享？" class="headerlink" title="6. 主题阅读是主题分享？"></a>6. 主题阅读是主题分享？</h4><p>请一个主题的若干作者一起来讨论一个主题。 分享沙龙<br>无招胜有招。</p><hr><h1 id="读《这样读书就够了》"><a href="#读《这样读书就够了》" class="headerlink" title="读《这样读书就够了》"></a>读《这样读书就够了》</h1><p>检视阅读，粗读</p><h2 id="思维导图-1"><a href="#思维导图-1" class="headerlink" title="思维导图"></a>思维导图</h2><p><img src="https://github.com/hirudy/article/blob/master/image/read/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6/%E8%BF%99%E6%A0%B7%E8%AF%BB%E4%B9%A6%E5%B0%B1%E5%A4%9F%E4%BA%86.png?raw=true" alt="这样读书就够了"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h4 id="1-这本书什么类型？这本书说了什么？"><a href="#1-这本书什么类型？这本书说了什么？" class="headerlink" title="1. 这本书什么类型？这本书说了什么？"></a>1. 这本书什么类型？这本书说了什么？</h4><ul><li>实用类，关于如何读书，如何拆书，以及拆书现场的一些的东西。</li><li>提出了一个读书方式：拆书帮便签法。</li><li>认为读书带目的</li><li>读一本书，不一定要整本书，选着对自己有价值的读就可以了。</li><li>生存余力=生存力量/生存负债</li></ul><h4 id="2-是否有道理？"><a href="#2-是否有道理？" class="headerlink" title="2. 是否有道理？"></a>2. 是否有道理？</h4><ul><li>这本书有一半的时间在说拆书家如何如何，没啥价值</li><li>比较赞同读书带目的，读书不一定全本书都读，可以选着对自己的有用的部分。</li></ul><h4 id="3-对我有什么价值？"><a href="#3-对我有什么价值？" class="headerlink" title="3. 对我有什么价值？"></a>3. 对我有什么价值？</h4><p>书签法，有点用，其核心大概是：</p><ul><li>用自己的话复述书的核心价值。</li><li>联系自己的相关经验，有相似的地方么</li><li>思考，可以怎么用，进行知识归类。</li></ul><p>可以用于读消遣书，或不需要分析阅读、精读的书。</p><hr><h1 id="读《如何高效读懂一本书》"><a href="#读《如何高效读懂一本书》" class="headerlink" title="读《如何高效读懂一本书》"></a>读《如何高效读懂一本书》</h1><p>检视略读，初步判断，该书，就是一本个人解读的书单。有时间再细看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;工欲善其事必先利其器，对于我们这些已经脱离了学校的指导学习的热，如果想要不断提高自己，就必须学会自我驱动学习。在自我驱动学习中，书籍成为我们获取知识的重要途径。如何从一本书中汲取知识成为重中之重。&lt;/p&gt;
&lt;p&gt;我以艾德勒的《如何阅读一本书》为基本框架，以赵周的《这样读书就
      
    
    </summary>
    
      <category term="随笔" scheme="https://www.zhangqifei.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>DevOps的八荣八耻</title>
    <link href="https://www.zhangqifei.top/2017/08/19/%E9%9A%8F%E7%AC%94/DevOps%E7%9A%84%E5%85%AB%E8%8D%A3%E5%85%AB%E8%80%BB/"/>
    <id>https://www.zhangqifei.top/2017/08/19/随笔/DevOps的八荣八耻/</id>
    <published>2017-08-19T01:41:22.000Z</published>
    <updated>2018-04-23T12:52:26.482Z</updated>
    
    <content type="html"><![CDATA[<center><br>以可配置为荣 ，以硬编码为耻<br></center><center><br>以可互备为荣 ，以单点为耻<br></center><center><br>以可无状态为荣 ，以有状态为耻<br></center><center><br>以可随便重启为荣 ，以不能迁移为耻<br></center><center><br>以整体交付为荣，以部分交付为耻<br></center><center><br>以标准化为荣，以特殊化为耻<br></center><center><br>以自动化运维为荣，以人肉化运维为耻<br></center><center><br>以无人值守为荣，以人工值班为耻<br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;br&gt;以可配置为荣 ，以硬编码为耻&lt;br&gt;&lt;/center&gt;&lt;center&gt;&lt;br&gt;以可互备为荣 ，以单点为耻&lt;br&gt;&lt;/center&gt;&lt;center&gt;&lt;br&gt;以可无状态为荣 ，以有状态为耻&lt;br&gt;&lt;/center&gt;&lt;center&gt;&lt;br&gt;以可随便重启为荣 ，以
      
    
    </summary>
    
      <category term="随笔" scheme="https://www.zhangqifei.top/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>ansible puppet saltstack三款自动化运维工具的对比！</title>
    <link href="https://www.zhangqifei.top/2017/08/10/linux/ansible%20puppet%20saltstack%E4%B8%89%E6%AC%BE%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4%E5%B7%A5%E5%85%B7%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <id>https://www.zhangqifei.top/2017/08/10/linux/ansible puppet saltstack三款自动化运维工具的对比/</id>
    <published>2017-08-10T06:41:22.000Z</published>
    <updated>2018-04-22T09:29:33.219Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、基础介绍"><a href="#一、基础介绍" class="headerlink" title="一、基础介绍"></a>一、基础介绍</h3><ul><li><a href="http://zhangqifei.top/2017/08/09/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7ansible/" target="_blank" rel="noopener">ansible基础介绍可参考</a></li><li><a href="http://zhangqifei.top/2017/08/07/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7puppet/" target="_blank" rel="noopener">puppet基础介绍可参考</a></li><li><a href="http://zhangqifei.top/2017/08/06/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7saltstack/" target="_blank" rel="noopener">saltstack基础介绍可参考</a></li></ul><h3 id="二、技术特性比较"><a href="#二、技术特性比较" class="headerlink" title="二、技术特性比较"></a>二、技术特性比较</h3><table><thead><tr><th>名称</th><th>Puppet</th><th>SaltStack</th><th>Ansible</th></tr></thead><tbody><tr><td>开发语言</td><td>Ruby</td><td>Python</td><td>Python</td></tr><tr><td>客户端</td><td>有</td><td>有</td><td>无</td></tr><tr><td>二次开发</td><td>不支持</td><td>支持</td><td>支持</td></tr><tr><td>通信验证</td><td>是</td><td>是</td><td>是</td></tr><tr><td>同学加密</td><td>标准SSL协议</td><td>AES加密</td><td>OpenSSH</td></tr><tr><td>平台支持</td><td>AIX,BSD,HP-UX,Linux,Mac OS X,Solaris,Windows</td><td>BSD,Linux,Mac OS X,Solaris,Windows</td><td>AIX,BSD,HP-UX,Linux,Mac OS X,Solaris</td></tr><tr><td>配置文件格式</td><td>Ruby语法格式</td><td>YAML</td><td>YAML</td></tr><tr><td>Web UI</td><td>提供</td><td>提供</td><td>提供（商业版本）</td></tr><tr><td>命令执行</td><td>不支持（配置模块可实现）</td><td>支持</td><td>支持</td></tr></tbody></table><h3 id="三、优缺点对比"><a href="#三、优缺点对比" class="headerlink" title="三、优缺点对比"></a>三、优缺点对比</h3><table><thead><tr><th>名称</th><th>优势</th><th>劣势</th><th>成本</th></tr></thead><tbody><tr><td>Puppet</td><td>模块由Ruby或Ruby子集编写<br>push命令可以即可触发变更<br>Web界面生成处理报表、资源清单、实时节点管理<br>代理运行端进行详细、深入的报告和对节点进行配置</td><td>相对其他工具较复杂，需学习Puppet的DSL或Ruby<br>安装过程缺少错误校验和产生错误报表</td><td>开源软件免费<br>SaltStack企业版每年内个节点花费约￥100</td></tr><tr><td>Saltstack</td><td>状态文件可用简单YAML配置模块或复杂的Python/PyDSL脚本<br>与客户端可以基于SSH或在被管节点安装代理<br>Web界面可看到运行的工作、minion状态、事件日志、可在客户端执行命令<br>扩展能力极强</td><td>Web界面像毒药竞争产品不稳定与相对不完善<br>缺乏生成深度报告的能力</td><td>开源软件免费<br>SaltStack企业版每年内个节点花费约￥150，随着数量增加相应的会有折扣</td></tr><tr><td>Ansible</td><td>模块可以用任何语言开发<br>备管节点不需要安装代理软件<br>有Web管理界面、可配置用户、组、资源清单和执行Playbook<br>安装、运行极其简单</td><td>对备管理节点为Windows有待加强<br>Web管理界面是内置的Ansible的一部分<br>需导入资源清单<br>执行效率较低</td><td>开源版本免费<br>Ansible Tower小于10台被管理节点免费<br>超过10太后没年每台需支付￥100~$250的支持服务费用</td></tr></tbody></table><h3 id="四、推荐场景"><a href="#四、推荐场景" class="headerlink" title="四、推荐场景"></a>四、推荐场景</h3><h4 id="4-1-Puppet"><a href="#4-1-Puppet" class="headerlink" title="4.1 Puppet"></a>4.1 Puppet</h4><p>　　Puppet也许是四款工具中最深入人心的。就可用操作、模块和用户界面而言，它是最全面的。Puppet呈现了数据中心协调的全貌，几乎涵盖每一个运行系统，为各大操作系统提供了深入的工具。初始设置比较简单，只需要在需要加以管理的每个系统上安装主服务器和客户端代理软件。</p><p>　　命令行接口(CLI)简单直观，允许通过puppet命令下载和安装模块。然后，需要对配置文件进行更改，好让模块适合所需的任务;应接到指令的客户端与主服务器联系时，会更改配置文件，或者客户端通过立即触发更改配置文件的推送(push)来进行更改。</p><p>　　还有一些模块可以提供和配置云服务器实例和虚拟服务器实例。所有模块和配置都使用基于Ruby的Puppet专属语言或者Ruby本身构建而成，因而除了系统管理技能外，还需要编程专业知识。</p><p>　　Puppet企业版拥有最全面的Web用户界面，允许使用主服务器上的预制模块和菜谱(cookbook)，实时控制被管理的节点。Web用户界面很适合用于管理，但是不允许对模块进行诸多配置。报告工具非常完善，提供了详细信息，以便了解代理软件运行如何、已做出什么样的变更。</p><h4 id="4-2-Ansible"><a href="#4-2-Ansible" class="headerlink" title="4.2 Ansible"></a>4.2 Ansible</h4><p>　　Ansible极其类似Salt，而不太类似Puppet或Chef。Ansible关注的重点是力求精简和快速，而且不需要在节点上安装代理软件。因此，Ansible通过SSH执行所有功能。Ansible基于Python;相比之下，Puppet和Chef基于Ruby。</p><p>　　Ansible可以通过Git软件库克隆，安装到Ansible主服务器上。安装完毕后，需要管理的节点被添加到Ansible配置环境，SSH授权密钥被附加到每个节点上，这与运行Ansible的用户有关。一旦完成了这步，Ansible主服务器可以通过SSH与节点进行通信，执行所有必要的任务。为了与默认情况下不允许根SSH访问的操作系统或发行版协同运行，Ansible接受sudo登录信息，以便在那些系统上以根用户的身份运行命令。</p><p>　　Ansible可以使用Paramiko(基于SSH2协议的Python实现)或标准SSH用于通信，不过还有一种加速模式，允许更快速、更大规模的通信。</p><p>　　针对确保服务在运行，或者触发更新和重新启动之类的简单任务，Ansible可以从命令行来运行，不需要使用配置文件。至于比较复杂的任务，Ansible配置通过名为Playbook的配置文件中的YAML语法来加以处理。Playbook还可以使用模板来扩展其功能。</p><p>　　Ansible有一大批模块，可用于管理各种系统以及亚马逊弹性计算云(EC2)和OpenStack等云计算基础设施。可以用几乎任何一种语言来编写自定义Ansible模块，只要模块输出是有效的JSON。</p><p>　　Ansible的Web用户界面以AnsibleWorks AWX的形式出现，但AWX与CLI并不直接联系在一起。这意味着，除非进行了同步过程，否则CLI里面的配置元素不会出现在Web用户界面中。你可以使用那个内置的同步工具，让两者保持一致，但需要按照预定计划运行同步工具。</p><h4 id="4-3-SaltStack"><a href="#4-3-SaltStack" class="headerlink" title="4.3 SaltStack"></a>4.3 SaltStack</h4><p>　　Salt类似Ansible，因为它也是基于CLI的工具，采用了推送方法实现客户端通信。它可以通过Git或通过程序包管理系统安装到主服务器和客户端上。客户端会向主服务器提出请求，请求在主服务器上得到接受后，就可以控制该客户端了。</p><p>　　Salt可以通过普通的SSH与客户端进行通信，但如果使用名为minion的客户端代理软件，可以大大增强可扩展性。此外，Salt含有一个异步文件服务器，可以为客户端加快文件服务速度，这完全是Salt注重高扩展性的一个体现。</p><p>　　与Ansible一样，你可以直接通过CLI，向客户端发出命令，比如启动服务或安装程序包;你也可以使用名为state的YAML配置文件，处理比较复杂的任务。还有“pillar”，这些是放在集中地方的数据集，YAML配置文件可以在运行期间访问它们。</p><p>　　你可以直接通过CLI，向客户端请求配置信息，比如内核版本或网络接口方面的详细信息。只要使用名为“grain”的库存元素，就可以描述客户端;这样一来，管理员可以轻松向某一种类型的服务器发出命令，不需要依赖已配置群组。比如说，只要使用一个CLI命令，你就可以向运行某个内核版本的每个客户端发送命令。</p><p>　　与Puppet、Chef和Ansible一样，Salt也提供了大量的模块，以处理特定的软件、操作系统和云服务。自定义模块可以用Python或PyDSL来编写。除了Unix管理外，Salt的确提供Windows管理功能，但它还是更擅长管理Unix和Linux系统。</p><p>　　Salt的Web用户界面Halite非常新，功能不如其他系统的Web用户界面来得全面。它提供了事件日志和客户端状态的视图，能够在客户端上运行命令，但除此之外乏善可陈。</p><p>　　Salt的较大优点在于可扩展性和弹性。你可以有多个级别的主服务器。上游主服务器可以控制下游主服务器及其客户端。另一个优点在于对等系统，让客户端可以向主服务器提出问题，然后主服务器从其他服务器得到答案，提供全面信息。如果需要在实时数据库中查询数据，以便完成客户端的配置，这个优点就很方便。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、基础介绍&quot;&gt;&lt;a href=&quot;#一、基础介绍&quot; class=&quot;headerlink&quot; title=&quot;一、基础介绍&quot;&gt;&lt;/a&gt;一、基础介绍&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://zhangqifei.top/2017/08/09/linux/
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
      <category term="运维自动化工具" scheme="https://www.zhangqifei.top/categories/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>运维自动化工具ansible</title>
    <link href="https://www.zhangqifei.top/2017/08/09/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7ansible/"/>
    <id>https://www.zhangqifei.top/2017/08/09/linux/运维自动化工具ansible/</id>
    <published>2017-08-09T12:42:22.000Z</published>
    <updated>2018-04-22T09:29:32.834Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>ansible是一个基于python开发的轻量级自动化运维管理工具，可以用来批量执行命令，安装程序，支持playbook编排。它通过ssh协议来连接主机，去中心化，相对比puppet和saltstack无需安装客户即可实现文件传输、命令执行、应用部署、配置管理、任务编排等，显得更为简单与轻量。ansible只是提供一种框架，其基于模块工作的，本身没有批量部署。</p><h3 id="企业级自动化运维工具应用实战ansible"><a href="#企业级自动化运维工具应用实战ansible" class="headerlink" title="企业级自动化运维工具应用实战ansible"></a>企业级自动化运维工具应用实战ansible</h3><p>公司计划在年底做一次大型市场促销活动，全面冲刺下交易额，为明年的上市做准备。公司要求各业务组对年底大促做准备，运维部要求所有业务容量进行三倍的扩容，并搭建出多套环境可以共开发和测试人员做测试，运维老大为了在年底有所表现，要求运维部门同学尽快实现，当你接到这个任务时，有没有更快的解决方案？</p><h3 id="Ansible发展史"><a href="#Ansible发展史" class="headerlink" title="Ansible发展史"></a>Ansible发展史</h3><p>Ansible</p><ul><li>创始人，Michael DeHaan（Cobbler 与Func 的作者）</li><li>2012-03-09，发布0.0.1版，红帽收购</li><li>2015-10-17，Red Hat宣布收购（据说是1.5 亿美元）</li></ul><p><strong>同类自动化工具GitHub关注程度（2016-07-10）</strong></p><table><thead><tr><th>同类的自动化运维工具</th><th>Watch（关注）</th><th>Star（点赞）</th><th>Fork（复制）</th><th>Contributors(贡献者)</th></tr></thead><tbody><tr><td>Ansible</td><td>1387</td><td>17716</td><td>5356</td><td>1428</td></tr><tr><td>Saltstack</td><td>530</td><td>6678</td><td>3002</td><td>1520</td></tr><tr><td>Puppet</td><td>463</td><td>4044</td><td>1678</td><td>425</td></tr><tr><td>Chef</td><td>383</td><td>4333</td><td>1806</td><td>464</td></tr><tr><td>Fabric</td><td>379</td><td>7334</td><td>1235</td><td>116</td></tr></tbody></table><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul><li>模块化：调用特定的模块，完成特定任务</li><li>有Paramiko，PyYAML，Jinja2（模板语言）三个关键模块</li><li>支持自定义模块</li><li>基于Python语言实现</li><li>部署简单，基于python和SSH(默认已安装)，agentless</li><li>安全，基于OpenSSH</li><li>支持playbook编排任务</li><li>幂等性：一个任务执行1遍和执行n遍效果一样，不因重复执行带来意外情况</li><li>无需代理不依赖PKI（无需ssl）</li><li>可使用任何编程语言写模块</li><li>YAML格式，编排任务，支持丰富的数据结构</li><li>较强大的多层解决方案</li></ul><h3 id="ansible架构"><a href="#ansible架构" class="headerlink" title="ansible架构"></a>ansible架构</h3><center><img src="http://zhangqifei.top/picture/ansible/4.png" alt="ansible架构"></center><h3 id="Ansible工作原理"><a href="#Ansible工作原理" class="headerlink" title="Ansible工作原理"></a>Ansible工作原理</h3><p><center><img src="http://zhangqifei.top/picture/ansible/5.png" alt="Ansible工作原理"></center></p><ul><li>ANSIBLE PLAYBOOKS：任务剧本（任务集），编排定义Ansible任务集的配置文件，由Ansible顺序依次执行，通常是JSON格式的YML文件</li><li>INVENTORY：Ansible管理主机的清单/etc/anaible/hosts</li><li>MODULES：Ansible执行命令的功能模块，多数为内置的核心模块，也可自定义</li><li>PLUGINS：模块功能的补充，如连接类型插件、循环插件、变量插件、过滤插件等，该功能不常用</li><li>API：供第三方程序调用的应用程序编程接口</li><li>ANSIBLE：组合INVENTORY、API、MODULES、PLUGINS的绿框，可以理解为是ansible命令工具，其为核心执行工具</li></ul><p><strong>Ansible命令执行来源：</strong></p><ul><li>USER，普通用户，即SYSTEM ADMINISTRATOR</li><li>CMDB（配置管理数据库）API 调用</li><li>PUBLIC/PRIVATE CLOUD API调用</li><li>USER-&gt; Ansible Playbook -&gt; Ansibile</li></ul><p><strong>利用ansible实现管理的方式：</strong></p><ul><li>Ad-Hoc 即ansible命令，主要用于临时命令使用场景</li><li>Ansible-playbook 主要用于长期规划好的，大型项目的场景，需要有前提的规划</li></ul><p><strong>Ansible-playbook（剧本）执行过程：</strong></p><ul><li>将已有编排好的任务集写入Ansible-Playbook</li><li>通过ansible-playbook命令分拆任务集至逐条ansible命令，按预定规则逐条执行</li></ul><p><strong>Ansible主要操作对象：</strong></p><ul><li>HOSTS主机</li><li>NETWORKING网络设备</li></ul><p><strong>注意事项</strong></p><ul><li>执行ansible的主机一般称为主控端，中控，master或堡垒机主控端Py:   thon版本需要2.6或以上</li><li>被控端Python版本小于2.4需要安装python-simplejson</li><li>被控端如开启SELinux需要安装libselinux-python</li><li>windows不能做为主控端</li></ul><h3 id="ansible安装-四种方式"><a href="#ansible安装-四种方式" class="headerlink" title="ansible安装(四种方式)"></a>ansible安装(四种方式)</h3><ul><li>rpm包安装: EPEL源<code>yum install ansible</code></li><li>编译安装:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">yum -y install python-jinja2 PyYAML python-paramiko </span><br><span class="line">python-babel python-crypto</span><br><span class="line">tar xf ansible-1.5.4.tar.gz</span><br><span class="line">cd ansible-1.5.4</span><br><span class="line">python setup.py build</span><br><span class="line">python setup.py install</span><br><span class="line">mkdir /etc/ansible</span><br><span class="line">cp -r examples/* /etc/ansible</span><br></pre></td></tr></table></figure><ul><li>Git方式安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone git://github.com/ansible/ansible.git --recursive</span><br><span class="line">cd ./ansible</span><br><span class="line">source ./hacking/env-setup</span><br></pre></td></tr></table></figure><ul><li>pip安装：pip是安装Python包的管理器，类似yum</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install python-pip python-devel</span><br><span class="line">yum install gcc glibc-devel zibl-devel rpm-bulid openssl-devel</span><br><span class="line">pip install  --upgrade pip</span><br><span class="line">pip install ansible--upgrade</span><br></pre></td></tr></table></figure><ul><li>确认安装：<code>ansible --version</code></li></ul><h3 id="相关文件"><a href="#相关文件" class="headerlink" title="相关文件"></a>相关文件</h3><p><strong>配置文件</strong><br><code>/etc/ansible/ansible.cfg</code> 主配置文件，配置ansible工作特性<br><code>/etc/ansible/hosts</code> 主机清单<br><code>/etc/ansible/roles/</code> 存放角色的目录</p><p><strong>程序</strong><br><code>/usr/bin/ansible</code> 主程序，临时命令执行工具<br><code>/usr/bin/ansible-doc</code> 查看配置文档，模块功能查看工具<br><code>/usr/bin/ansible-galaxy</code> 下载/上传优秀代码或Roles模块的官网平台<br><code>/usr/bin/ansible-playbook</code> 定制自动化任务，编排剧本工具<br><code>/usr/bin/ansible-pull</code> 远程执行命令的工具<br><code>/usr/bin/ansible-vault</code>  文件加密工具<br><code>/usr/bin/ansible-console</code>  基于Console界面与用户交互的执行工具</p><h4 id="主机清单inventory"><a href="#主机清单inventory" class="headerlink" title="主机清单inventory"></a>主机清单inventory</h4><ul><li>ansible的主要功用在于批量主机操作，为了便捷地使用其中的部分主机，可以在inventory file中将其分组命名</li><li>默认的inventory file为<code>/etc/ansible/hosts</code></li><li>inventory file可以有多个，且也可以通过Dynamic Inventory来动态生成</li></ul><p><strong><code>/etc/ansible/hosts</code>文件格式</strong><br>inventory文件遵循INI文件风格，中括号中的字符为组名。可以将同一个主机同时归并到多个不同的组中；此外，当如若目标主机使用了非默认的SSH端口，还可以在主机名称之后使用冒号加端口号来标明<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">例：</span><br><span class="line">[root@centos7 ~]#vim /etc/ansible/hosts</span><br><span class="line">[web]</span><br><span class="line">192.168.109.100</span><br><span class="line">192.168.109.2</span><br><span class="line"></span><br><span class="line">[db]</span><br><span class="line">192.168.109.3</span><br><span class="line">192.168.109.100 //这里默认有个all</span><br><span class="line">[root@centos7 ~]#ansible db -m ping       </span><br><span class="line">192.168.109.100 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br><span class="line">192.168.109.3 | SUCCESS =&gt; &#123;</span><br><span class="line">    &quot;changed&quot;: false, </span><br><span class="line">    &quot;ping&quot;: &quot;pong&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果主机名称遵循相似的命名模式，还可以使用列表的方式标识各主机<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[websrvs]</span><br><span class="line">www[01:100].example.com</span><br><span class="line"></span><br><span class="line">[dbsrvs]</span><br><span class="line">db-[a:f].example.com</span><br></pre></td></tr></table></figure></p><h3 id="ansible-配置文件"><a href="#ansible-配置文件" class="headerlink" title="ansible 配置文件"></a>ansible 配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ansible 配置文件/etc/ansible/ansible.cfg （一般保持默认）</span><br><span class="line">[defaults]</span><br><span class="line">#inventory      = /etc/ansible/hosts  # 主机列表配置文件</span><br><span class="line">#library        = /usr/share/my_modules/ # 库文件存放目录</span><br><span class="line">#remote_tmp     = $HOME/.ansible/tmp #临时py命令文件存放在远程主机目录</span><br><span class="line">#local_tmp      = $HOME/.ansible/tmp # 本机的临时命令执行目录</span><br><span class="line">#forks          = 5   # 默认并发数</span><br><span class="line">#sudo_user      = root  # 默认sudo 用户</span><br><span class="line">#ask_sudo_pass  = True  #每次执行ansible命令是否询问ssh密码</span><br><span class="line">#ask_pass       = True   </span><br><span class="line">#remote_port    = 22</span><br><span class="line">#host_key_checking = False  #检查对应服务器的host_key，建议取消注释第一次连接不用输入yes</span><br><span class="line">#log_path = /var/log/ansible.log 生成日志文件</span><br></pre></td></tr></table></figure><h3 id="ansible系列命令"><a href="#ansible系列命令" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Ansible系列命令</span><br><span class="line">ansible    ansible-doc    ansible-playbook    ansible-vault ansible-console    ansible-galaxy    ansible-pull </span><br><span class="line"></span><br><span class="line">ansible-doc:显示模块帮助</span><br><span class="line">ansible-doc [options] [module...]</span><br><span class="line">-a              显示所有模块的文档</span><br><span class="line">-l, --list      列出可用模块</span><br><span class="line">-s, --snippet   显示指定模块的playbook片段</span><br><span class="line">示例：</span><br><span class="line">ansible-doc –l       列出所有模块</span><br><span class="line">ansible-doc ping     查看指定模块帮助用法</span><br><span class="line">ansible-doc –s  ping 查看指定模块帮助用法</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ansible通过ssh实现配置管理、应用部署、任务执行等功能，建议配置ansible端能基于密钥认证的方式联系各被管理节点</span><br><span class="line"></span><br><span class="line">ansible &lt;host-pattern&gt; [-m module_name] [-a args] </span><br><span class="line">--version           显示版本</span><br><span class="line">-m module           指定模块，默认为command</span><br><span class="line">-v                  详细过程–vv-vvv更详细</span><br><span class="line">--list-hosts        显示主机列表，可简写—list</span><br><span class="line">-k, --ask-pass      提示连接密码，默认Key验证</span><br><span class="line">-K, --ask-become-pass  提示输入sudo</span><br><span class="line">-C, --check            检查，并不执行</span><br><span class="line">-T, --timeout=TIMEOUT  执行命令的超时时间，默认10s</span><br><span class="line">-u, --user=REMOTE_USER 执行远程执行的用户</span><br><span class="line">-b, --become           代替旧版的sudo切换</span><br><span class="line"></span><br><span class="line">ansible的Host-pattern</span><br><span class="line">    匹配主机的列表</span><br><span class="line">    All ：表示所有Inventory中的所有主机</span><br><span class="line">        ansible all –m ping </span><br><span class="line">    *  :通配符</span><br><span class="line">        ansible &quot;*&quot; -m ping </span><br><span class="line">        ansible 192.168.1.* -m ping</span><br><span class="line">        ansible &quot;*srvs&quot;  -m ping</span><br><span class="line">    或关系</span><br><span class="line">        ansible &quot;websrvs:appsrvs&quot;  -m ping</span><br><span class="line">        ansible &quot;192.168.1.10:192.168.1.20&quot; -m ping</span><br><span class="line">    逻辑与</span><br><span class="line">        ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping</span><br><span class="line">        在websrvs组并且在dbsrvs组中的主机</span><br><span class="line">    逻辑非</span><br><span class="line">        ansible &apos;websrvs:!dbsrvs&apos; –m ping</span><br><span class="line">        在websrvs组，但不在dbsrvs组中的主机</span><br><span class="line">    综合逻辑</span><br><span class="line">        ansible &apos;websrvs:dbsrvs:&amp;appsrvs:!ftpsrvs&apos; –m ping</span><br><span class="line">    正则表达式</span><br><span class="line">        ansible &quot;websrvs:&amp;dbsrvs&quot; –m ping</span><br><span class="line">        ansible &quot;~(web|db).*\.magedu\.com&quot; –m ping</span><br></pre></td></tr></table></figure><h3 id="ansible命令执行过程"><a href="#ansible命令执行过程" class="headerlink" title="ansible命令执行过程"></a>ansible命令执行过程</h3><p>ansible命令执行过程<code>ansible all -m command -a &#39;ls /root&#39;</code></p><ol><li>加载自己的配置文件默认<code>/etc/ansible/ansible.cfg</code></li><li>加载自己对应的模块文件，如command</li><li>通过ansible将模块或命令生成对应的临时py文件，并将该文件传输至远程服务器的对应执行用户<code>$HOME/.ansible/tmp/ansible-tmp-数字/XXX.PY文件</code></li><li>给文件+x执行</li><li>执行并返回结果</li><li>删除临时py文件，sleep 0退出</li></ol><p>执行状态：<br>绿色：执行成功并且不需要做改变的操作<br>黄色：执行成功并且对目标主机做变更<br>红色：执行失败</p><h4 id="ansible使用示例"><a href="#ansible使用示例" class="headerlink" title="ansible使用示例"></a>ansible使用示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">以wang用户执行ping存活检测</span><br><span class="line">ansible all -m ping -u wang -k</span><br><span class="line">以wang sudo至root执行ping存活检测</span><br><span class="line">ansible all -m ping -u wang –b -k</span><br><span class="line">以wangsudo至mage用户执行ping存活检测</span><br><span class="line">ansible all -m ping -u wang –b -k --become-user mage</span><br><span class="line">以wang sudo至root用户执行ls</span><br><span class="line">ansible all -m command -u wang--become-user=root -a &apos;ls/root&apos; -b –k -K</span><br></pre></td></tr></table></figure><h3 id="ansible常用模块"><a href="#ansible常用模块" class="headerlink" title="ansible常用模块"></a>ansible常用模块</h3><h4 id="Command：在远程主机执行命令，默认模块，可忽略-m选项"><a href="#Command：在远程主机执行命令，默认模块，可忽略-m选项" class="headerlink" title="Command：在远程主机执行命令，默认模块，可忽略-m选项"></a>Command：在远程主机执行命令，默认模块，可忽略-m选项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令：</span><br><span class="line">chdir：    ＃运行该命令之前，切换到该目录。</span><br><span class="line">creates：  ＃一个文件当它已经存在时，这个步骤将不运行。</span><br><span class="line"></span><br><span class="line">ansible srvs -m command -a &apos;service vsftpd start&apos; </span><br><span class="line">ansible srvs -m command -a &apos;echo magedu |passwd --stdin wang&apos;   不成功此命令不支持$VARNAME &lt; &gt; | ;&amp; 等，用shell模块实现</span><br></pre></td></tr></table></figure><h4 id="Shell：和command相似，用shell执行命令"><a href="#Shell：和command相似，用shell执行命令" class="headerlink" title="Shell：和command相似，用shell执行命令"></a>Shell：和command相似，用shell执行命令</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m shell -a &apos;echo xxxxx |passwd –stdin wang&apos; </span><br><span class="line">调用bash执行命令类似cat /tmp/stanley.md | awk -F&apos;|&apos; &apos;&#123;print $1,$2&#125;&apos; &amp;&gt; /tmp/example.txt这些复杂命令，即使使用shell也可能会失败，解决办法：写到脚本时，copy到远程，执行，再把需要的结果拉回执行命令的机器</span><br><span class="line">[root@centos7 ~]#ansible all -m shell -a &apos;echo $HOSTNAME&apos;</span><br><span class="line">192.168.109.100 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">centos7.magedu.com</span><br><span class="line">192.168.109.2 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">centos7</span><br><span class="line">192.168.109.3 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">centos6.9</span><br></pre></td></tr></table></figure><h4 id="Script：运行脚本"><a href="#Script：运行脚本" class="headerlink" title="Script：运行脚本"></a>Script：运行脚本</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f1.sh</span><br><span class="line">hostname</span><br><span class="line">date .... 定义了一些脚本等</span><br><span class="line"></span><br><span class="line">snsible websrvs -m script -a &apos;f1.sh&apos;</span><br></pre></td></tr></table></figure><h4 id="Copy-从服务器复制文件到客户端"><a href="#Copy-从服务器复制文件到客户端" class="headerlink" title="Copy:从服务器复制文件到客户端,"></a>Copy:从服务器复制文件到客户端,</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m copy -a &quot;src=/root/f1.sh dest=/tmp/f2.sh    owner=wang mode=600 backup=yes&quot; </span><br><span class="line">如目标存在，默认覆盖，此处指定先备份</span><br><span class="line"></span><br><span class="line">ansible srv -m copy -a &quot;content=&apos;test content\n&apos; dest=/tmp/f1.txt&quot; 利用内容，直接生成目标文件</span><br></pre></td></tr></table></figure><h4 id="cron：计划任务"><a href="#cron：计划任务" class="headerlink" title="cron：计划任务"></a>cron：计划任务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">支持时间：minute，hour，day，month，weekday</span><br><span class="line">ansible srv -m cron -a &quot;minute=*/5 job=&apos;/usr/bin/ntpdate 172.16.0.1 &amp;&gt;/dev/null&apos; name=Synctime&quot; 创建任务</span><br><span class="line">ansible srv -a &apos;crontab -l&apos; 查看任务</span><br><span class="line">ansible srv -m cron -a &apos;state=absent name=Synctime&apos;  删除任务</span><br><span class="line">计划任务目录路径 /var/spool/cron/root</span><br><span class="line">ansible srv -m cron -a &apos;disabled=yes job=&quot;/usr/bin/ntpdate 172.16.0.1 &amp;&gt;/dev/null&quot; name=Synctime&apos;</span><br><span class="line">disables=yes 前面加上注释 no的话取消注释</span><br></pre></td></tr></table></figure><h4 id="fetch-从客户端取文件至服务器端，copy相反，目录可先tar"><a href="#fetch-从客户端取文件至服务器端，copy相反，目录可先tar" class="headerlink" title="fetch:从客户端取文件至服务器端，copy相反，目录可先tar"></a>fetch:从客户端取文件至服务器端，copy相反，目录可先tar</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m fetch -a &apos;src=/root/a.sh dest=/data/scripts&apos;</span><br></pre></td></tr></table></figure><h4 id="file：设置文件属性"><a href="#file：设置文件属性" class="headerlink" title="file：设置文件属性"></a>file：设置文件属性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m file -a &quot;path=/root/a.sh state=touch owner=wang mode=755&quot; //创建空文件 并设置权限等</span><br><span class="line"></span><br><span class="line">ansible web -m file -a &apos;src=/app/testfile  dest=/app/testfile-link state=link&apos; //创建软连接</span><br></pre></td></tr></table></figure><h4 id="hostname：管理主机名"><a href="#hostname：管理主机名" class="headerlink" title="hostname：管理主机名"></a>hostname：管理主机名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ansible web -m hostname -a &quot;name=websrv&quot;</span><br></pre></td></tr></table></figure><h4 id="yum：管理包"><a href="#yum：管理包" class="headerlink" title="yum：管理包"></a>yum：管理包</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m yum -a &apos;name=httpd state=latest&apos;  安装</span><br><span class="line">ansible srv -m yum -a &apos;name=httpd,tftp state=latest&apos;  安装多个</span><br><span class="line">ansible srv -m yum -a &apos;name=httpd state=latest update_cache=yes&apos;  </span><br><span class="line">update_cache=yes 相当于yum clean all</span><br><span class="line">ansible srv -m yum -a &apos;name=httpd state=absent&apos;  删除</span><br></pre></td></tr></table></figure><h4 id="service：管理服务"><a href="#service：管理服务" class="headerlink" title="service：管理服务"></a>service：管理服务</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m service -a &apos;name=httpd state=stopped enabled=yes&apos;关闭并且设置开机启动 不支持多个命令</span><br><span class="line">ansible srv -m service -a &apos;name=httpd state=started&apos;启动</span><br><span class="line">ansible srv –m service –a &apos;name=httpd state=reloaded&apos;</span><br><span class="line">ansible srv -m service -a &apos;name=httpd state=restarted&apos;重启</span><br></pre></td></tr></table></figure><h4 id="user：管理用户"><a href="#user：管理用户" class="headerlink" title="user：管理用户"></a>user：管理用户</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m user -a &apos;name=user1 comment=&quot;test user&quot; uid=2048 home=/app/user1 group=root&apos;创建普通用户</span><br><span class="line">ansible srv -m user -a &apos;name=sysuser1 system=yes home=/app/sysuser1 &apos;创建系统用户</span><br><span class="line">ansible srv -m user -a &apos;name=user1 state=absent remove=yes&apos; 删除用户及家目录等数据</span><br></pre></td></tr></table></figure><h4 id="Group：管理组"><a href="#Group：管理组" class="headerlink" title="Group：管理组"></a>Group：管理组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible srv -m group -a &quot;name=testgroup system=yes&quot;</span><br><span class="line">ansible srv -m group -a &quot;name=testgroup state=absent&quot;</span><br></pre></td></tr></table></figure><h3 id="ansible系列命令-1"><a href="#ansible系列命令-1" class="headerlink" title="ansible系列命令"></a>ansible系列命令</h3><h4 id="ansible-galaxy"><a href="#ansible-galaxy" class="headerlink" title="ansible-galaxy"></a>ansible-galaxy</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">连接https://galaxy.ansible.com 下载相应的roles</span><br><span class="line">中文 http://www.ansible.com.cn/index.html</span><br><span class="line"></span><br><span class="line">列出所有已安装的galaxy </span><br><span class="line">    ansible-galaxy list</span><br><span class="line">安装galaxy</span><br><span class="line">    ansible-galaxy install geerlingguy.redis</span><br><span class="line">删除galaxy</span><br><span class="line">    ansible-galaxy remove geerlingguy.redis</span><br></pre></td></tr></table></figure><h4 id="ansible-pull"><a href="#ansible-pull" class="headerlink" title="ansible-pull"></a>ansible-pull</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ansible-pull</span><br><span class="line">推送命令至远程，效率无限提升，对运维要求较高</span><br></pre></td></tr></table></figure><h4 id="Ansible-playbook"><a href="#Ansible-playbook" class="headerlink" title="Ansible-playbook"></a>Ansible-playbook</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ansible-playbook hello.yml</span><br><span class="line">例子：</span><br><span class="line">vim hello.yml</span><br><span class="line">- hosts: test</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">  - name: hello world </span><br><span class="line">    command: wall &quot;hello world&quot;</span><br></pre></td></tr></table></figure><h4 id="Ansible-vault"><a href="#Ansible-vault" class="headerlink" title="Ansible-vault"></a>Ansible-vault</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">功能：管理加密解密yml文件</span><br><span class="line">    ansible-vault [create|decrypt|edit|encrypt|rekey|view]</span><br><span class="line">    ansible-vault encrypt hello.yml 加密</span><br><span class="line">    ansible-vault decrypt hello.yml 解密</span><br><span class="line">    ansible-vault view hello.yml 查看</span><br><span class="line">    ansible-vault edit hello.yml 编辑加密文件</span><br><span class="line">    ansible-vault rekey hello.yml 修改口令</span><br><span class="line">    ansible-vault create new.yml 创建新文件</span><br></pre></td></tr></table></figure><h4 id="Ansible-console"><a href="#Ansible-console" class="headerlink" title="Ansible-console"></a>Ansible-console</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Ansible-console：2.0+新增，可交互执行命令，支持tab</span><br><span class="line">    root@test(2)[f:10] $</span><br><span class="line">        执行用户@当前操作的主机组(当前组的主机数量)[f:并发数]$</span><br><span class="line">    设置并发数：forks n  例如：forks 10</span><br><span class="line">    切换组：cd 主机组例如：cd web</span><br><span class="line">    列出当前组主机列表：list</span><br><span class="line">    列出所有的内置命令：?或help</span><br><span class="line">示例：</span><br><span class="line">root@all (2)[f:5]$ list</span><br><span class="line">root@all (2)[f:5]$ cd appsrvs</span><br><span class="line">root@appsrvs (2)[f:5]$ list </span><br><span class="line">root@appsrvs(2)[f:5]$ yum name=httpd state=present</span><br><span class="line">root@appsrvs(2)[f:5]$ service name=httpd state=started</span><br></pre></td></tr></table></figure><h3 id="playbook"><a href="#playbook" class="headerlink" title="playbook"></a>playbook</h3><ul><li>playbook是由一个或多个“play”组成的列表</li><li>play的主要功能在于将事先归并为一组的主机装扮成事先通过ansible中的task定义好的角色。从根本上来讲，所谓task无非是调用ansible的一个module。将多个play组织在一个playbook中，即可以让它们联同起来按事先编排的机制同唱一台大戏</li><li>Playbook采用YAML语言编写</li></ul><p><center><img src="http://zhangqifei.top/picture/ansible/6.png" alt="playbook"></center></p><h4 id="YAML介绍"><a href="#YAML介绍" class="headerlink" title="YAML介绍"></a>YAML介绍</h4><ul><li>YAML是一个可读性高的用来表达资料序列的格式。YAML参考了其他多种语言，包括：XML、C语言、Python、Perl以及电子邮件格式RFC2822等。Clark Evans在2001年在首次发表了这种语言，另外IngydötNet与Oren Ben-Kiki也是这语言的共同设计者</li><li>YAML Ain’tMarkup Language，即YAML不是XML。不过，在开发的这种语言时，YAML的意思其实是：”Yet Another Markup Language”（仍是一种标记语言）</li><li>特性<ul><li>YAML的可读性好</li><li>YAML和脚本语言的交互性好</li><li>YAML使用实现语言的数据类型</li><li>YAML有一个一致的信息模型</li><li>YAML易于实现</li><li>YAML可以基于流来处理</li><li>YAML表达能力强，扩展性好</li></ul></li></ul><p>更多的内容及规范参见<a href="http://www.yaml.org" target="_blank" rel="noopener">http://www.yaml.org</a></p><h4 id="YAML语法简介"><a href="#YAML语法简介" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h4><ul><li>在单一档案中，可用连续三个连字号(——)区分多个档案。另外，还有选择性的连续三个点号( … )用来表示档案结尾</li><li>次行开始正常写Playbook的内容，一般建议写明该Playbook的功能</li><li>使用#号注释代码</li><li>缩进必须是统一的，不能空格和tab混用</li><li>缩进的级别也必须是一致的，同样的缩进代表同样的级别，程序判别配置的级别是通过缩进结合换行来实现的</li><li>YAML文件内容和Linux系统大小写判断方式保持一致，是区别大小写的，k/v的值均需大小写敏感</li><li>k/v的值可同行写也可换行写。同行使用:分隔</li><li>v可是个字符串，也可是另一个列表一个完整的代码块功能需最少元素需包括name: task</li><li>一个name只能包括一个task</li><li>YAML文件扩展名通常为yml或yaml</li></ul><h5 id="YAML语法简介-1"><a href="#YAML语法简介-1" class="headerlink" title="YAML语法简介"></a>YAML语法简介</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dictionary：字典，通常由多个key与value构成</span><br><span class="line">示例：</span><br><span class="line">---</span><br><span class="line"># An employee record</span><br><span class="line">name: Example Developer</span><br><span class="line">job: Developers</span><br><span class="line">kill: Elite</span><br><span class="line">也可以将key:value放置于&#123;&#125;中进行表示，用,分隔多个key:value</span><br><span class="line">示例：</span><br><span class="line">---</span><br><span class="line"># An employee record</span><br><span class="line">&#123;name: Example Developer, job: Developer, skill: Elite&#125;</span><br></pre></td></tr></table></figure><h3 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h3><p>YAML的语法和其他高阶语言类似，并且可以简单表达清单、散列表、标量等数据结构。其结构（Structure）通过空格来展示，序列（Sequence）里的项用”-“来代表，Map里的键值对用”:”分隔<br>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">name: John Smith</span><br><span class="line">age: 41</span><br><span class="line">gender: Male</span><br><span class="line">spouse:</span><br><span class="line">  name: Jane Smith</span><br><span class="line">  age: 37</span><br><span class="line">  gender: Female</span><br><span class="line">children:</span><br><span class="line">  - name: Jimmy Smith</span><br><span class="line">    age: 17</span><br><span class="line">    gender: Male</span><br><span class="line">  - name: Jenny Smith</span><br><span class="line">    age 13</span><br><span class="line">    gender: Female</span><br></pre></td></tr></table></figure></p><h3 id="Playbook核心元素"><a href="#Playbook核心元素" class="headerlink" title="Playbook核心元素"></a>Playbook核心元素</h3><ul><li>Hosts      执行的远程主机列表</li><li>Tasks      任务集</li><li>Varniables 内置变量或自定义变量在playbook中调用</li><li>Templates  模板，可替换模板文件中的变量并实现一些简单逻辑的文件</li><li>Handlers   和notity结合使用，由特定条件触发的操作，满足条件方才执行，否则不执行</li><li>tags       标签指定某条任务执行，用于选择运行playbook中的部分代码。ansible具有幂等性，因此会自动跳过没有变化的部分，即便如此，有些代码为测试其确实没有发生变化的时间依然会非常地长。此时，如果确信其没有变化，就可以通过tags跳过此些代码片断<code>ansible-playbook –t tagsname useradd.yml</code><br>示例:安装httpd 并且开机启动<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">vim test1.yml</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: install package</span><br><span class="line">      yum: name=httpd start=present</span><br><span class="line">    - name: start service</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">      </span><br><span class="line">ansible-playbook test1.yml 执行</span><br></pre></td></tr></table></figure></li></ul><h5 id="playbook基础组件"><a href="#playbook基础组件" class="headerlink" title="playbook基础组件"></a>playbook基础组件</h5><ul><li>Hosts：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">playbook中的每一个play的目的都是为了让某个或某些主机以某个指定的用户身份执行任务。hosts用于指定要执行指定任务的主机，须事先定义在主机清单中</span><br><span class="line">可以是如下形式：</span><br><span class="line">one.example.com</span><br><span class="line">one.example.com:two.example.com</span><br><span class="line">192.168.1.50</span><br><span class="line">192.168.1.*</span><br><span class="line"></span><br><span class="line">Websrvs:dbsrvs两个组的并集</span><br><span class="line">Websrvs:&amp;dbsrvs两个组的交集</span><br><span class="line">webservers:!phoenix  在websrvs组，但不在dbsrvs组</span><br><span class="line">示例:-hosts: websrvs：dbsrvs</span><br></pre></td></tr></table></figure><ul><li>remote_user: </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">可用于Host和task中。也可以通过指定其通过sudo的方式在远程主机上执行任务，其可用于play全局或某任务；此外，甚至可以在sudo时使用sudo_user指定sudo时切换的用户</span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    -name: test connection</span><br><span class="line">    ping: </span><br><span class="line">    remote_user: magedu</span><br><span class="line">    sudo: yes       默认sudo为root</span><br><span class="line">    sudo_user:wang  sudo为wang</span><br></pre></td></tr></table></figure><ul><li>task列表和action</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">play的主体部分是task list。task list中的各任务按次序逐个在hosts中指定的所有主机上执行，即在所有主机上完成第一个任务后再开始第二个。在运行自下而下某playbook时，如果中途发生错误，所有已执行任务都将回滚，因此，在更正playbook后重新执行一次即可</span><br><span class="line"></span><br><span class="line">task的目的是使用指定的参数执行模块，而在模块参数中可以使用变量。模块执行是幂等的，这意味着多次执行是安全的，因为其结果均一致</span><br><span class="line"></span><br><span class="line">每个task都应该有其name，用于playbook的执行结果输出，建议其内容尽可能清晰地描述任务执行步骤。如果未提供name，则action的结果将用于输出</span><br></pre></td></tr></table></figure><ul><li>tasks：任务列表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">格式：</span><br><span class="line">    (1) action: module arguments</span><br><span class="line">    (2) module: arguments 建议使用</span><br><span class="line">    注意：shell和command模块后面跟命令，而非key=value</span><br><span class="line">某任务的状态在运行后为changed时，可通过“notify&quot;通知给相应的handlers</span><br><span class="line">任务可以通过&quot;tags&quot;打标签，而后可在ansible-playbook命令上使用-t指定进行调用</span><br><span class="line">示例：</span><br><span class="line">tasks:</span><br><span class="line">  - name: disable selinux</span><br><span class="line">    command: /sbin/setenforce 0</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">如果命令或脚本的退出码不为零，可以使用如下方式替代</span><br><span class="line">tasks:</span><br><span class="line">  - name: run this command and ignore the result</span><br><span class="line">    shell: /usr/bin/somecommand|| /bin/true</span><br><span class="line"></span><br><span class="line">或者使用ignore_errors来忽略错误信息：</span><br><span class="line">tasks:</span><br><span class="line">  - name: run this command and ignore the result</span><br><span class="line">    shell: /usr/bin/somecommand</span><br><span class="line">    ignore_errors: True</span><br><span class="line">    </span><br><span class="line">运行playbook的方式</span><br><span class="line">    ansible-playbook &lt;filename.yml&gt; ... [options]</span><br><span class="line">常见选项</span><br><span class="line">    --check 只检测可能会发生的改变，但不真正执行操作</span><br><span class="line">    --list-hosts 列出运行任务的主机</span><br><span class="line">    --limit 主机列表只针对主机列表中的主机执行</span><br><span class="line">    -v 显示过程-vv-vvv更详细</span><br><span class="line">示例</span><br><span class="line">    ansible-playbook  file.yml --check 只检测</span><br><span class="line">    ansible-playbook  file.yml </span><br><span class="line">    ansible-playbook  file.yml --limit websrvs</span><br></pre></td></tr></table></figure><h4 id="Playbook-VS-ShellScripts"><a href="#Playbook-VS-ShellScripts" class="headerlink" title="Playbook VS ShellScripts"></a>Playbook VS ShellScripts</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">SHELL脚本</span><br><span class="line">#!/bin/bash</span><br><span class="line"># 安装Apache</span><br><span class="line">yum install --quiet -y httpd</span><br><span class="line"># 复制配置文件</span><br><span class="line">cp /path/to/config/httpd.conf /etc/httpd/conf/httpd.conf</span><br><span class="line">cp /path/to/httpd-vhosts.conf /etc/httpd/conf/httpd-vhosts.conf</span><br><span class="line"># 启动Apache，并设置开机启动</span><br><span class="line">service httpd start </span><br><span class="line">chkconfig httpd on</span><br><span class="line"></span><br><span class="line">Playbook定义</span><br><span class="line">---</span><br><span class="line">  - hosts: all</span><br><span class="line">    tasks: </span><br><span class="line">      - name: &quot;安装Apache&quot;</span><br><span class="line">        command: yum install -q -y httpd</span><br><span class="line">      - name: &quot;复制配置文件&quot;</span><br><span class="line">        command: cp /tmp/httpd.conf/ etc/httpd/conf/httpd.conf</span><br><span class="line">        command: cp /tmp/httpd-vhosts.conf/ etc/httpd/conf/httpd-vhosts.conf</span><br><span class="line">      - name: &quot;启动Apache，并设置开机启动&quot;</span><br><span class="line">        service: name=httpd state=started enabled=yes</span><br></pre></td></tr></table></figure><h5 id="示例system-yml："><a href="#示例system-yml：" class="headerlink" title="示例system.yml："></a>示例system.yml：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line">  - hosts: allre</span><br><span class="line">    mote_user: root</span><br><span class="line">    </span><br><span class="line">    tasks:</span><br><span class="line">      - name: create mysql user</span><br><span class="line">        user: name=mysql system=yes uid=36</span><br><span class="line">      - name: create a group </span><br><span class="line">        group: name=httpd system=yes</span><br></pre></td></tr></table></figure><h4 id="Playbook示例"><a href="#Playbook示例" class="headerlink" title="Playbook示例"></a>Playbook示例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">示例：httpd.yml</span><br><span class="line"></span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: Install httpd</span><br><span class="line">      yum: name=httpd state=present</span><br><span class="line">    - name: Install configure file</span><br><span class="line">      copy: src=files/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">    - name: start service</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br></pre></td></tr></table></figure><h4 id="handlers和notify结合使用触发条件"><a href="#handlers和notify结合使用触发条件" class="headerlink" title="handlers和notify结合使用触发条件"></a>handlers和notify结合使用触发条件</h4><ul><li>Handlers</li><li>是task列表，这些task与前述的task并没有本质上的不同,用于当关注的资源发生变化时，才会采取一定的操作</li><li>notify这个action可用于在每个play的最后被触发，这样可以避免多次有改变发生时每次都执行指定的操作，仅在所有的变化发生完成后一次性地执行指定操作。在notify中列出的操作称为handler，也即notify中调用handler中定义的操作</li></ul><h4 id="Playbook中handlers使用"><a href="#Playbook中handlers使用" class="headerlink" title="Playbook中handlers使用"></a>Playbook中handlers使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- hosts:websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: Install httpd </span><br><span class="line">      yum: name=httpd state=present</span><br><span class="line">    - name: Install configure file</span><br><span class="line">      copy: src=files/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">      notify: restart httpd</span><br><span class="line">    - name: ensure apache is running</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">    </span><br><span class="line">    handlers:</span><br><span class="line">      - name: restart httpd</span><br><span class="line">        service: name=httpd status=restarted</span><br></pre></td></tr></table></figure><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: add group nginx</span><br><span class="line">      tags: user</span><br><span class="line">      user: name=nginx state=present</span><br><span class="line">    - name: add user nginx</span><br><span class="line">      user: name=nginx state=present group=nginx</span><br><span class="line">    - name: Install Nginx</span><br><span class="line">      yum: name=nginx state=present</span><br><span class="line">    - name: config </span><br><span class="line">      copy: src=/root/config.txt dest=/etc/nginx/nginx.conf</span><br><span class="line">      notify:</span><br><span class="line">        - Restart Nginx</span><br><span class="line">        - Check Nginx Process</span><br><span class="line">    </span><br><span class="line">    handlers:</span><br><span class="line">      - name: Restart Nginx</span><br><span class="line">        service: name=nginx state=restarted enabled=yes</span><br><span class="line">      - name: Check Nginx process</span><br><span class="line">        shell:  killall -0 nginx &gt; /tmp/nginx.log</span><br></pre></td></tr></table></figure></p><h4 id="Playbook中tags使用"><a href="#Playbook中tags使用" class="headerlink" title="Playbook中tags使用"></a>Playbook中tags使用</h4><p>示例：httpd.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: Install httpd</span><br><span class="line">      yum: name=httpd state=present</span><br><span class="line">    - name: Install configure file</span><br><span class="line">      copy: src=files/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">      tags: conf</span><br><span class="line">    - name: start httpd service</span><br><span class="line">      tags: service</span><br><span class="line">      service: name=httpd state=started enabled=yes </span><br><span class="line">      </span><br><span class="line">ansible-playbook –t conf httpd.yml</span><br><span class="line">    -t //--tags</span><br></pre></td></tr></table></figure></p><h6 id="综合实例：安装httpd-并且启动端口是8080"><a href="#综合实例：安装httpd-并且启动端口是8080" class="headerlink" title="综合实例：安装httpd 并且启动端口是8080"></a>综合实例：安装httpd 并且启动端口是8080</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">本机先安装httpd 把httpd配置文件 /etc/httpd/conf/httpd.conf 里面端口改为8080</span><br><span class="line"></span><br><span class="line">[root@centos7 app]#cat httpd.yml </span><br><span class="line">---</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: install httpd</span><br><span class="line">      yum: name=httpd</span><br><span class="line">    - name: copy config file</span><br><span class="line">      copy: src=/app/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">    - name: start httpd</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line">      </span><br><span class="line">[root@centos7 app]#ansible-playbook httpd.yml</span><br><span class="line">现在把端口改为80</span><br><span class="line">[root@centos7 app]#cat httpd.yml </span><br><span class="line">---</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: install httpd</span><br><span class="line">      yum: name=httpd</span><br><span class="line">    - name: copy config file</span><br><span class="line">      copy: src=/app/httpd.conf dest=/etc/httpd/conf/</span><br><span class="line">      notify: restart httpd</span><br><span class="line">    - name: start httpd</span><br><span class="line">      service: name=httpd state=started enabled=yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  handlers:</span><br><span class="line">    - name: restart httpd</span><br><span class="line">      service: name=httpd state=restarted</span><br><span class="line">[root@centos7 app]#ansible-playbook --limit 192.18.109.1  httpd.yml 只针对这一台机器</span><br><span class="line"></span><br><span class="line">[root@centos7 app]#ansible web -m shell -a &apos;ss -ntl|grep 80&apos;</span><br><span class="line">192.168.109.100 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">LISTEN     0      128         :::80                      :::*                 </span><br><span class="line">192.168.109.2 | SUCCESS | rc=0 &gt;&gt;</span><br><span class="line">LISTEN     0      128         :::80                      :::*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h3&gt;&lt;p&gt;ansible是一个基于python开发的轻量级自动化运维管理工具，可以用来批量执行命令，安装程序，支持playbook编排
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
      <category term="运维自动化工具" scheme="https://www.zhangqifei.top/categories/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="ansible" scheme="https://www.zhangqifei.top/tags/ansible/"/>
    
  </entry>
  
  <entry>
    <title>运维自动化工具puppet</title>
    <link href="https://www.zhangqifei.top/2017/08/07/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7puppet/"/>
    <id>https://www.zhangqifei.top/2017/08/07/linux/运维自动化工具puppet/</id>
    <published>2017-08-07T11:42:22.000Z</published>
    <updated>2018-04-22T09:29:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="puppet的概念"><a href="#puppet的概念" class="headerlink" title="puppet的概念"></a>puppet的概念</h2><p>Puppet是一款使用GPLV2X协议授权的开源管理配置工具，用Ruby语言开发。其既可以通过客户端–服务器的方式运行，也可以独立运行。Puppet可以为系统管理员提供方便、快捷的系统自动化管理。对于系统管理员来说通过Puppet配置管理系统，底层的操作系统的发行版本是透明的，Puppet通过（Provider又称提供者）属性来完成软件的配置与安装，管理员不必关心操作系统的种类与发行版本，<br>Puppet还可以提供一个强大的框架来完成系统管理功能，在框架的基础上系统管理员可以通过Puppet语言来描述系统的一些事务，如安装软件、初始化系统、启动、删除服务、推送配置文件和差异化配置管理服务器等。同时系统管理员和系统管理员之间可以分享用Puppet语言描述好的事务，从而减少重复劳动，提高工作效率。</p><h3 id="puppet工作模型"><a href="#puppet工作模型" class="headerlink" title="puppet工作模型"></a>puppet工作模型</h3><ul><li>a.部署调度<ul><li>puppet master在一台服务器以守护进程方式运行，同时也包含客户端各节点的配置信息，puppet agent 在与master的通信过程中，通过标准的SSL协议进行加密和验证，验证通过后，agent从masteer上读取响应节点信息应用在本地。</li></ul></li><li>b.配置语言和资源抽象<ul><li>puppet使用描述性语言来定义配置项，在puppet中将配置项被称为resource，当Agent连接Master时，Master并不知道Agent的操作系统型号和版本。Agent通过Facter工具收集系统相关信息，并通过SSL协议将Agent的信息传递给Master。Master根据Agent收集到的相关信息，通过资源的提供者来为Agent服务。比如Package资源收到Agent的信息后，会识别Agent的系统型号版本，并通过资源提供者（如yum aptitude pkgadd apt-get等）匹配，为Agent服务。</li></ul></li><li>c.事物层<pre><code>Puppet事务层其实就是它的解析引擎。Puppet事务层配置每一台主机的过程包括：</code></pre><ul><li>解析和配置编译。</li><li>将编译好的配置同步到Agent。</li><li>在Agent上应用配置。</li><li>向Master报告运行结果。</li></ul></li></ul><p>首先Puppet会创建一个图表来表示所有资源的关系和上下游执行顺序，以及和Agent的关系。然后Puppet将按照资源之间的关系和上下游顺序依次执行。<br>接着Puppet为每一个Agent获取相应的资源，并把它们编译成“目录”，然后将目录依次分发到各主机，并通过Agent来应用它们，最后应用结果以报告形式反馈给Master。自动化运维工具puppet安装配置</p><h3 id="puppet的细节和原理"><a href="#puppet的细节和原理" class="headerlink" title="puppet的细节和原理"></a>puppet的细节和原理</h3><p><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221202568971.png" alt><br></center><br>Puppet采用了非常简单的C/S架构，所有数据的交互都通过SSL进行，以保证安全。</p><ol><li>客户端Puppetd向Master发起认证请求，或使用带签名的证书。</li><li>Master告诉Client你是合法的。</li><li>客户端Puppetd调用Facter，Facter探测出主机的一些变量，例如主机名、内存大小、IP地址等。Puppetd将这些信息通过SSL连接发送到服务器端。</li><li>服务器端的Puppet Master检测客户端的主机名，然后找到manifest对应的node配置，并对该部分内容进行解析。Facter送过来的信息可以作为变量处 理，node牵涉到的代码才解析，其他没牵涉的代码不解析。解析分为几个阶段，首先是语法检查，如果语法错误就报错；如果语法没错，就继续解析，解析的结 果生成一个中间的“伪代码”（catelog），然后把伪代码发给客户端。</li><li>客户端接收到“伪代码”，并且执行。</li><li>客户端在执行时判断有没有File文件，如果有，则向fileserver发起请求。</li><li>客户端判断有没有配置Report，如果已配置，则把执行结果发送给服务器。</li><li>服务器端把客户端的执行结果写入日志，并发送给报告系统。</li></ol><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">两台机器：</span><br><span class="line">192.168.1.100（服务端）</span><br><span class="line">192.168.1.101 （客户端）</span><br><span class="line">两台机器关闭selinux，清空iptables规则，并保存，设置hostname</span><br><span class="line"></span><br><span class="line">100上</span><br><span class="line">hostname   master.aming.com</span><br><span class="line">编辑/etc/sysconfig/network  定义hostname</span><br><span class="line"></span><br><span class="line">101上</span><br><span class="line">hostname   client.aming.com</span><br><span class="line">编辑/etc/sysconfig/network  定义hostname</span><br><span class="line">重启服务器</span><br><span class="line"></span><br><span class="line">编辑hosts文件</span><br><span class="line">100和101全部为</span><br><span class="line">192.168.1.100  master.aming.com</span><br><span class="line">192.168.1.101   client.aming.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装ntpdate，并建立自动同步时间的任务计划：</span><br><span class="line">yum install -y ntp</span><br><span class="line">cront -e   //加入</span><br><span class="line">*/10  * * * * ntpdate time.windows.com</span><br></pre></td></tr></table></figure><h3 id="服务端安装"><a href="#服务端安装" class="headerlink" title="服务端安装"></a>服务端安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">安装puppet 源</span><br><span class="line">rpm -ivh  http://yum.puppetlabs.com/el/6/p ... ease-6-7.noarch.rpm</span><br><span class="line"></span><br><span class="line">安装服务端程序</span><br><span class="line">yum install -y puppet-server</span><br><span class="line">启动服务</span><br><span class="line">service  puppetmaster start</span><br><span class="line"></span><br><span class="line">开机启动</span><br><span class="line">chkconfig  puppetmaster on</span><br></pre></td></tr></table></figure><h3 id="客户端安装"><a href="#客户端安装" class="headerlink" title="客户端安装"></a>客户端安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">安装puppet 源</span><br><span class="line">rpm -ivh http://yum.puppetlabs.com/el/6/p ... ease-6-7.noarch.rpm</span><br><span class="line"></span><br><span class="line">安装客户端程序</span><br><span class="line">yum install -y puppet</span><br><span class="line"></span><br><span class="line">修改配置文件</span><br><span class="line">vi /etc/puppet/puppet.conf</span><br><span class="line">在最后面添加：</span><br><span class="line">listen = true</span><br><span class="line">server = master.aming.com</span><br><span class="line">runinterval = 30   //主动更新，每隔30s</span><br><span class="line"></span><br><span class="line">然后启动puppet服务</span><br><span class="line">/etc/init.d/puppet start</span><br><span class="line"></span><br><span class="line">手动生成ssl证书</span><br><span class="line">puppet agent  --test  --server  master.aming.com</span><br></pre></td></tr></table></figure><h3 id="服务端查看，签发客户端的证书"><a href="#服务端查看，签发客户端的证书" class="headerlink" title="服务端查看，签发客户端的证书"></a>服务端查看，签发客户端的证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">puppet cert list --all</span><br><span class="line">会看到client.aming.com 的key，正常应该会在行首有一个+，如果没有说明还没有签发</span><br><span class="line"></span><br><span class="line">签发客户端</span><br><span class="line">puppet cert --sign client.aming.com</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">服务端上</span><br><span class="line">vi /etc/puppet/manifests/site.pp</span><br><span class="line">加入如下内容：</span><br><span class="line">node default &#123;</span><br><span class="line">file &#123;</span><br><span class="line">&quot;/tmp/123.txt&quot;: content =&gt; &quot;test,test&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">客户端上</span><br><span class="line">puppet agent --test --server  master.aming.com</span><br><span class="line">这样会在客户端上生成一个 /tmp/123.txt的文件，并且内容为 testtest</span><br></pre></td></tr></table></figure><h3 id="配置自动签发证书"><a href="#配置自动签发证书" class="headerlink" title="配置自动签发证书"></a>配置自动签发证书</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">服务端上删除客户端证书</span><br><span class="line">puppet cert clean client.aming.com</span><br><span class="line"></span><br><span class="line">客户端上删除ssl下的文件</span><br><span class="line">rm -rf /var/lib/puppet/ssl/*</span><br><span class="line"></span><br><span class="line">服务端更改配置文件</span><br><span class="line">vim /etc/puppet/puppet.conf在[main]下面加一行</span><br><span class="line">autosign = true</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">服务端创建自动签发的配置文件</span><br><span class="line">vim /etc/puppet/autosign.conf</span><br><span class="line">加入如下内容：</span><br><span class="line">*.aming.com </span><br><span class="line"></span><br><span class="line">重启puppetmaster服务</span><br><span class="line">/etc/init.d/puppetmaster restart</span><br><span class="line"></span><br><span class="line">客户端重启puppet服务</span><br><span class="line">/etc/init.d/puppet restart</span><br><span class="line"></span><br><span class="line">这样就能在服务端上自动签发证书了。当然不重启服务，手动连一下服务端也可以</span><br><span class="line">客户端执行：</span><br><span class="line">puppet agent --test --server  master.aming.com</span><br><span class="line"></span><br><span class="line">扩展： puppet更新方式  http://www.cnphp6.com/archives/66975</span><br></pre></td></tr></table></figure><h2 id="模块管理"><a href="#模块管理" class="headerlink" title="模块管理"></a>模块管理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">首先要理解几个概念，模块、类、资源。 模块是puppet的最大单元，模块里面有类，类下面有资源。 </span><br><span class="line">puppet管理的文件、用户、服务、任务计划等全部由这些单元组成。</span><br><span class="line"></span><br><span class="line">下面我们来定义一个模块：</span><br><span class="line">在服务端上做如下操作：</span><br><span class="line">mkdir /etc/puppet/modules/testm  //模块名字就是testm</span><br><span class="line">cd !$</span><br><span class="line">mkdir &#123;files,manifests,templates&#125;   //一个模块下需要有这三个目录，files存一些文件（可以为空），manifests存配置文件，templates存模板（可以留空）</span><br><span class="line">touch manifests/init.pp  //这个是必须的</span><br><span class="line">vi  manifests/init.pp   //内容如下</span><br><span class="line">class testm&#123;</span><br><span class="line">file &#123;&quot;/tmp/2.txt&quot;:</span><br><span class="line">owner =&gt; &quot;root&quot;,</span><br><span class="line">group =&gt; &quot;root&quot;,</span><br><span class="line">mode =&gt; 0400,</span><br><span class="line">source =&gt; &quot;puppet://$puppetserver/modules/testm/1.txt&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：类名字也叫做testm, 类下面定义了一个资源file，文件名字叫做/tmp/2.txt ，owner，group，mode定义文件的属主、数组以及权限，</span><br><span class="line">source定义这个文件从哪里获取。 $puppetserver一会也要定义一下，这里指的是puppet server服务器上/etc/puppet/modules/testm/files/1.txt</span><br><span class="line"></span><br><span class="line">下面要继续定义一个很关键的配置文件：</span><br><span class="line">vim  /etc/puppet/manifests/site.pp   //内容如下</span><br><span class="line">$puppetserver = &apos;master.aming.com&apos;</span><br><span class="line"></span><br><span class="line">node &apos;client.aming.com&apos;&#123;</span><br><span class="line">    include testm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">说明：$puppetserver 定义服务端的主机名，node后面为客户端的主机名，这里面定义该客户端要加载的模块</span><br><span class="line">配置完成后，在客户端执行命令：</span><br><span class="line">puppet agent --test  --server=master.aming.com   //如果客户端上启动了puppet服务，不用执行这命令，它也会自动同步的</span><br><span class="line">上面的模块其实只是同步了一个文件而已，那么要想同步一个目录如何做？我们可以通过实现同步一个目录来做一个包发布系统。</span><br><span class="line">比如在一台机器上编译安装好了apache，那么就可以通过这样的模块把这个apache目录整个分发到其他机器上。</span><br><span class="line"></span><br><span class="line">模块配置文件如下：</span><br><span class="line">class apache&#123;</span><br><span class="line">file &#123;&quot;/usr/local/apache2&quot;:</span><br><span class="line">owner =&gt; &quot;root&quot;,</span><br><span class="line">group =&gt; &quot;root&quot;,</span><br><span class="line">source =&gt; &quot;puppet://$puppetserver/modules/apache/apache2&quot;,</span><br><span class="line">recurse =&gt; true,</span><br><span class="line">purge =&gt; true</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">其中recurse=&gt;true 这个参数很关键，它表示递归的意思，没有这个不能同步目录。purge参数可以保证当服务端删除某个文件，客户端可以跟着删除。</span><br><span class="line"></span><br><span class="line">远程执行命令：</span><br><span class="line">exec &#123;&quot;123&quot;:</span><br><span class="line">unless =&gt; &quot;test -f /tmp/aminglinux.txt&quot;,</span><br><span class="line">path =&gt; [&quot;/bin&quot;, &quot;/sbin&quot;, &quot;/usr/bin&quot;, &quot;/usr/sbin&quot;],</span><br><span class="line">command =&gt; &quot;/bin/touch /tmp/aminglinux.txt&quot;</span><br><span class="line">&#125;</span><br><span class="line">说明：unless后面的命令作为一个条件，当条件成立时，不会执行下面的命令，如果想要条件成立时，执行下面的命令，用 onlyif。</span><br><span class="line">要注意的是，我们一定要给执行的这条命令加个条件，使用unless就可以，必须满足这个条件才能执行命令，否则这个命令会一直执行，不太妥当。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cron资源：</span><br><span class="line">cron &#123;&quot;aming1&quot;:</span><br><span class="line">command =&gt; &quot;/sbin/ntpdate time.windows.com&quot;,</span><br><span class="line">user =&gt; &quot;root&quot;,</span><br><span class="line">minute =&gt; &quot;*/10&quot;,</span><br><span class="line"># ensure =&gt; &quot;absent&quot;  //当增加了这行配置，则会把该cron删除掉</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">说明：分时日月周分别对应puppet里面的minute，hour，monthday，month，weekday</span><br></pre></td></tr></table></figure><h2 id="扩展学习"><a href="#扩展学习" class="headerlink" title="扩展学习"></a>扩展学习</h2><ul><li><a href="http://blog.chinaunix.net/uid-20639775-id-3314583.html" target="_blank" rel="noopener">http://blog.chinaunix.net/uid-20639775-id-3314583.html</a></li></ul><p>资源： </p><ul><li>package  <a href="http://puppet.wikidot.com/package" target="_blank" rel="noopener">http://puppet.wikidot.com/package</a></li><li>service <a href="http://puppet.wikidot.com/srv" target="_blank" rel="noopener">http://puppet.wikidot.com/srv</a></li><li>exec <a href="http://puppet.wikidot.com/exec" target="_blank" rel="noopener">http://puppet.wikidot.com/exec</a></li><li>cron <a href="http://puppet.wikidot.com/cron" target="_blank" rel="noopener">http://puppet.wikidot.com/cron</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;puppet的概念&quot;&gt;&lt;a href=&quot;#puppet的概念&quot; class=&quot;headerlink&quot; title=&quot;puppet的概念&quot;&gt;&lt;/a&gt;puppet的概念&lt;/h2&gt;&lt;p&gt;Puppet是一款使用GPLV2X协议授权的开源管理配置工具，用Ruby语言开发。其
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
      <category term="运维自动化工具" scheme="https://www.zhangqifei.top/categories/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="puppet" scheme="https://www.zhangqifei.top/tags/puppet/"/>
    
  </entry>
  
  <entry>
    <title>运维自动化工具saltstack</title>
    <link href="https://www.zhangqifei.top/2017/08/06/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7saltstack/"/>
    <id>https://www.zhangqifei.top/2017/08/06/linux/运维自动化工具saltstack/</id>
    <published>2017-08-06T10:42:22.000Z</published>
    <updated>2018-04-22T09:29:33.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Saltstack简介"><a href="#Saltstack简介" class="headerlink" title="Saltstack简介"></a>Saltstack简介</h2><p>SaltStack是一个服务器基础架构集中化管理平台，具备配置管理、远程执行、监控等功能，一般可以理解为简化版的puppet和加强版的func。SaltStack基于Python语言实现，结合轻量级消息队列（ZeroMQ）与Python第三方模块（Pyzmq、PyCrypto、Pyjinjia2、python-msgpack和PyYAML等）构建。通过部署SaltStack环境，我们可以在成千上万台服务器上做到批量执行命令，根据不同业务特性进行配置集中化管理、分发文件、采集服务器数据、操作系统基础及软件包管理等，SaltStack是运维人员提高工作效率、规范业务配置与操作的利器。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>简单</strong><ul><li>兼顾大规模部署与更小的系统的同时提供多功能性是很困难的，Salt是非常简单配置和维护，不管项目的大小。Salt可以胜任管理任意的数量的服务器，不管是本地网络，还是跨数据中心。架构采用C/S模式，在一个后台程序中集成必要功能。默认不需要复杂的配置就可以工作，同时可以定制用于特殊的需求。</li></ul></li><li><strong>并行执行</strong><ul><li>Salt的核心功能：</li><li>通过并行方式让远端节点执行命令</li><li>采用安全的加密/解析协议</li><li>最小化使用网络和负载</li><li>提供简单的程序接口</li><li>Salt引入了更细粒度的控制，允许不通过目标名字，二是通过系统属性分类</li></ul></li><li><strong>构建在成熟技术之上</strong><ul><li>Salt采用了很多技术和技巧。网络层采用优秀的ZeroMQ库，所以守护进程里面包含AMQ代理。Salt采用公钥和主控通讯，同时使用更快的AES加密通信，验证和加密都已经集成在Salt里面。Salt使用msgpack通讯，所以更快速和更轻量网络交换。</li></ul></li><li><strong>Python 客户端接口</strong><ul><li>为了实现简单的扩展，Salt执行例程可以写成简单的Python模块。客户端程序收集的数据可以发送回主控端，可以是其他任意程序。可以通过Python API调用Salt程序，或者命令行，因此，Salt可以用来执行一次性命令，或者大型应用程序中的一部分模块。</li></ul></li><li><strong>快速，灵活，可扩展</strong><ul><li>结果是一个系统可以高速在一台或者一组服务器执行命令。Salt速度很快，配置简单，扩展性好，提供了一个远程执行架构，可以管理多样化需求的任何数量的服务器。整合了世界上最好的远程执行方法，增强处理能力，扩展使用范围，使得可以适用任何多样化复杂的网络。</li></ul></li><li><strong>开源</strong><ul><li>Salt基于Apache 2.0 licence开发，可以用于开源或者自有项目。请反馈你的扩展给项目组，以便更多人受益，共同促进Salt发展。请在你的系统部署 系统，让运维更便捷。</li></ul></li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>saltstack是基于C/S服务模式，在该架构中，服务器端叫做Master，客户端叫做Minion。传统的C/S模式我们这样理解，客户端发送请求给服务器端，服务器端接受到来自客户端的请求并处理完成后再返回客户端。 在saltstack架构中，不仅有传统的C/S服务模式，而且有消息队列中的发布与订阅（pub/sub）服务模式。目前我们一般用其C/S架构做批量管理。</p><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479473.png" alt="12"><br></center><ul><li>Master：控制中心,salt命令运行和资源状态管理</li><li>Minion : 需要管理的客户端机器,会主动去连接Mater端,并从Master端得到资源状态</li><li>信息,同步资源管理信息</li><li>States：配置管理的指令集</li><li>Modules：在命令行中和配置文件中使用的指令模块,可以在命令行中运行</li><li>Grains：minion端的变量,静态的</li><li>Pillar：minion端的变量,动态的比较私密的变量,可以通过配置文件实现同步minions定义</li><li>highstate：为minion端下发永久添加状态,从sls配置文件读取.即同步状态配置</li><li>salt_schedule：会自动保持客户端配置</li></ul><h3 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h3><p>Master与Minion认证</p><ul><li>minion在第一次启动时，会在/etc/salt/pki/minion/（该路径在/etc/salt/minion里面设置）下自动生成minion.pem（private key）和 minion.pub（public key），然后将 minion.pub发送给master。</li><li>master在接收到minion的public key后，通过salt-key命令accept minion public key，这样在master的/etc/salt/pki/master/minions下的将会存放以minion id命名的 public key，然后master就能对minion发送指令了。<ul><li>SaltStack master启动后默认监听4505和4506两个端口。4505（publish_port）为saltstack的消息发布系统，4506（ret_port）为saltstack客户端与服务端通信的端口。如果使用lsof 查看4505端口，会发现所有的minion在4505端口持续保持在ESTABLISHED状态</li></ul></li></ul><h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">主机名                IP地址               系统</span><br><span class="line">saltstack-server172.20.4.50CentOS release 6.9 (Final)</span><br><span class="line">saltstack-1        172.20.4.51CentOS release 6.9 (Final)</span><br><span class="line">saltstack-2        172.20.4.52CentOS release 6.9 (Final)</span><br></pre></td></tr></table></figure><h3 id="初始化环境："><a href="#初始化环境：" class="headerlink" title="初始化环境："></a>初始化环境：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">yum install ntpdate -y &amp;&amp; ntpdate time1.aliyun.com                    #同步时间</span><br><span class="line">service iptables stop                                                 #关闭iptables</span><br><span class="line">sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/&quot;  /etc/selinux/config   #关闭selinux</span><br><span class="line">setenforce 0</span><br><span class="line"> </span><br><span class="line">cat &gt; saltstack.repo &lt;&lt;EOF</span><br><span class="line">[saltstack-repo]</span><br><span class="line">name=SaltStack repo for RHEL/CentOS $releasever</span><br><span class="line">baseurl=https://repo.saltstack.com/yum/RedHat/$releasever/$basearch/latest</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://repo.saltstack.com/yum/redhat/$releasever/$basearch/latest/SALTSTACK-GPG-KEY.pub</span><br><span class="line">EOF</span><br><span class="line">rpm --import https://repo.saltstack.com/yum/redhat/6/x86_64/latest/SALTSTACK-GPG-KEY.pub</span><br><span class="line">yum cleanall &amp;&amp; yum makecache                #更新yum源</span><br></pre></td></tr></table></figure><h3 id="master-端安装"><a href="#master-端安装" class="headerlink" title="master  端安装"></a>master  端安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install salt-master</span><br><span class="line">mkdir /etc/salt/states</span><br><span class="line"> </span><br><span class="line">编辑/etc/salt/states</span><br><span class="line">interface: 0.0.0.0</span><br><span class="line">state_top: top.sls</span><br><span class="line">file_roots:</span><br><span class="line">   base:</span><br><span class="line">     - /etc/salt/states</span><br></pre></td></tr></table></figure><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479471.png" alt="12"><br></center><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">启动服务，并设置开机自启</span><br><span class="line">/etc/init.d/salt-master start</span><br><span class="line">chkconfig salt-master on</span><br></pre></td></tr></table></figure><h3 id="monitor端安装"><a href="#monitor端安装" class="headerlink" title="monitor端安装"></a>monitor端安装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">配置yum源和master方法一致</span><br><span class="line"></span><br><span class="line">yum -y install salt-minion</span><br><span class="line">修改/etc/salt/minion文件（slatstack-1/2 都更改成对应的id，master指向master的ip地址）</span><br></pre></td></tr></table></figure><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479476.png" alt><br></center><br>启动客户端，并设置开机自启动<br><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479474.png" alt><br></center><h3 id="证书管理"><a href="#证书管理" class="headerlink" title="证书管理"></a>证书管理</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#执行salt-key -L  查看秘钥验证</span><br><span class="line">#执行Salt-key -a 加ID添加认证秘钥</span><br></pre></td></tr></table></figure><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479472.png" alt><br></center><h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><center><br><img src="https://www.linuxidc.com/upload/2017_12/171221203479475.png" alt><br></center>    <h2 id="常见模块"><a href="#常见模块" class="headerlink" title="常见模块"></a>常见模块</h2><p>(1)、cp模块（实现远程文件、目录的复制，以及下载URL文件等操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">将主服务器file_roots指定位置下的目录复制到被控主机</span><br><span class="line">salt &quot;*&quot; cp.get_dir salt://testdir /tmp/test</span><br><span class="line"></span><br><span class="line">将主服务器file_roots指定位置下的文件复制到被控主机</span><br><span class="line">salt &quot;*&quot; cp.get_file salt://testdir/testfile /tmp/testfile</span><br><span class="line"></span><br><span class="line">下载指定URL内容到被控主机指定位置</span><br><span class="line">salt &quot;*&quot; cp.get_url http://mirrors.163.com/.help/CentOS6-Base-163.repo /etc/yum.repos.d/CentOS6-Base-163.repo</span><br></pre></td></tr></table></figure></p><p>(2)、cmd模块（实现远程的命令行调用执行）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">salt &quot;*&quot; cmd.run &apos;netstat -lntup&apos;</span><br></pre></td></tr></table></figure></p><p>(3)、cron模块（实现被控主机的crontab操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">为指定的被控主机、root用户添加crontab信息</span><br><span class="line">salt &quot;*&quot; cron.set_job root &apos;*/5&apos; &apos;*&apos; &apos;*&apos; &apos;*&apos; &apos;*&apos; &apos;/usr/sbin/ntpdate time1.aliyun.com&apos;</span><br><span class="line"></span><br><span class="line">删除指定的被控主机、root用户的crontab信息</span><br><span class="line">salt &quot;*&quot; cron.rm_job root &apos;/usr/sbin/ntpdate time1.aliyun.com&apos;</span><br><span class="line"></span><br><span class="line">查看定时任务</span><br><span class="line">salt &apos;*&apos; cron.raw_cron root</span><br></pre></td></tr></table></figure></p><p>(4)、dnsutil模块（实现被控主机通用DNS操作）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为被控主机添加指定的hosts主机配置项</span><br><span class="line">salt &apos;*&apos; dnsutil.hosts_append /etc/hosts 127.0.0.1 test.saltstack.com</span><br></pre></td></tr></table></figure></p><p>(5)、file模块（被控主机文件常见操作，包括文件读写、权限、查找、校验等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; file.get_sum /etc/resolv.conf md5</span><br><span class="line">salt &apos;*&apos; file.stats /etc/resolv.conf</span><br></pre></td></tr></table></figure></p><p>(6)、network模块（返回被控主机网络信息）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; network.ip_addrs</span><br><span class="line">salt &apos;*&apos; network.interfaces</span><br></pre></td></tr></table></figure></p><p>(7)、pkg包管理模块（被控主机程序包管理，如yum、apt-get等）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; pkg.install sysstat</span><br><span class="line">salt &apos;*&apos; pkg.file_list sysstat</span><br></pre></td></tr></table></figure></p><p>(8)、service 服务模块（被控主机程序包服务管理）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">salt &apos;*&apos; service.enable crond</span><br><span class="line">salt &apos;*&apos; service.disable crond</span><br><span class="line">salt &apos;*&apos; service.status crond</span><br><span class="line">salt &apos;*&apos; service.stop crond</span><br><span class="line">salt &apos;*&apos; service.start crond</span><br><span class="line">salt &apos;*&apos; service.restart crond</span><br><span class="line">salt &apos;*&apos; service.reload crond</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Saltstack简介&quot;&gt;&lt;a href=&quot;#Saltstack简介&quot; class=&quot;headerlink&quot; title=&quot;Saltstack简介&quot;&gt;&lt;/a&gt;Saltstack简介&lt;/h2&gt;&lt;p&gt;SaltStack是一个服务器基础架构集中化管理平台，具备配置管理、
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
      <category term="运维自动化工具" scheme="https://www.zhangqifei.top/categories/linux/%E8%BF%90%E7%BB%B4%E8%87%AA%E5%8A%A8%E5%8C%96%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="saltstack" scheme="https://www.zhangqifei.top/tags/saltstack/"/>
    
  </entry>
  
  <entry>
    <title>8分钟带你深入浅出搞懂Nginx</title>
    <link href="https://www.zhangqifei.top/2017/06/06/linux/8%E5%88%86%E9%92%9F%E5%B8%A6%E4%BD%A0%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E6%90%9E%E6%87%82Nginx/"/>
    <id>https://www.zhangqifei.top/2017/06/06/linux/8分钟带你深入浅出搞懂Nginx/</id>
    <published>2017-06-06T01:41:22.000Z</published>
    <updated>2018-04-22T09:29:33.065Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx/20180328172708395.png?raw=true" alt="架构图"><br><font color="gray">架构图</font><br></center><blockquote><p>上图基本上说明了当下流行的技术架构，其中Nginx有点入口网关的味道。</p></blockquote><hr><p><strong>反向代理服务器？</strong><br>经常听人说到一些术语，如反向代理，那么什么是反向代理，什么又是正向代理呢？</p><p><strong>正向代理：</strong></p><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx/20180328172708395.png?raw=true" alt="正向代理"><br><font color="gray">正向代理示意图</font><br></center><blockquote><p>由于防火墙的原因，我们并不能直接访问谷歌，那么我们可以借助VPN来实现，这就是一个简单的正向代理的例子。这里你能够发现，正向代理“代理”的是客户端，而且客户端是知道目标的，而目标是不知道客户端是通过VPN访问的。</p></blockquote><p><strong>反向代理：</strong></p><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328173053110.png?raw=true" alt="反向代理"><br><font color="gray">反向代理示意图</font><br></center><blockquote><p>当我们在外网访问百度的时候，其实会进行一个转发，代理到内网去，这就是所谓的反向代理，即反向代理“代理”的是服务器端，而且这一个过程对于客户端而言是透明的。</p></blockquote><hr><center><br><font color="gray">Nginx的Master-Worker模式</font><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328173552608.png?raw=true" alt="这里写图片描述"><br><font color="gray">nginx进程</font><br></center><blockquote><p>启动Nginx后，其实就是在80端口启动了Socket服务进行监听，如图所示，Nginx涉及Master进程和Worker进程。</p></blockquote><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328173745376.png?raw=true" alt="Master-Worker模式"><br><font color="gray">Master-Worker模式</font><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328173922132.png?raw=true" alt="这里写图片描述"><br></center><p><strong>nginx.conf</strong></p><ul><li><strong>Master进程的作用是？</strong><font color="gray">读取并验证配置文件nginx.conf；管理worker进程；</font></li><li><strong>Worker进程的作用是？</strong><font color="gray">每一个Worker进程都维护一个线程（避免线程切换），处理连接和请求；注意Worker进程的个数由配置文件决定，一般和CPU个数相关（有利于进程切换），配置几个就有几个Worker进程。</font></li></ul><hr><center><strong>思考：Nginx如何做到热部署？</strong></center><blockquote><p>所谓热部署，就是配置文件<code>nginx.conf</code>修改后，不需要<code>stop Nginx</code>，不需要中断请求，就能让配置文件生效！（<code>nginx -s reload</code> 重新加载 <code>nginx -t</code>检查配置 <code>nginx -s stop</code>停止）</p></blockquote><p>通过上文我们已经知道worker进程负责处理具体的请求，那么如果想达到热部署的效果，可以想象：</p><p><strong>方案一：</strong></p><font color="gray">修改配置文件nginx.conf后，主进程master负责推送给woker进程更新配置信息，woker进程收到信息后，更新进程内部的线程信息。（有点valatile的味道）</font><p><strong>方案二：</strong></p><font color="gray">修改配置文件nginx.conf后，重新生成新的worker进程，当然会以新的配置进行处理请求，而且新的请求必须都交给新的worker进程，至于老的worker进程，等把那些以前的请求处理完毕后，kill掉即可。</font><blockquote><p>Nginx采用的就是方案二来达到热部署的！</p></blockquote><hr><center><strong>思考：Nginx如何做到高并发下的高效处理？</strong><center><br><br><font color="gray">上文已经提及Nginx的worker进程个数与CPU绑定、worker进程内部包含一个线程高效回环处理请求，这的确有助于效率，但这是不够的。</font><br><br><font color="gray">作为专业的程序员，我们可以开一下脑洞：BIO/NIO/AIO、异步/同步、阻塞/非阻塞…</font><br><br><font color="gray">要同时处理那么多的请求，要知道，有的请求需要发生IO，可能需要很长时间，如果等着它，就会拖慢worker的处理速度。</font><br><br><font color="gray">Nginx采用了Linux的epoll模型，epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入epoll队列中，这个过程是异步的。worker只需要从epoll队列循环处理即可。</font><br><br><hr><br><center><strong>思考：Nginx挂了怎么办?</strong></center><br><font color="gray">Nginx既然作为入口网关，很重要，如果出现单点问题，显然是不可接受的。</font><br><br><font color="gray">答案是：</font><strong>Keepalived+Nginx实现高可用。</strong><br><br><font color="gray">Keepalived是一个高可用解决方案，主要是用来防止服务器单点发生故障，可以通过和Nginx配合来实现Web服务的高可用。（其实，Keepalived不仅仅可以和Nginx配合，还可以和很多其他服务配合）</font><br><br><strong>Keepalived+Nginx实现高可用的思路：</strong><br><br><font color="gray">第一：请求不要直接打到Nginx上，应该先通过Keepalived（这就是所谓虚拟IP，VIP）</font><br><br><font color="gray">第二：Keepalived应该能监控Nginx的生命状态（提供一个用户自定义的脚本，定期检查Nginx进程状态，进行权重变化,，从而实现Nginx故障切换）</font><br><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328175340149.png?raw=true" alt="这里写图片描述"><br><font color="gray">Keepalived+Nginx</font><br></center><hr><p><strong>我们的主战场：</strong><code>nginx.conf</code></p><ul><li>很多时候，在开发、测试环境下，我们都得自己去配置Nginx，就是去配置<code>nginx.conf</code>。</li><li><code>nginx.conf</code>是典型的分段配置文件，下面我们来分析下。</li></ul><center><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//20180328175623369.png?raw=true" alt="这里写图片描述"><br><img src="https://github.com/zhangqifei/picture/blob/master/nginx//2018032817572351.png?raw=true" alt="这里写图片描述"><br></center><p><strong>其实这是把Nginx作为web server来处理静态资源。</strong></p><ul><li>第一：location可以进行正则匹配，应该注意正则的几种形式以及优先级。（这里不展开）</li><li>第二：Nginx能够提高速度的其中一个特性就是：动静分离，就是把静态资源放到Nginx上，由Nginx管理，动态请求转发给后端。</li><li>第三：我们可以在Nginx下把静态资源、日志文件归属到不同域名下（也即是目录），这样方便管理维护。</li><li>第四：Nginx可以进行IP访问控制，有些电商平台，就可以在Nginx这一层，做一下处理，内置一个黑名单模块，那么就不必等请求通过Nginx达到后端在进行拦截，而是直接在Nginx这一层就处理掉。</li></ul><hr><p><strong>反向代理【proxy_pass】</strong></p><p>所谓反向代理，很简单，其实就是在location这一段配置中的root替换成proxy_pass即可。root说明是静态资源，可以由Nginx进行返回；而proxy_pass说明是动态请求，需要进行转发，比如代理到Tomcat上。</p><p>反向代理，上面已经说了，过程是透明的，比如说<code>request -&gt; Nginx -&gt; Tomcat</code>，那么对于Tomcat而言，请求的IP地址就是Nginx的地址，而非真实的request地址，这一点需要注意。不过好在Nginx不仅仅可以反向代理请求，还可以由用户自定义设置<code>HTTP HEADER</code>。</p><hr><p><strong>负载均衡【upstream】</strong></p><p>上面的反向代理中，我们通过<code>proxy_pass</code>来指定Tomcat的地址，很显然我们只能指定一台Tomcat地址，那么我们如果想指定多台来达到负载均衡呢？</p><ul><li>第一，通过upstream来定义一组Tomcat，并指定负载策略（IPHASH、加权论调、最少连接），健康检查策略（Nginx可以监控这一组Tomcat的状态）等。</li><li>第二，将proxy_pass替换成upstream指定的值即可。</li></ul><p><strong>负载均衡可能带来的问题？</strong></p><ul><li>负载均衡所带来的明显的问题是，一个请求，可以到A server，也可以到B server，这完全不受我们的控制，当然这也不是什么问题，只是我们得注意的是：用户状态的保存问题，如Session会话信息，不能在保存到服务器上。</li></ul><hr><p><strong>缓存</strong></p><p>缓存，是Nginx提供的，可以加快访问速度的机制，说白了，在配置上就是一个开启，同时指定目录，让缓存可以存储到磁盘上。具体配置，大家可以参考Nginx官方文档，这里就不在展开了</p></center></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Nginx是一款轻量级的Web服务器、反向代理服务器，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;img src=&quot;https://github.com/zhangqifei/picture/blob/master
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
    
      <category term="Nginx" scheme="https://www.zhangqifei.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Systemd 入门教程：命令篇</title>
    <link href="https://www.zhangqifei.top/2017/05/06/linux/Systemd%20%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%9A%E5%91%BD%E4%BB%A4%E7%AF%87/"/>
    <id>https://www.zhangqifei.top/2017/05/06/linux/Systemd 入门教程：命令篇/</id>
    <published>2017-05-06T01:31:25.000Z</published>
    <updated>2018-04-22T09:30:14.835Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://zhangqifei.top/picture/ifeier/data/systemd.jpg" width="500" height="200" alt="markdown" align="center"></center><br>Systemd 是 Linux 系统工具，用来启动<strong>守护进程</strong>，已成为大多数发行版的标准配置。<br><br>本文介绍它的基本用法，分为上下两篇。今天介绍它的主要命令，<strong>下一篇</strong>介绍如何用于实战。<br>历史上，Linux 的启动一直采用<code>init</code>进程。<br><br>下面的命令用来启动服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ /etc/init.d/apache2 start</span><br><span class="line"># 或者</span><br><span class="line">$ service apache2 start</span><br></pre></td></tr></table></figure><br><br><strong>这种方法有两个缺点。</strong><br>1. 启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程。<br>2. 启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长。<br><br>Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。<br><br>根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。<br><br><br><center><img src="http://zhangqifei.top/picture/ifeier/data/dystemdname.jpg" width="500" height="200" alt="Systemdname" align="center"><br>（Systemd 作者 Lennart Poettering）</center><p>使用了 Systemd，就不需要再用<code>init</code>了。Systemd 取代了<code>initd</code>，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl --version    //查看 Systemd 的版本。</span><br></pre></td></tr></table></figure></p><p>Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反”keep simple, keep stupid”的<strong>Unix 哲学</strong></p><p><center><img src="http://zhangqifei.top/picture/ifeier/data/systemd.png" width="500" height="200" alt="Systemdname" align="center"><br>（Systemd 架构图）</center><br>Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。</p><h2 id="systemd"><a href="#systemd" class="headerlink" title="systemd"></a>systemd</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST --&gt; Boot Sequence --&gt; Bootloader --&gt; kernel + initramfs(initrd) --&gt; rootfs--&gt; /sbin/init</span><br><span class="line">    init:CentOS 5: SysV init</span><br><span class="line">    CentOS 6: Upstart</span><br><span class="line">    CentOS 7: Systemd</span><br></pre></td></tr></table></figure><p>Systemd：系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程</p><p><strong>Systemd新特性：</strong></p><ul><li>系统引导时实现服务并行启动</li><li>按需启动守护进程</li><li>自动化的服务依赖关系管理</li><li>同时采用socket式与D-Bus总线式激活服务</li><li>系统状态快照</li></ul><p><strong>核心概念：</strong> unit表示不同类型的systemd对象，通过配置文件进行标识和配置；文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息</p><p><strong>配置文件：</strong></p><ul><li>/usr/lib/systemd/system:每个服务最主要的启动脚本设置,类似于之前的/etc/init.d/</li><li>/run/systemd/system:系统执行过程中所产生的服务脚本,比上面目录优先运行</li><li>/etc/systemd/system:管理员建立的执行脚本,类似于/etc/rc.d/rcN.d/Sxx类的功能,比上面目录优先运行</li></ul><h3 id="Unit类型"><a href="#Unit类型" class="headerlink" title="Unit类型"></a>Unit类型</h3><ol><li>Systemctl –t help 查看unit类型</li><li>Service unit: 文件扩展名为.service, 用于定义系统服务</li><li>Target unit: 文件扩展名为.target，用于模拟实现运行级别</li><li>Device unit: .device, 用于定义内核识别的设备</li><li>Mount unit: .mount, 定义文件系统挂载点</li><li>Socket unit: .socket,用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动</li><li>Scope Unit：不是由 Systemd 启动的外部进程</li><li>Slice Unit：进程组</li><li>Snapshot unit: .snapshot, 管理系统快照</li><li>Swap unit: .swap, 用于标识swap设备</li><li>Automount unit: .automount，文件系统的自动挂载点</li><li>Path unit: .path，用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时，延迟激活服务，如：spool 目录</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><p>关键特性：</p><ul><li>基于socket的激活机制：socket与服务程序分离</li><li>基于d-bus的激活机制：</li><li>基于device的激活机制：</li><li>基于path的激活机制：</li><li>系统快照：保存各unit的当前状态信息于持久存储设备中向后兼容sysvinit脚本</li></ul><p>不兼容：</p><ul><li>systemctl命令固定不变，不可扩展</li><li>非由systemd启动的服务，systemctl无法与之通信和控制</li></ul><h3 id="管理服务"><a href="#管理服务" class="headerlink" title="管理服务"></a>管理服务</h3><ul><li>管理系统服务：CentOS 7: service unit</li></ul><blockquote><p>注意：能兼容早期的服务脚本<br> 命令：systemctl COMMAND name.service</p></blockquote><ul><li>启动：service name start ==&gt; systemctl start name.service</li><li>停止：service name stop ==&gt; systemctl stop name.service</li><li>重启：service name restart ==&gt; systemctl restart name.service</li><li>状态：service name status ==&gt; systemctl status name.service</li><li>条件式重启：已启动才重启，否则不做操作<br> service name condrestart ==&gt; systemctl try-restart name.service</li><li>重载或重启服务：先加载，再启动<br> systemctl reload-or-restart name.service</li><li>重载或条件式重启服务：<br> systemctl reload-or-try-restart name.service</li><li>禁止自动和手动启动：<br> systemctl mask name.service</li><li>取消禁止：<br> systemctl unmask name.service</li></ul><h3 id="服务查看"><a href="#服务查看" class="headerlink" title="服务查看"></a>服务查看</h3><ul><li>查看某服务当前激活与否的状态：<br>systemctl is-active name.service</li><li>查看所有已经激活的服务：<br>systemctl list-units –type|-t service </li><li>查看所有服务：<br>systemctl list-units –type service –all|-a</li></ul><p><strong>chkconfig命令的对应关系：</strong></p><ul><li>设定某服务开机自启：<br>chkconfig name on ==&gt; systemctl enable name.service</li><li>设定某服务开机禁止启动：<br>chkconfig name off ==&gt; systemctl disable name.service</li><li>查看所有服务的开机自启状态：<br>chkconfig –list ==&gt; systemctl list-unit-files –type service </li><li>用来列出该服务在哪些运行级别下启用和禁用<br>chkconfig sshd–list ==&gt;ls /etc/systemd/system/*.wants/sshd.service</li><li>查看服务是否开机自启：<br>systemctl is-enabled name.service</li><li>其它命令：查看服务的依赖关系：<br>systemctl list-dependencies name.service</li><li>杀掉进程：<br>systemctl kill unitname</li></ul><h3 id="服务状态"><a href="#服务状态" class="headerlink" title="服务状态"></a>服务状态</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">systemctl list-unit-files --<span class="built_in">type</span> service --all显示状态</span><br><span class="line">    loaded:Unit:配置文件已处理</span><br><span class="line">    active(running):一次或多次持续处理的运行</span><br><span class="line">    active(exited):成功完成一次性的配置</span><br><span class="line">    active(waiting):运行中，等待一个事件</span><br><span class="line">    inactive:不运行</span><br><span class="line">    enabled:开机启动</span><br><span class="line">    disabled:开机不启动</span><br><span class="line">    static:开机不启动，但可被另一个启用的服务激活</span><br></pre></td></tr></table></figure><blockquote><p>注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的systemctl status命令。</p></blockquote><blockquote><p>一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</p></blockquote><h3 id="systemctl-命令示例"><a href="#systemctl-命令示例" class="headerlink" title="systemctl 命令示例"></a>systemctl 命令示例</h3><ul><li>显示所有单元状态<br>systemctl或systemctl list-units</li><li>只显示服务单元的状态<br>systemctl –type=service ==&gt;systemctl -t=service</li><li>显示sshd服务单元<br>systemctl –l status sshd.service</li><li>验证sshd服务当前是否活动<br>systemctl is-active sshd</li><li>启动，停止和重启sshd服务<br>systemctl start sshd.service<br>systemctl stop sshd.service<br>systemctl restart sshd.service</li><li>重新加载配置<br>systemctl reload sshd.service</li><li>列出活动状态的所有服务单元<br>systemctl list-units –type=service</li><li>列出所有服务单元<br>systemctl list-units –type=service –all</li><li>查看服务单元的启用和禁用状态<br>systemctl list-unit-files  –type=service</li><li>列出失败的服务<br>systemctl –failed –type=servicesy</li><li>列出依赖的单元<br>systemctl list-dependencies sshd</li><li>验证sshd服务是否开机启动<br>systemctl is-enabled sshd</li><li>禁用network，使之不能自动启动,但手动可以<br>systemctl disable network</li><li>启用network<br>systemctl enable  network</li><li>禁用network，使之不能手动或自动启动<br>systemctl mask network</li><li>启用network<br>systemctl unmask network</li></ul><h3 id="systemd-analyze"><a href="#systemd-analyze" class="headerlink" title="systemd-analyze"></a>systemd-analyze</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看启动耗时</span></span><br><span class="line">$ systemd-analyze                                                                                       </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看每个服务的启动耗时</span></span><br><span class="line">$ systemd-analyze blame</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示瀑布状的启动过程流</span></span><br><span class="line">$ systemd-analyze critical-chain</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 显示指定服务的启动流</span></span><br><span class="line">$ systemd-analyze critical-chain atd.service</span><br></pre></td></tr></table></figure><h3 id="hostnamectl查看当前主机的信息。"><a href="#hostnamectl查看当前主机的信息。" class="headerlink" title="hostnamectl查看当前主机的信息。"></a>hostnamectl查看当前主机的信息。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示当前主机的信息</span></span><br><span class="line">$ hostnamectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主机名。</span></span><br><span class="line">$ hostnamectl <span class="built_in">set</span>-hostname rhel7</span><br></pre></td></tr></table></figure><h3 id="localectl查看本地化设置。"><a href="#localectl查看本地化设置。" class="headerlink" title="localectl查看本地化设置。"></a>localectl查看本地化设置。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地化设置</span></span><br><span class="line">$ localectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地化参数。</span></span><br><span class="line">$ localectl <span class="built_in">set</span>-locale LANG=en_GB.utf8</span><br><span class="line">$ localectl <span class="built_in">set</span>-keymap en_GB  </span><br><span class="line">```  </span><br><span class="line"><span class="comment">### timedatectl查看当前时区设置。</span></span><br><span class="line">```bash</span><br><span class="line"><span class="comment"># 查看当前时区设置</span></span><br><span class="line">$ timedatectl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示所有可用的时区</span></span><br><span class="line">$ timedatectl list-timezones                                                                                   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前时区</span></span><br><span class="line">$ timedatectl <span class="built_in">set</span>-timezone America/New_York</span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time YYYY-MM-DD</span><br><span class="line">$ timedatectl <span class="built_in">set</span>-time HH:MM:SS</span><br></pre></td></tr></table></figure><h3 id="loginctl查看当前登录的用户。"><a href="#loginctl查看当前登录的用户。" class="headerlink" title="loginctl查看当前登录的用户。"></a>loginctl查看当前登录的用户。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出当前session</span></span><br><span class="line">$ loginctl list-sessions</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出当前登录用户</span></span><br><span class="line">$ loginctl list-users</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出显示指定用户的信息</span></span><br><span class="line">$ loginctl show-user ruanyf</span><br></pre></td></tr></table></figure><h3 id="service-unit文件格式"><a href="#service-unit文件格式" class="headerlink" title="service unit文件格式"></a>service unit文件格式</h3><ul><li>/etc/systemd/system：系统管理员和用户使用<br>/usr/lib/systemd/system：发行版打包者使用</li><li>以“#” 开头的行后面的内容会被认为是注释</li><li>相关布尔值，1、yes、on、true 都是开启，0、no、off、false 都是关闭</li><li>时间单位默认是秒，所以要用毫秒（ms）分钟（m）等须显式说明</li><li>service unit file文件通常由三部分组成：<br>[Unit]：定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等<br>[Service]：与特定类型相关的专用选项；此处为Service类型<br>[Install]：定义由“systemctlenable”以及”systemctldisable“命令在实现服务启用或禁用时用到的一些选项</li></ul><h4 id="Unit-段的常用选项："><a href="#Unit-段的常用选项：" class="headerlink" title="[Unit]段的常用选项："></a>[Unit]段的常用选项：</h4><p> Description：描述信息<br> Documentation：文档地址<br> Requires：依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活<br> Wants：依赖到的其它units，弱依赖<br> Conflicts：定义units间的冲突关系<br> Condition…：当前 Unit 运行必须满足的条件，否则不会运行<br> Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败<br> After：定义unit的启动次序，表示当前unit应该晚于哪些unit启动，其功能与Before相反<br> BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行<br> Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动</p><blockquote><p>从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如[Unit]。注意，配置文件的区块名和字段名，都是大小写敏感的。每个区块内部是一些等号连接的键值对;注意，键值对的等号两侧不能有空格.</p></blockquote><h4 id="Service-段的常用选项："><a href="#Service-段的常用选项：" class="headerlink" title="[Service]段的常用选项："></a>[Service]段的常用选项：</h4><p>[Service]区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</p><ul><li>Type：定义影响ExecStart及相关参数的功能的unit进程启动类型<br>Type=simple：默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中<br>Type=forking：由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止<br>Type=oneshot：与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中<br>Type=dbus：与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行<br>Type=notify：在启动完成后会发送一个通知消息。还需要配合NotifyAccess 来让Systemd 接收消息<br>Type=idle：与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务</li></ul><ul><li>EnvironmentFile：环境配置文件</li><li>ExecStart：指明启动unit要运行命令或脚本的绝对路径</li><li>ExecStartPre：ExecStart前运行(启动当前服务之前执行的命令)</li><li>ExecStartPost：ExecStart后运行(启动当前服务之后执行的命令)</li><li>ExecStop：指明停止unit要运行的命令或脚本(停止当前服务时执行的命令)</li><li>Restart：当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务(定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog)</li><li>ExecReload：重启当前服务时执行的命令</li><li>ExecStopPost：停止当其服务之后执行的命令</li><li>RestartSec：自动重启当前服务间隔的秒数</li><li>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数</li><li>Environment：指定环境变量</li></ul><h4 id="Install-段的常用选项："><a href="#Install-段的常用选项：" class="headerlink" title="[Install]段的常用选项："></a>[Install]段的常用选项：</h4><p>[Install]通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</p><ul><li>Alias：别名，可使用systemctlcommand Alias.service</li><li>RequiredBy：被哪些units所依赖，强依赖(它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中)</li><li>WantedBy：被哪些units所依赖，弱依赖(它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中)</li><li>Also：安装本服务的时候还要安装别的相关服务</li></ul><blockquote><p>注意：对于新创建的unit文件，或者修改了的unit文件，要通知systemd重载此配置文件,而后可以选择重启systemctl daemon-reload<br>Unit 配置文件的完整字段清单，请参考<a href="https://www.freedesktop.org/software/systemd/man/systemd.unit.html" target="_blank" rel="noopener">官方文档</a>。</p></blockquote><h3 id="服务Unit文件示例："><a href="#服务Unit文件示例：" class="headerlink" title="服务Unit文件示例："></a>服务Unit文件示例：</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/systemd/system/bak.service </span><br><span class="line">[Unit]</span><br><span class="line">Description=backup  /etc</span><br><span class="line">Requires=atd.service</span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">ExecStart=/bin/bash -c <span class="string">"echo /testdir/bak.sh|at now"</span></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>systemctl daemon-reload</li><li>systemctl start bak</li><li>启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</li><li>简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于”状态点”，启动某个 Target 就好比启动到某种状态。</li><li>传统的init启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</li></ul><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> target units：</span><br><span class="line">     unit配置文件：.target</span><br><span class="line">     ls /usr/lib/systemd/system/*.target</span><br><span class="line">     systemctl list-unit-files --<span class="built_in">type</span> target  --all</span><br><span class="line"> 运行级别：</span><br><span class="line"> 0  ==&gt; runlevel0.target -&gt; poweroff.target</span><br><span class="line"> 1  ==&gt; runlevel1.target -&gt; rescue.target</span><br><span class="line"> 2  ==&gt; runlevel2.target -&gt; multi-user.target</span><br><span class="line"> 3  ==&gt; runlevel3.target -&gt; multi-user.target</span><br><span class="line"> 4  ==&gt; runlevel4.target -&gt; multi-user.target</span><br><span class="line"> 5  ==&gt; runlevel5.target -&gt; graphical.target</span><br><span class="line"> 6  ==&gt; runlevel6.target -&gt; reboot.target</span><br><span class="line"> </span><br><span class="line">（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</span><br><span class="line"> </span><br><span class="line">（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</span><br><span class="line"> </span><br><span class="line">（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。</span><br><span class="line"> </span><br><span class="line"> 查看依赖性：</span><br><span class="line"> systemctl list-dependencies graphical.target</span><br><span class="line"> </span><br><span class="line"> 级别切换：</span><br><span class="line"> initN ==&gt; systemctl isolate name.target</span><br><span class="line"> systemctl isolate multi-user.target</span><br><span class="line"> 注：只有/lib/systemd/system/*.target文件中AllowIsolate=yes 才能切换(修改文件需执行systemctl daemon-reload才能生效)</span><br><span class="line"> </span><br><span class="line"> 查看target：</span><br><span class="line"> runlevel;   who -r</span><br><span class="line"> systemctl list-units --<span class="built_in">type</span> target</span><br><span class="line"> </span><br><span class="line"> 获取默认运行级别：</span><br><span class="line"> /etc/inittab==&gt; systemctl get-default</span><br><span class="line"> 修改默认级别：</span><br><span class="line"> /etc/inittab==&gt; systemctl <span class="built_in">set</span>-default name.target</span><br><span class="line"> systemctl <span class="built_in">set</span>-default multi-user.target</span><br><span class="line"> ls –l /etc/systemd/system/default.target</span><br><span class="line"> </span><br><span class="line"> 其它命令</span><br><span class="line"> 切换至紧急救援模式（单用户状态）：</span><br><span class="line"> systemctl rescue </span><br><span class="line"> 切换至emergency模式： </span><br><span class="line"> systemctl emergency</span><br><span class="line"> 其它常用命令：</span><br><span class="line"> 传统命令init，poweroff，halt，reboot都成为systemctl的软链接</span><br><span class="line"> 关机：systemctl halt、systemctl poweroff</span><br><span class="line"> 重启：systemctl reboot</span><br><span class="line"> 挂起：systemctl <span class="built_in">suspend</span></span><br><span class="line"> 休眠：systemctl hibernate</span><br><span class="line"> 休眠并挂起：systemctl hybrid-sleep</span><br></pre></td></tr></table></figure><p> Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用<code>journalctl</code>一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是<code>/etc/systemd/journald.conf</code></p><h3 id="journalctl功能强大，用法非常多。"><a href="#journalctl功能强大，用法非常多。" class="headerlink" title="journalctl功能强大，用法非常多。"></a>journalctl功能强大，用法非常多。</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有日志（默认情况下 ，只保存本次启动的日志）</span></span><br><span class="line">$ journalctl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看内核日志（不显示应用日志）</span></span><br><span class="line">$ journalctl -k</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看系统本次启动的日志</span></span><br><span class="line">$ journalctl -b</span><br><span class="line">$ journalctl -b -0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看上一次启动的日志（需更改设置）</span></span><br><span class="line">$ journalctl -b -1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定时间的日志</span></span><br><span class="line">$ journalctl --since=<span class="string">"2012-10-30 18:17:16"</span></span><br><span class="line">$ journalctl --since <span class="string">"20 min ago"</span></span><br><span class="line">$ journalctl --since yesterday</span><br><span class="line">$ journalctl --since <span class="string">"2015-01-10"</span> --until <span class="string">"2015-01-11 03:00"</span></span><br><span class="line">$ journalctl --since 09:00 --until <span class="string">"1 hour ago"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部的最新10行日志</span></span><br><span class="line">$ journalctl -n</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示尾部指定行数的日志</span></span><br><span class="line">$ journalctl -n 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示最新日志</span></span><br><span class="line">$ journalctl -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定服务的日志</span></span><br><span class="line">$ journalctl /usr/lib/systemd/systemd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定进程的日志</span></span><br><span class="line">$ journalctl _PID=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个路径的脚本的日志</span></span><br><span class="line">$ journalctl /usr/bin/bash</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定用户的日志</span></span><br><span class="line">$ journalctl _UID=33 --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service</span><br><span class="line">$ journalctl -u nginx.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实时滚动显示某个 Unit 的最新日志</span></span><br><span class="line">$ journalctl -u nginx.service -f</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并显示多个 Unit 的日志</span></span><br><span class="line">$ journalctl -u nginx.service -u php-fpm.service --since today</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看指定优先级（及其以上级别）的日志，共有8级</span></span><br><span class="line"><span class="comment"># 0: emerg</span></span><br><span class="line"><span class="comment"># 1: alert</span></span><br><span class="line"><span class="comment"># 2: crit</span></span><br><span class="line"><span class="comment"># 3: err</span></span><br><span class="line"><span class="comment"># 4: warning</span></span><br><span class="line"><span class="comment"># 5: notice</span></span><br><span class="line"><span class="comment"># 6: info</span></span><br><span class="line"><span class="comment"># 7: debug</span></span><br><span class="line">$ journalctl -p err -b</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志默认分页输出，--no-pager 改为正常的标准输出</span></span><br><span class="line">$ journalctl --no-pager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（单行）输出</span></span><br><span class="line">$ journalctl -b -u nginx.service -o json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以 JSON 格式（多行）输出，可读性更好</span></span><br><span class="line">$ journalctl -b -u nginx.serviceqq</span><br><span class="line">-o json-pretty</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示日志占据的硬盘空间</span></span><br><span class="line">$ journalctl --disk-usage</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件占据的最大空间</span></span><br><span class="line">$ journalctl --vacuum-size=1G</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件保存多久</span></span><br><span class="line">$ journalctl --vacuum-time=1years</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://zhangqifei.top/picture/ifeier/data/systemd.jpg&quot; width=&quot;500&quot; height=&quot;200&quot; alt=&quot;markdown&quot; align=&quot;center&quot;&gt;&lt;/center&gt;&lt;br
      
    
    </summary>
    
      <category term="centos" scheme="https://www.zhangqifei.top/categories/centos/"/>
    
    
      <category term="centos7" scheme="https://www.zhangqifei.top/tags/centos7/"/>
    
  </entry>
  
  <entry>
    <title>一次完整的http请求处理过程</title>
    <link href="https://www.zhangqifei.top/2017/05/05/%E9%9A%8F%E7%AC%94/%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84http%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B/"/>
    <id>https://www.zhangqifei.top/2017/05/05/随笔/一次完整的http请求处理过程/</id>
    <published>2017-05-05T01:12:22.000Z</published>
    <updated>2018-04-23T07:12:14.436Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Web服务请求处理步骤"><a href="#Web服务请求处理步骤" class="headerlink" title="Web服务请求处理步骤"></a>Web服务请求处理步骤</h3><center><img src="http://zhangqifei.top/picture/httpd/4.jpg" alt="Web服务请求处理步骤"></center><h4 id="一次完整的http请求处理过程"><a href="#一次完整的http请求处理过程" class="headerlink" title="一次完整的http请求处理过程"></a>一次完整的http请求处理过程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">1、建立连接：接收或拒绝连接请求</span><br><span class="line">2、接收请求：接收客户端请求报文中对某资源的一次请求的过程</span><br><span class="line">3、处理请求：服务器对请求报文进行解析，并获取请求的资源及请求方法等相关信息，根据方法，资源，首部和可选的主体部分对请求进行处理</span><br><span class="line">    元数据：请求报文首部</span><br><span class="line">    &lt;method&gt; &lt;URL&gt; &lt;VERSION&gt;</span><br><span class="line">    HEADERS格式name:value</span><br><span class="line">    &lt;request body&gt;</span><br><span class="line">    示例：</span><br><span class="line">    Host: www.chuyuni.cn   请求的主机名称</span><br><span class="line">    Server: Apache/2.4.7</span><br><span class="line">HTTP常用请求方式，MethodGET、POST、HEAD、PUT、DELETE、TRACE、OPTIONS</span><br><span class="line">4、访问资源：服务器获取请求报文中请求的资源web服务器，即存放了web资源的服务器，负责向请求者提供对方请求的静态资源，或动态运行后生成的资源</span><br><span class="line">        资源放置于本地文件系统特定的路径：DocRoot</span><br><span class="line">        DocRoot → /var/www/html</span><br><span class="line">        /var/www/html/images/logo.jpg</span><br><span class="line">        http://www.magedu.com/images/logo.jpg</span><br><span class="line">    web服务器资源路径映射方式：</span><br><span class="line">    (a) docroot        (b) alias</span><br><span class="line">    (c) 虚拟主机docroot(d) 用户家目录docroot</span><br><span class="line">5、构建响应报文：一旦Web服务器识别除了资源，就执行请求方法中描述的动作，并返回响应报文。响应报文中包含有响应状态码、响应首部，如果生成了响应主体的话，还包括响应主体</span><br><span class="line">    1）响应实体：如果事务处理产生了响应主体，就将内容放在响应报文中回送过去。响应报文中通常包括：描述了响应主体MIME类型的Content-Type首部描述了响应主体长度的Content-Length实际报文的主体内容</span><br><span class="line">    2）URL重定向：web服务构建的响应并非客户端请求的资源，而是资源另外一个访问路径</span><br><span class="line">    永久重定向：http://www.360buy.com</span><br><span class="line">    临时重定向：http://www.taobao.com</span><br><span class="line">    3）MIME类型：Web服务器要负责确定响应主体的MIME类型。多种配置服务器的方法可将MIME类型与资源管理起来魔法分类：Apache web服务器可以扫描每个资源的内容，并将其与一个已知模式表(被称为魔法文件)进行匹配，以决定每个文件的MIME类型。这样做可能比较慢，但很方便，尤其是文件没有标准扩展名时显式分类：可以对Web服务器进行配置，使其不考虑文件的扩展名或内容，强制特定文件或目录内容拥有某个MIME类型类型协商：有些Web服务器经过配置，可以以多种文档格式来存储资源。在这种情况下，可以配置Web服务器，使其可以通过与用户的协商来决定使用哪种格式(及相关的MIME类型)&quot;最好&quot;</span><br><span class="line">    </span><br><span class="line">6、发送响应报文：Web服务器通过连接发送数据时也会面临与接收数据一样的问题。服务器可能有很多条到各个客户端的连接，有些是空闲的，有些在向服务器发送数据，还有一些在向客户端回送响应数据。服务器要记录连接的状态，还要特别注意对持久连接的处理。对非持久连接而言，服务器应该在发送了整条报文之后，关闭自己这一端的连接。对持久连接来说，连接可能仍保持打开状态，在这种情况下，服务器要正确地计算Content-Length首部，不然客户端就无法知道响应什么时候结束了</span><br><span class="line"></span><br><span class="line">7、记录日志：最后，当事务结束时，Web服务器会在日志文件中添加一个条目，来描述已执行的事务</span><br></pre></td></tr></table></figure><p>Web访问响应模型（Web I/O）</p><blockquote><ul><li>单进程I/O模型：启动一个进程处理用户请求，而且一次只处理一个，多个请求被串行响应</li><li>多进程I/O模型：并行启动多个进程,每个进程响应一个连接请求</li><li>复用I/O结构：启动一个进程，同时响应N个连接请求实现方法：多线程模型和事件驱动多线程模型：一个进程生成N个线程，每线程响应一个连接请求事件驱动：一个进程处理N个请求</li><li>复用的多进程I/O模型：启动M个进程，每个进程响应N个连接请求，同时接收M*N个请求</li></ul></blockquote><center><img src="http://zhangqifei.top/picture/httpd/5.jpg" alt="Web访问响应模型"></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Web服务请求处理步骤&quot;&gt;&lt;a href=&quot;#Web服务请求处理步骤&quot; class=&quot;headerlink&quot; title=&quot;Web服务请求处理步骤&quot;&gt;&lt;/a&gt;Web服务请求处理步骤&lt;/h3&gt;&lt;center&gt;&lt;img src=&quot;http://zhangqifei.t
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
    
      <category term="HTTP" scheme="https://www.zhangqifei.top/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>Linux各发行版时间线2017年版本</title>
    <link href="https://www.zhangqifei.top/2017/03/05/linux/Linux%E5%90%84%E5%8F%91%E8%A1%8C%E7%89%88%E6%97%B6%E9%97%B4%E7%BA%BF2017%E5%B9%B4%E7%89%88%E6%9C%AC/"/>
    <id>https://www.zhangqifei.top/2017/03/05/linux/Linux各发行版时间线2017年版本/</id>
    <published>2017-03-05T14:47:20.000Z</published>
    <updated>2018-04-22T09:30:14.906Z</updated>
    
    <content type="html"><![CDATA[<center><img src="http://zhangqifei.top/picture/ifeier/data/linux.jpg" width="500" height="200" alt="linux" align="center"></center><p>时间线目前版本16.12，于2017年2月1日发布，参见<a href="https://en.wikipedia.org/wiki/File:Linux_Distribution_Timeline.svg" target="_blank" rel="noopener">wikipedia</a></p><p>svg图片太长，无法显示，可以点击链接下载:<a href="https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg" target="_blank" rel="noopener">点这儿</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;&lt;img src=&quot;http://zhangqifei.top/picture/ifeier/data/linux.jpg&quot; width=&quot;500&quot; height=&quot;200&quot; alt=&quot;linux&quot; align=&quot;center&quot;&gt;&lt;/center&gt;


&lt;p&gt;时间
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
    
      <category term="Linux" scheme="https://www.zhangqifei.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux防火墙</title>
    <link href="https://www.zhangqifei.top/2017/03/04/linux/Linux%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    <id>https://www.zhangqifei.top/2017/03/04/linux/Linux防火墙/</id>
    <published>2017-03-04T01:42:22.000Z</published>
    <updated>2018-04-22T09:29:33.353Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安全技术"><a href="#安全技术" class="headerlink" title="安全技术"></a>安全技术</h3><ul><li><strong>入侵检测与管理系统</strong>（Intrusion Detection Systems）：特点是不阻断任何网络访问，量化、定位来自内外网络的威胁情况，主要以提供报告和事后监督为主，提供有针对性的指导措施和安全决策依据。一般采用旁路部署方式</li><li><strong>入侵防御系统</strong>（Intrusion Prevention System）：以透明模式工作，分析数据包的内容如：溢出攻击、拒绝服务攻击、木马、蠕虫、系统漏洞等进行准确的分析判断，在判定为攻击行为后立即予以阻断，主动而有效的保护网络的安全，一般采用在线部署方式</li><li><strong>防火墙</strong>（FireWall ）：隔离功能，工作在网络或主机边缘，对进出网络或主机的数据包基于一定的规则检查，并在匹配某规则时由规则定义的行为进行处理的一组功能的组件，基本上的实现都是默认情况下关闭所有的通过型访问，只开放允许访问的策略</li></ul><h3 id="防火墙的分类"><a href="#防火墙的分类" class="headerlink" title="防火墙的分类"></a>防火墙的分类</h3><ul><li>主机防火墙：服务范围为当前主机</li><li>网络防火墙：服务范围为防火墙一侧的局域网</li><li>硬件防火墙：在专用硬件级别实现部分功能的防火墙；另一个部分功能基于软件实现，Checkpoint,NetScreen</li><li>软件防火墙：运行于通用硬件平台之上的防火墙的应用软件</li><li>网络层防火墙：OSI下面第三层</li><li>应用层防火墙/代理服务器：代理网关，OSI七层</li></ul><h4 id="网络型防火墙"><a href="#网络型防火墙" class="headerlink" title="网络型防火墙"></a>网络型防火墙</h4><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301140229118.png" alt="网络型防火墙"><br></center><ul><li>包过滤防火墙</li><li>网络层对数据包进行选择，选择的依据是系统内设置的过滤逻辑，被称为访问控制列表（ACL），通过检查数据流中每个数据的源地址，目的地址，所用端口号和协议状态等因素，或他们的组合来确定是否允许该数据包通过</li><li><strong>优点：</strong>对用户来说透明，处理速度快且易于维护</li><li><strong>缺点：</strong>无法检查应用层数据，如病毒等</li></ul><h4 id="应用层防火墙"><a href="#应用层防火墙" class="headerlink" title="应用层防火墙"></a>应用层防火墙</h4><p>应用层防火墙/代理服务型防火墙（Proxy Service）</p><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301140314791.png" alt="应用层防火墙"><br></center><ul><li>将所有跨越防火墙的网络通信链路分为两段</li><li>内外网用户的访问都是通过代理服务器上的“链接”来实现</li><li><strong>优点：</strong>在应用层对数据进行检查，比较安全</li><li><strong>缺点：</strong>增加防火墙的负载</li><li>现实生产环境中所使用的防火墙一般都是二者结合体</li><li>即先检查网络数据，通过之后再送到应用层去检查</li></ul><h3 id="iptables的基本认识"><a href="#iptables的基本认识" class="headerlink" title="iptables的基本认识"></a>iptables的基本认识</h3><p>Netfilter组件</p><ul><li>内核空间，集成在linux内核中</li><li>扩展各种网络服务的结构化底层框架</li><li>内核中选取五个位置放了五个hook(勾子) function(INPUT、OUTPUT、FORWARD、PREROUTING、POSTROUTING)，而这五个hook function向用户开放，用户可以通过一个命令工具（iptables）向其写入规则</li><li>由信息过滤表（table）组成，包含控制IP包处理的规则集（rules），规则被分组放在链（chain）上</li></ul><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301144916228.png" alt="五个链"><br></center><p><strong>内核中数据包的传输过程</strong></p><ul><li>当一个数据包进入网卡时，数据包首先进入PREROUTING链，内核根据数据包目的IP判断是否需要转送出去</li><li>如果数据包就是进入本机的，数据包就会沿着图向下移动，到达INPUT链。数据包到达INPUT链后，任何进程都会收到它。本机上运行的程序可以发送数据包，这些数据包经过OUTPUT链，然后到达POSTROUTING链输出</li><li>如果数据包是要转发出去的，且内核允许转发，数据包就会向右移动，经过FORWARD链，然后到达POSTROUTING链输出</li></ul><h4 id="三种报文流向："><a href="#三种报文流向：" class="headerlink" title="三种报文流向："></a>三种报文流向：</h4><ul><li><strong>流入本机：</strong> PREROUTING –&gt; INPUT–&gt;用户空间进程</li><li><strong>流出本机：</strong> 用户空间进程–&gt;OUTPUT–&gt; POSTROUTING</li><li><strong>转发：</strong> PREROUTING –&gt; FORWARD –&gt; POSTROUTING</li></ul><h3 id="防火墙工具"><a href="#防火墙工具" class="headerlink" title="防火墙工具"></a>防火墙工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iptables</span><br><span class="line">    命令行工具，工作在用户空间</span><br><span class="line">    用来编写规则，写好的规则被送往netfilter，告诉内核如何去处理信息包</span><br><span class="line">firewalld</span><br><span class="line">    CentOS 7引入了新的前端管理工具</span><br><span class="line">    管理工具：</span><br><span class="line">        firewall-cmd命令行</span><br><span class="line">        firewall-config图形</span><br></pre></td></tr></table></figure><h3 id="iptables的组成"><a href="#iptables的组成" class="headerlink" title="iptables的组成"></a>iptables的组成</h3><p>iptables由<strong>四个表</strong>和<strong>五个链</strong>以及一些规则组成<br><strong>四个表table：</strong></p><ul><li><strong>filter表:</strong> 过滤规则表，根据预定义的规则过滤符合条件的数据包</li><li><strong>nat表:</strong> network address translation 地址转换规则表</li><li><strong>mangle:</strong> 修改数据标记位规则表</li><li><strong>Raw:</strong> 关闭NAT表上启用的连接跟踪机制，加快封包穿越防火墙速度</li></ul><p><strong>优先级由高到低:</strong> raw–&gt;mangle–&gt;nat–&gt;filter<br><strong>五个内置链chain</strong></p><ul><li>INPUT</li><li>OUTPUT</li><li>FORWARD</li><li>PREROUTING</li><li>POSTROUTING</li></ul><h4 id="Netfilter表和链对应关系"><a href="#Netfilter表和链对应关系" class="headerlink" title="Netfilter表和链对应关系"></a>Netfilter表和链对应关系</h4><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301140524380.png" alt="Netfilter表和链对应关系"><br>优先级由高到低: raw -&gt; mangle -&gt; nat -&gt; filter<br></center><h4 id="数据包过滤匹配流程"><a href="#数据包过滤匹配流程" class="headerlink" title="数据包过滤匹配流程"></a>数据包过滤匹配流程</h4><center><br><img src="https://raw.githubusercontent.com/zhangqifei/picture/master/iptables/20180301141001934.png" alt="数据包过滤匹配流程"><br></center><h3 id="iptables规则"><a href="#iptables规则" class="headerlink" title="iptables规则"></a>iptables规则</h3><p><strong>规则rule：</strong>根据规则的匹配条件尝试匹配报文，对匹配成功的报文根据规则定义的处理动作作出处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">匹配条件：默认为与条件，同时满足</span><br><span class="line">基本匹配：IP,端口,TCP的Flags（SYN,ACK等）</span><br><span class="line">扩展匹配：通过复杂高级功能匹配</span><br><span class="line">处理动作：称为target，跳转目标</span><br><span class="line">内建处理动作：ACCEPT(接收),DROP(婉转的拒绝),REJECT(强硬的拒绝),SNAT,DNAT,MASQUERADE,MARK,LOG...</span><br><span class="line">自定义处理动作：自定义chain，利用分类管理复杂情形</span><br></pre></td></tr></table></figure></p><blockquote><p>规则要添加在链上，才生效；添加在自定义上不会自动生效<br>链chain：<br>:   <strong>内置链：</strong>每个内置链对应于一个钩子函数<br>    <strong>自定义链：</strong>用于对内置链进行扩展或补充，可实现更灵活的规则组织管理机制；只有Hook钩子调用自定义链时，才生效</p></blockquote><p><strong>iptables规则添加时考量点</strong></p><ul><li>要实现哪种功能：判断添加在哪张表上</li><li>报文流经的路径：判断添加在哪个链上</li><li>报文的流向：判断源和目的</li><li>匹配规则：业务需要</li></ul><p><strong>链上规则的次序，即为检查的次序，因此隐含一定的法则</strong></p><ul><li>同类规则(访问同一应用)，匹配范围小的放上面</li><li>不同类规则(访问不同应用)，匹配到报文频率较大的放上面</li><li>将那些可由一条规则描述的多个规则合并为一个</li><li>设置默认策略</li></ul><p><strong>实验环境准备：</strong></p><ul><li><strong>Centos7:</strong> <ul><li><code>systemctl stop firewalld.service</code> </li><li><code>systemctl disable firewalld.service</code></li></ul></li><li><strong>Centos6:</strong> <ul><li><code>service iptables stop</code> </li><li><code>chkconfig iptables off</code></li></ul></li></ul><h3 id="iptables命令"><a href="#iptables命令" class="headerlink" title="iptables命令"></a>iptables命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">man 8 iptables</span><br><span class="line"></span><br><span class="line">iptables [-t table] &#123;-A|-C|-D&#125; chain rule-specification</span><br><span class="line"></span><br><span class="line">iptables [-t table] -I chain [rulenum] rule-specification</span><br><span class="line"></span><br><span class="line">iptables [-t table] -R chain rulenum rule-specification</span><br><span class="line"></span><br><span class="line">iptables [-t table] -D chain rulenum</span><br><span class="line"></span><br><span class="line">iptables [-t table] -S [chain [rulenum]]</span><br><span class="line"></span><br><span class="line">iptables [-t table] &#123;-F|-L|-Z&#125; [chain [rulenum]] [options...]</span><br><span class="line"></span><br><span class="line">iptables [-t table] -N chain</span><br><span class="line"></span><br><span class="line">iptables [-t table] -X [chain]</span><br><span class="line"></span><br><span class="line">iptables [-t table] -P chain target</span><br><span class="line"></span><br><span class="line">iptables [-t table] -E old-chain-name new-chain-name</span><br><span class="line"></span><br><span class="line">rule-specification = [matches...] [target]</span><br><span class="line"></span><br><span class="line">match = -m matchname [per-match-options]</span><br><span class="line"></span><br><span class="line">target = -j targetname [per-target-options]</span><br></pre></td></tr></table></figure><p><strong>示例1：</strong><br>从172.18.99.1来的所有全部拒绝访问<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@centos7 ~]#iptables -A INPUT -s 172.18.99.1 -j DROP</span><br><span class="line">-A 添加 -I 插入 -s 后指定源地址 -j 策略</span><br></pre></td></tr></table></figure></p><h3 id="iptables命令规则格式："><a href="#iptables命令规则格式：" class="headerlink" title="iptables命令规则格式："></a>iptables命令规则格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">iptables [-t table] SUBCOMMAND chain [-m matchname[per-match-options]] -j targetname[per-target-options]</span><br><span class="line">--------------------------------</span><br><span class="line">-t table(表)：raw, mangle, nat, [filter]默认</span><br><span class="line">--------------------------------</span><br><span class="line">SUBCOMMAND(子命令)：</span><br><span class="line">1、链管理：</span><br><span class="line">-N：new, 自定义一条新的规则链</span><br><span class="line">-X：delete，删除自定义的空的规则链</span><br><span class="line">-P：Policy，设置默认策略；对filter表中的链而言，其默认策略有：</span><br><span class="line">ACCEPT：接受 </span><br><span class="line">DROP：丢弃 </span><br><span class="line">-E：重命名自定义链；引用计数不为0的自定义链不能够被重命名，也不能被删除</span><br><span class="line">2、查看：</span><br><span class="line">-L：list, 列出指定鏈上的所有规则，本选项须置后</span><br><span class="line">-n：numberic，以数字格式显示地址和端口号</span><br><span class="line">-v：verbose，详细信息 </span><br><span class="line">-vv更详细 </span><br><span class="line">-x：exactly，显示计数器结果的精确值,而非单位转换后的易读值(字节数更精确) </span><br><span class="line">--line-numbers：显示规则的序号 </span><br><span class="line">常用组合：</span><br><span class="line">--vnL </span><br><span class="line">--vvnxL --line-numbers </span><br><span class="line">-S selected,以iptables-save 命令格式显示链上规则</span><br><span class="line">3、规则管理：</span><br><span class="line">-A：append，追加 </span><br><span class="line">-I：insert, 插入，要指明插入至的规则编号，默认为第一条 </span><br><span class="line">-D：delete，删除(1) 指明规则序号(2) 指明规则本身 </span><br><span class="line">-R：replace，替换指定链上的指定规则编号 </span><br><span class="line">-F：flush，清空指定的规则链 </span><br><span class="line">-Z：zero，置零(包数指从头开始)</span><br><span class="line">iptables的每条规则都有两个计数器 </span><br><span class="line">(1) 匹配到的报文的个数 </span><br><span class="line">(2) 匹配到的所有报文的大小之和</span><br><span class="line">--------------------------------</span><br><span class="line">chain：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING</span><br><span class="line">匹配条件</span><br><span class="line">基本：通用的，PARAMETERS</span><br><span class="line">扩展：需加载模块，MATCH EXTENTIONS</span><br><span class="line">1、基本匹配条件：无需加载模块，由iptables/netfilter自行提供</span><br><span class="line">[!] -s, --source  address[/mask][,...]：源IP地址或范围 </span><br><span class="line">[!] -d, --destination address[/mask][,...]：目标IP地址或范围 </span><br><span class="line">[!] -p, --protocol protocol：指定协议，可使用数字如0（all） </span><br><span class="line">protocol: tcp, udp, icmp, icmpv6,udplite,esp, ah, sctp, mhor  "all"  参看：/etc/protocols </span><br><span class="line">[!] -i, --in-interface name：报文流入的接口；只能应用于数据报文流入环节，只应用于INPUT、FORWARD、PREROUTING链 </span><br><span class="line">[!] -o, --out-interface name：报文流出的接口；只能应用于数据报文流出的环节，只应用于FORWARD、OUTPUT、POSTROUTING链</span><br><span class="line">2 扩展匹配条件：需要加载扩展模块（/usr/lib64/xtables/*.so），方可生效</span><br><span class="line">查看帮助man iptables-extensions</span><br><span class="line">(1)隐式扩展：在使用-p选项指明了特定的协议时，无需再用-m选项指明扩展模块的扩展机制，不需要手动加载扩展模块</span><br><span class="line">tcp协议的扩展选项</span><br><span class="line">[!] --source-port, --sport port[:port]：匹配报文源端口,可为端口范围 </span><br><span class="line">[!] --destination-port,--dportport[:port]：匹配报文目标端口,可为范围 </span><br><span class="line">[!] --tcp-flags mask comp</span><br><span class="line">mask 需检查的标志位列表，用,分隔 例如SYN,ACK,FIN,RST</span><br><span class="line">comp 在mask列表中必须为1的标志位列表，无指定则必须为0，用,分隔</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">--tcp-flags SYN,ACK,FIN,RST  SYN  表示要检查的标志位为SYN,ACK,FIN,RST四个，其中SYN必须为1，余下的必须为0 </span><br><span class="line">--tcp-flags SYN,ACK,FIN,RST SYN,ACK </span><br><span class="line">--tcp-flags ALL ALL </span><br><span class="line">--tcp_flagsALL NONE</span><br><span class="line">[!] --syn：用于匹配第一次握手</span><br><span class="line">相当于：--tcp-flags SYN,ACK,FIN,RST  SYN</span><br><span class="line"></span><br><span class="line">udp协议的扩展选项</span><br><span class="line">[!] --source-port, --sport port[:port]：匹配报文的源端口；可以是端口范围 </span><br><span class="line">[!] --destination-port,--dportport[:port]：匹配报文的目标端口；可以是端口范围</span><br><span class="line">icmp协议的扩展选项 </span><br><span class="line">[!] --icmp-type &#123;type[/code]|typename&#125;</span><br><span class="line">type/code </span><br><span class="line">0/0   echo-replyicmp应答 </span><br><span class="line">8/0   echo-request icmp请求</span><br><span class="line">(2)显式扩展：必须使用-m选项指明要调用的扩展模块的扩展机制，要手动加载扩展模块</span><br><span class="line">[-m matchname[per-match-options]]</span><br><span class="line">处理动作：</span><br><span class="line">-j targetname [per-target-options]</span><br><span class="line">简单：ACCEPT，DROP</span><br><span class="line">扩展：REJECT：--reject-with:icmp-port-unreachable默认 </span><br><span class="line">RETURN：返回调用链 </span><br><span class="line">REDIRECT：端口重定向 </span><br><span class="line">LOG：记录日志，dmesg </span><br><span class="line">MARK：做防火墙标记 </span><br><span class="line">DNAT：目标地址转换 </span><br><span class="line">SNAT：源地址转换 </span><br><span class="line">MASQUERADE：地址伪装</span><br><span class="line">... </span><br><span class="line">自定义链：</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Chain INPUT (policy ACCEPT 21144 packets, 3008K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line">   21  1954 DROP       all  --  *      *       172.18.99.1          0.0.0.0/0           </span><br><span class="line">   16  1320 REJECT     all  --  *      *       172.18.99.1          0.0.0.0/0            reject-with icmp-port-unreachable</span><br><span class="line">pkts:包数</span><br><span class="line">bytes:字节数</span><br><span class="line">target:处理动作</span><br><span class="line">prot:协议</span><br><span class="line">opt:</span><br><span class="line">in:传入</span><br><span class="line">out:传出</span><br><span class="line">source:原地址 </span><br><span class="line">destination:目标地址</span><br></pre></td></tr></table></figure><p>······持续更新中······</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;安全技术&quot;&gt;&lt;a href=&quot;#安全技术&quot; class=&quot;headerlink&quot; title=&quot;安全技术&quot;&gt;&lt;/a&gt;安全技术&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;入侵检测与管理系统&lt;/strong&gt;（Intrusion Detection Systems）：
      
    
    </summary>
    
      <category term="linux" scheme="https://www.zhangqifei.top/categories/linux/"/>
    
    
      <category term="防火墙" scheme="https://www.zhangqifei.top/tags/%E9%98%B2%E7%81%AB%E5%A2%99/"/>
    
  </entry>
  
  <entry>
    <title>Chrome浏览器最牛插件之一 Vimium</title>
    <link href="https://www.zhangqifei.top/2017/02/08/%E5%B7%A5%E5%85%B7/Chrome%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9C%80%E7%89%9B%E6%8F%92%E4%BB%B6%E4%B9%8B%E4%B8%80%20Vimium/"/>
    <id>https://www.zhangqifei.top/2017/02/08/工具/Chrome浏览器最牛插件之一 Vimium/</id>
    <published>2017-02-08T00:33:59.000Z</published>
    <updated>2018-04-23T07:12:34.107Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vimium"><a href="#vimium" class="headerlink" title="vimium"></a>vimium</h2><p>Vimium 这个名字其实是 Vim 和 Chromium 的合体。很多人可能不知道 Vim，Vim 其实是 Linux 等平台上的一款文本编辑器，熟练的运用它可以彻底脱离鼠标，通过一系列快捷键，来操作写代码。<br>而 Vimium 则继承了 Vim 中的常用操作，让你在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。想像一下，你再也不需要移动鼠标去打开一个链接，手指不用离开键盘，这一切将会是多么的幸福。</p><p><center><img src="http://zhangqifei.top/picture/ifeier/chrome/vimium.jpg" width="500" height="200" alt="vimium" align="center"></center><br>废话不多说，直接上快捷键😁.上操作命令</p><h3 id="导航当页"><a href="#导航当页" class="headerlink" title="导航当页"></a>导航当页</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">?       显示help，查询vimium的所有使用方法</span><br><span class="line">h       向左滚动</span><br><span class="line">j       向下滚动</span><br><span class="line">k       向上滚动</span><br><span class="line">l       向右滚动</span><br><span class="line">gg      滚动到顶部</span><br><span class="line">G       滚动到底部</span><br><span class="line">d       向下滚动半页</span><br><span class="line">u       向上滚动半页面</span><br><span class="line">f       显示链接字母，在当前页面打开</span><br><span class="line">F       显示链接字母，在新的页面打开</span><br><span class="line">r       刷新</span><br><span class="line">gs      显示网页源代码</span><br><span class="line">i       进入插入模式，所有按键的命令都无效，直至ESC键退出</span><br><span class="line">yy      将当前的网址复制到剪贴板</span><br><span class="line">yf      显示链接字母，并将网址拷贝到剪贴板</span><br><span class="line">gf      cycle forward to the next frame</span><br><span class="line">gF      focus the main/top frame</span><br></pre></td></tr></table></figure><h3 id="打开新的页面"><a href="#打开新的页面" class="headerlink" title="打开新的页面"></a>打开新的页面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">o       搜索网址，书签，或历史记录，在当前页面打开</span><br><span class="line">O       搜索网址，书签，或历史记录，在新的页面打开</span><br><span class="line">b       搜索书签，在当前页面打开</span><br><span class="line">B       搜索书签，在新的页面打开</span><br></pre></td></tr></table></figure><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/       进入查找模式，输入关键字查找，ESC退出</span><br><span class="line">n       切换到下一个匹配</span><br><span class="line">N       切换到上一个匹配</span><br></pre></td></tr></table></figure><h3 id="前进后退"><a href="#前进后退" class="headerlink" title="前进后退"></a>前进后退</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">H       后退</span><br><span class="line">L       前进</span><br></pre></td></tr></table></figure><h3 id="切换tab"><a href="#切换tab" class="headerlink" title="切换tab"></a>切换tab</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">J, gT   切换到左边tab</span><br><span class="line">K, gt   切换到右边tab</span><br><span class="line">g0      切换到第一个tab</span><br><span class="line">g$      切换到最后一个tab</span><br><span class="line">^       切换到刚才的tab</span><br><span class="line">t       创建一个新的页面</span><br><span class="line">yt      复制当前页面</span><br><span class="line">x       关闭当前页面</span><br><span class="line">X       恢复刚才关闭的页面</span><br><span class="line">T       在当前所有的tab页面中搜索</span><br><span class="line">&lt;a-p&gt;   pin/unpin current tab</span><br></pre></td></tr></table></figure><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ma      当页标记，只能在当前tab页面跳转，m + 一个小写字母</span><br><span class="line">mA      全局标记，可以再切换到其他tab的跳转过来，m + 一个大写字母</span><br><span class="line">`a      跳转到当页标记</span><br><span class="line">`A      跳转到全局标记</span><br><span class="line">``      跳回之前的位置</span><br></pre></td></tr></table></figure><h3 id="进阶控制命令"><a href="#进阶控制命令" class="headerlink" title="进阶控制命令"></a>进阶控制命令</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">]], [[  Follow the link labeled &apos;next&apos; or &apos;&gt;&apos; (&apos;previous&apos; or &apos;&lt;&apos;)</span><br><span class="line">          - helpful for browsing paginated sites</span><br><span class="line">&lt;a-f&gt;   open multiple links in a new tab</span><br><span class="line">gi      focus the first (or n-th) text input box on the page</span><br><span class="line">gu      跳转到当前网址的上一级网址</span><br><span class="line">gU      跳转到当前网址的跟网址</span><br><span class="line">ge      编辑当前的网址，在当前页面打开</span><br><span class="line">gE      编辑当前网址，在新的页面打开</span><br><span class="line">zH      滚动到最左边</span><br><span class="line">zL      滚动到最右边</span><br><span class="line">v       enter visual mode; use p/P to paste-and-go, use y to yank</span><br><span class="line">V       enter visual line mode</span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5t      数字num + t，打开num个tab页面</span><br><span class="line">&lt;Esc&gt;   ESC按钮，可以从任意控制命令中退出，也可以从任意模式中退出（例如插入模式、查找模式）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;vimium&quot;&gt;&lt;a href=&quot;#vimium&quot; class=&quot;headerlink&quot; title=&quot;vimium&quot;&gt;&lt;/a&gt;vimium&lt;/h2&gt;&lt;p&gt;Vimium 这个名字其实是 Vim 和 Chromium 的合体。很多人可能不知道 Vim，Vim 其实是
      
    
    </summary>
    
      <category term="浏览器" scheme="https://www.zhangqifei.top/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="Chrome" scheme="https://www.zhangqifei.top/tags/Chrome/"/>
    
  </entry>
  
</feed>
